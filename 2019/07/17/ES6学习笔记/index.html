<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css">

<script class="next-config" data-name="main" type="application/json">{&quot;hostname&quot;:&quot;www.wjqixige.cn&quot;,&quot;root&quot;:&quot;&#x2F;&quot;,&quot;images&quot;:&quot;&#x2F;images&quot;,&quot;scheme&quot;:&quot;Gemini&quot;,&quot;version&quot;:&quot;8.3.0&quot;,&quot;exturl&quot;:false,&quot;sidebar&quot;:{&quot;position&quot;:&quot;left&quot;,&quot;display&quot;:&quot;post&quot;,&quot;padding&quot;:18,&quot;offset&quot;:12},&quot;copycode&quot;:false,&quot;bookmark&quot;:{&quot;enable&quot;:false,&quot;color&quot;:&quot;#222&quot;,&quot;save&quot;:&quot;auto&quot;},&quot;fancybox&quot;:false,&quot;mediumzoom&quot;:false,&quot;lazyload&quot;:false,&quot;pangu&quot;:false,&quot;comments&quot;:{&quot;style&quot;:&quot;tabs&quot;,&quot;active&quot;:null,&quot;storage&quot;:true,&quot;lazyload&quot;:false,&quot;nav&quot;:null},&quot;motion&quot;:{&quot;enable&quot;:false,&quot;async&quot;:false,&quot;transition&quot;:{&quot;post_block&quot;:&quot;fadeIn&quot;,&quot;post_header&quot;:&quot;fadeInDown&quot;,&quot;post_body&quot;:&quot;fadeInDown&quot;,&quot;coll_header&quot;:&quot;fadeInLeft&quot;,&quot;sidebar&quot;:&quot;fadeInUp&quot;}},&quot;prism&quot;:false,&quot;i18n&quot;:{&quot;placeholder&quot;:&quot;搜索...&quot;,&quot;empty&quot;:&quot;没有找到任何搜索结果：${query}&quot;,&quot;hits_time&quot;:&quot;找到 ${hits} 个搜索结果（用时 ${time} 毫秒）&quot;,&quot;hits&quot;:&quot;找到 ${hits} 个搜索结果&quot;}}</script>
<meta name="description" content="持续关注前端新特性，笔记随理解和经验的深入不断的更新。 12345## node：v12.2.0；npm: 大于5.2.0git clone https:&#x2F;&#x2F;github.com&#x2F;cucygh&#x2F;es-cli.gitcd es-clinpm installnpm start">
<meta property="og:type" content="article">
<meta property="og:title" content="ES6学习笔记">
<meta property="og:url" content="http://www.wjqixige.cn/2019/07/17/ES6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="栖溪阁晓生">
<meta property="og:description" content="持续关注前端新特性，笔记随理解和经验的深入不断的更新。 12345## node：v12.2.0；npm: 大于5.2.0git clone https:&#x2F;&#x2F;github.com&#x2F;cucygh&#x2F;es-cli.gitcd es-clinpm installnpm start">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://www.wjqixige.cn/2019/07/17/ES6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/wj004.png">
<meta property="og:image" content="http://www.wjqixige.cn/2019/07/17/ES6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/wj005.png">
<meta property="og:image" content="http://www.wjqixige.cn/2019/07/17/ES6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/wj006.png">
<meta property="og:image" content="http://www.wjqixige.cn/2019/07/17/ES6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/wj007.png">
<meta property="article:published_time" content="2019-07-17T03:10:10.000Z">
<meta property="article:modified_time" content="2021-05-14T14:49:53.033Z">
<meta property="article:author" content="Mr.wj">
<meta property="article:tag" content="es6">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://www.wjqixige.cn/2019/07/17/ES6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/wj004.png">


<link rel="canonical" href="http://www.wjqixige.cn/2019/07/17/ES6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">



<script class="next-config" data-name="page" type="application/json">{&quot;sidebar&quot;:&quot;&quot;,&quot;isHome&quot;:false,&quot;isPost&quot;:true,&quot;lang&quot;:&quot;zh-CN&quot;,&quot;comments&quot;:true,&quot;permalink&quot;:&quot;http:&#x2F;&#x2F;www.wjqixige.cn&#x2F;2019&#x2F;07&#x2F;17&#x2F;ES6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0&#x2F;&quot;,&quot;path&quot;:&quot;2019&#x2F;07&#x2F;17&#x2F;ES6学习笔记&#x2F;&quot;,&quot;title&quot;:&quot;ES6学习笔记&quot;}</script>

<script class="next-config" data-name="calendar" type="application/json">&quot;&quot;</script>
<title>ES6学习笔记 | 栖溪阁晓生</title><script src="/js/config.js"></script>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">栖溪阁晓生</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">个人在线笔记本</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80%E3%80%81ES6-2015"><span class="nav-text">一、ES6(2015)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#01%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-text">01、什么是作用域</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E4%BB%80%E4%B9%88%E6%98%AF%E4%BD%9C%E7%94%A8%E5%9F%9F%EF%BC%9F"><span class="nav-text">1.1 什么是作用域？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E5%85%A8%E5%B1%80%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-text">1.2 全局作用域</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-%E5%87%BD%E6%95%B0%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-text">1.3 函数作用域</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-%E5%9D%97%E7%8A%B6%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-text">1.4 块状作用域</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-%E5%8A%A8%E6%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-text">1.5 动态作用域</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%A9%E5%B1%95%E9%98%85%E8%AF%BB"><span class="nav-text">@ 扩展阅读</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#02%E3%80%81let%E5%92%8Cconst"><span class="nav-text">02、let和const</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-Let"><span class="nav-text">2.1 Let</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-1-let-%E5%A3%B0%E6%98%8E%E7%9A%84%E5%8F%98%E9%87%8F%E6%8B%A5%E6%9C%89%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-text">2.1.1 let 声明的变量拥有块级作用域</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-2-let-%E5%A3%B0%E6%98%8E%E7%9A%84%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E4%B8%8D%E6%98%AF%E5%85%A8%E5%B1%80%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="nav-text">2.1.2 let 声明的全局变量不是全局对象的属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-3-%E7%94%A8let%E9%87%8D%E5%AE%9A%E4%B9%89%E5%8F%98%E9%87%8F%E4%BC%9A%E6%8A%9B%E5%87%BA%E4%B8%80%E4%B8%AA%E8%AF%AD%E6%B3%95%E9%94%99%E8%AF%AF"><span class="nav-text">2.1.3 用let重定义变量会抛出一个语法错误</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-4-let%E5%A3%B0%E6%98%8E%E7%9A%84%E5%8F%98%E9%87%8F%E4%B8%8D%E4%BC%9A%E8%BF%9B%E8%A1%8C%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87"><span class="nav-text">2.1.4 let声明的变量不会进行变量提升</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-Const"><span class="nav-text">2.2 Const</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%A9%E5%B1%95%E9%98%85%E8%AF%BB-1"><span class="nav-text">@ 扩展阅读</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#03%E3%80%81%E6%95%B0%E7%BB%84-Array"><span class="nav-text">03、数组-Array</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-for%E2%80%A6of"><span class="nav-text">3.1 for…of</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-Array-prototype-from"><span class="nav-text">3.2 Array.prototype.from()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-Array-prototype-of"><span class="nav-text">3.3 Array.prototype.of()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-Array-prototype-fill"><span class="nav-text">3.4 Array.prototype.fill()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-Array-prototype-find"><span class="nav-text">3.5 Array.prototype.find()</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%9D%E8%80%83"><span class="nav-text">思考</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-Array-prototype-findIndex"><span class="nav-text">3.6 Array.prototype.findIndex()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%A9%E5%B1%95%E9%98%85%E8%AF%BB-2"><span class="nav-text">@ 扩展阅读</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#04%E3%80%81Class"><span class="nav-text">04、Class</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-Intro"><span class="nav-text">4.1 Intro</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-Basic-Syntax"><span class="nav-text">4.2 Basic Syntax</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-Setters-amp-Getters"><span class="nav-text">4.3 Setters &amp; Getters</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-Static-Methods"><span class="nav-text">4.4 Static Methods</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-5-Sub-Classes"><span class="nav-text">4.5 Sub Classes</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%A9%E5%B1%95%E9%98%85%E8%AF%BB-3"><span class="nav-text">@ 扩展阅读</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#05%E3%80%81Function"><span class="nav-text">05、Function</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-Default-Parameters"><span class="nav-text">5.1 Default Parameters</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-Rest-Parameter"><span class="nav-text">5.2 Rest Parameter</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-Spread-Operator"><span class="nav-text">5.3 Spread Operator</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-4-Arrow-Function"><span class="nav-text">5.4 Arrow Function</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%A9%E5%B1%95%E9%98%85%E8%AF%BB-4"><span class="nav-text">@ 扩展阅读</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#06%E3%80%81Object"><span class="nav-text">06、Object</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-Enhanced-Object-Properties"><span class="nav-text">6.1 Enhanced Object Properties</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-Set"><span class="nav-text">6.2 Set</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-Map"><span class="nav-text">6.3 Map</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-4-Object-assign"><span class="nav-text">6.4 Object.assign()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%A9%E5%B1%95%E9%98%85%E8%AF%BB-5"><span class="nav-text">@ 扩展阅读</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#07%E3%80%81RegExp"><span class="nav-text">07、RegExp</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-1-Sticky"><span class="nav-text">7.1 Sticky</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-Unicode"><span class="nav-text">7.2 Unicode</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%A9%E5%B1%95%E9%98%85%E8%AF%BB-6"><span class="nav-text">@ 扩展阅读</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#08%E3%80%81Template"><span class="nav-text">08、Template</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#8-1-String-Literals"><span class="nav-text">8.1 String Literals</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-2-Tag-Literals"><span class="nav-text">8.2 Tag Literals</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%A9%E5%B1%95%E9%98%85%E8%AF%BB-7"><span class="nav-text">@ 扩展阅读</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#09%E3%80%81Desctructuring"><span class="nav-text">09、Desctructuring</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#9-1-Array-Destructuring"><span class="nav-text">9.1 Array Destructuring</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-2-Object-Destructuring"><span class="nav-text">9.2 Object Destructuring</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%A9%E5%B1%95%E9%98%85%E8%AF%BB-8"><span class="nav-text">@ 扩展阅读</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10%E3%80%81Promise"><span class="nav-text">10、Promise</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#10-1-Callbacks"><span class="nav-text">10.1 Callbacks</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-2-Promise-Syntax"><span class="nav-text">10.2 Promise Syntax</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-3-Promise-prototype-then"><span class="nav-text">10.3 Promise.prototype.then()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-4-Promise-resolve"><span class="nav-text">10.4 Promise.resolve()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-4-Promise-reject"><span class="nav-text">10.4 Promise.reject()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-5-Promise-prototype-catch"><span class="nav-text">10.5 Promise.prototype.catch()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-6-Promise-all"><span class="nav-text">10.6 Promise.all()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-7-Promise-race"><span class="nav-text">10.7 Promise.race()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%A9%E5%B1%95%E9%98%85%E8%AF%BB-9"><span class="nav-text">@ 扩展阅读</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11%E3%80%81Reflect"><span class="nav-text">11、Reflect</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#11-1-Reflect-apply"><span class="nav-text">11.1 Reflect.apply()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-2-Reflect-construct"><span class="nav-text">11.2 Reflect.construct()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-3-Reflect-defineProperty"><span class="nav-text">11.3 Reflect.defineProperty()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-4-Reflect-deleteProperty"><span class="nav-text">11.4 Reflect.deleteProperty()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-5-Reflect-get"><span class="nav-text">11.5 Reflect.get()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-6-Reflect-getOwnPropertyDescriptor"><span class="nav-text">11.6 Reflect.getOwnPropertyDescriptor()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-7-Reflect-getPrototypeOf"><span class="nav-text">11.7 Reflect.getPrototypeOf()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-8-Reflect-has"><span class="nav-text">11.8 Reflect.has()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-9-Reflect-isExtensible"><span class="nav-text">11.9 Reflect.isExtensible()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-10-Reflect-ownKeys"><span class="nav-text">11.10 Reflect.ownKeys()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-11-Reflect-preventExtensions"><span class="nav-text">11.11 Reflect.preventExtensions()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-12-Reflect-set"><span class="nav-text">11.12 Reflect.set()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-13-Reflect-setPrototypeOf"><span class="nav-text">11.13 Reflect.setPrototypeOf()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%A9%E5%B1%95%E9%98%85%E8%AF%BB-10"><span class="nav-text">@ 扩展阅读</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12%E3%80%81Proxy"><span class="nav-text">12、Proxy</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#12-1-Basic-Syntax"><span class="nav-text">12.1 Basic Syntax</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-2-Schema-Validation"><span class="nav-text">12.2 Schema Validation</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-3-Revocable-Proxies"><span class="nav-text">12.3 Revocable Proxies</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%A9%E5%B1%95%E9%98%85%E8%AF%BB-11"><span class="nav-text">@ 扩展阅读</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13%E3%80%81Generator"><span class="nav-text">13、Generator</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#13-1-Intro"><span class="nav-text">13.1 Intro</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-2-Basic-Syntax"><span class="nav-text">13.2 Basic Syntax</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#13-2-1-%E8%AF%AD%E6%B3%95"><span class="nav-text">13.2.1 语法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#13-2-2-yield-%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-text">13.2.2 yield 表达式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#13-2-3-%E6%96%B9%E6%B3%95"><span class="nav-text">13.2.3 方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Scene-Practice"><span class="nav-text">Scene Practice</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%BA%E6%99%AF1"><span class="nav-text">场景1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%BA%E6%99%AF2"><span class="nav-text">场景2</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%A9%E5%B1%95%E9%98%85%E8%AF%BB-12"><span class="nav-text">@ 扩展阅读</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14%E3%80%81Iterator"><span class="nav-text">14、Iterator</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#14-1-Iterable"><span class="nav-text">14.1 Iterable</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-2-Iterator"><span class="nav-text">14.2 Iterator</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%A9%E5%B1%95%E9%98%85%E8%AF%BB-13"><span class="nav-text">@ 扩展阅读</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#15%E3%80%81module"><span class="nav-text">15、module</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#15-1-export"><span class="nav-text">15.1 export</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-2-import"><span class="nav-text">15.2 import</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%A9%E5%B1%95%E9%98%85%E8%AF%BB-14"><span class="nav-text">@ 扩展阅读</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E3%80%81ES7-2016"><span class="nav-text">二、ES7(2016)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#01%E3%80%81Array-prototype-includes"><span class="nav-text">01、Array.prototype.includes</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#02%E3%80%81Math-pow"><span class="nav-text">02、Math.pow</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%89%E3%80%81ES8-2017"><span class="nav-text">三、ES8(2017)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#01%E3%80%81Async-Await"><span class="nav-text">01、Async&#x2F;Await</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#02%E3%80%81Object-values-Object-keys"><span class="nav-text">02、Object.values()&#x2F;Object.keys()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#03%E3%80%81Object-entries"><span class="nav-text">03、Object.entries</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#04%E3%80%81String-padding"><span class="nav-text">04、String padding</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#05%E3%80%81Object-getOwnPropertyDescriptors"><span class="nav-text">05、Object.getOwnPropertyDescriptors()</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#refernce"><span class="nav-text">refernce</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%9B%E3%80%81ES9-2018"><span class="nav-text">四、ES9(2018)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#01%E3%80%81for-await-of"><span class="nav-text">01、for await of</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#02%E3%80%81Promise-prototype-finally"><span class="nav-text">02、Promise.prototype.finally()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#03%E3%80%81Object-Rest-amp-Spread"><span class="nav-text">03、Object Rest&amp;Spread</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#04%E3%80%81RegExp-Updates"><span class="nav-text">04、RegExp Updates</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-s-dotAll-flag"><span class="nav-text">1 s (dotAll) flag</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-named-capture-groups"><span class="nav-text">2 named capture groups</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-Lookbehind-Assertions"><span class="nav-text">3 Lookbehind Assertions</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-Unicode-Property-Escapes"><span class="nav-text">4 Unicode Property Escapes</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%A9%E5%B1%95%E9%98%85%E8%AF%BB-15"><span class="nav-text">@ 扩展阅读</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%94%E3%80%81ES10-2019"><span class="nav-text">五、ES10(2019)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#01%E3%80%81JSON-stringify"><span class="nav-text">01、JSON.stringify()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#02%E3%80%81Array-prototype-flat"><span class="nav-text">02、Array.prototype.flat()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#03%E3%80%81Array-prototype-flatMap"><span class="nav-text">03、Array.prototype.flatMap()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#04%E3%80%81String-prototype-trimStart"><span class="nav-text">04、String.prototype.trimStart()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#05%E3%80%81String-prototype-trimEnd"><span class="nav-text">05、String.prototype.trimEnd()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#06%E3%80%81String-prototype-matchAll"><span class="nav-text">06、String.prototype.matchAll()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#07%E3%80%81Object-fromEntries"><span class="nav-text">07、Object.fromEntries()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#08%E3%80%81Symbol-prototype-description"><span class="nav-text">08、Symbol.prototype.description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#09%E3%80%81Function-prototype-toString"><span class="nav-text">09、Function.prototype.toString()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10%E3%80%81try%E2%80%A6catch"><span class="nav-text">10、try…catch</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11%E3%80%81BigInt"><span class="nav-text">11、BigInt</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%A9%E5%B1%95%E9%98%85%E8%AF%BB-16"><span class="nav-text">@ 扩展阅读</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%82%E8%80%83"><span class="nav-text">参考</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%AD%E3%80%81ES11-2020"><span class="nav-text">六、ES11(2020)</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <a href="/"><img class="site-author-image" itemprop="image" alt="Mr.wj" src="/uploads/logo.jpg"></a>
  <p class="site-author-name" itemprop="name">Mr.wj</p>
  <div class="site-description" itemprop="description">欢迎来到栖息阁晓生博客</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">54</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">37</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/gadekuoen/wjqixige" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;gadekuoen&#x2F;wjqixige" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/wujiang569@126.com" title="E-Mail → wujiang569@126.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://me.csdn.net/weixin_39455881" title="CSDN → https:&#x2F;&#x2F;me.csdn.net&#x2F;weixin_39455881" rel="noopener" target="_blank"><i class="crosshairs fa-fw"></i>CSDN</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/2983932047/profile?rightmod=1&wvr=6&mod=personinfo&is_all=1" title="微博 → https:&#x2F;&#x2F;weibo.com&#x2F;2983932047&#x2F;profile?rightmod&#x3D;1&amp;wvr&#x3D;6&amp;mod&#x3D;personinfo&amp;is_all&#x3D;1" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>微博</a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.wjqixige.cn/2019/07/17/ES6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/logo.jpg">
      <meta itemprop="name" content="Mr.wj">
      <meta itemprop="description" content="欢迎来到栖息阁晓生博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="栖溪阁晓生">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          ES6学习笔记
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-07-17 11:10:10" itemprop="dateCreated datePublished" datetime="2019-07-17T11:10:10+08:00">2019-07-17</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-05-14 22:49:53" itemprop="dateModified" datetime="2021-05-14T22:49:53+08:00">2021-05-14</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/ES6/" itemprop="url" rel="index"><span itemprop="name">ES6</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>持续关注前端新特性，笔记随理解和经验的深入不断的更新。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## node：v12.2.0；npm: 大于5.2.0</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/cucygh/es-cli.git</span><br><span class="line"><span class="built_in">cd</span> es-cli</span><br><span class="line">npm install</span><br><span class="line">npm start</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h1 id="一、ES6-2015"><a href="#一、ES6-2015" class="headerlink" title="一、ES6(2015)"></a>一、ES6(2015)</h1><h2 id="01、什么是作用域"><a href="#01、什么是作用域" class="headerlink" title="01、什么是作用域"></a>01、什么是作用域</h2><h3 id="1-1-什么是作用域？"><a href="#1-1-什么是作用域？" class="headerlink" title="1.1 什么是作用域？"></a>1.1 什么是作用域？</h3><p>作用域是在运行时代码中的某些特定部分中变量，函数和对象的可访问性。换句话说，作用域决定了代码区块中变量和其他资源的可见性。通俗的来讲，作用域其实就是一个独立的地盘，让变量不会泄露出去。常见的作用域主要分为几个类型：全局作用域、函数作用域、块状作用域、动态作用域。</p>
<table>
<thead>
<tr>
<th align="left">对象</th>
<th align="left">类型</th>
</tr>
</thead>
<tbody><tr>
<td align="left">global/window</td>
<td align="left">全局作用域</td>
</tr>
<tr>
<td align="left">function</td>
<td align="left">函数作用域（局部作用域）</td>
</tr>
<tr>
<td align="left">{}</td>
<td align="left">块状作用域</td>
</tr>
<tr>
<td align="left">this</td>
<td align="left">动态作用域</td>
</tr>
</tbody></table>
<blockquote>
<p>[!TIP]<br>如果一个 变量 或者其他表达式不在 “当前的作用域”，那么JavaScript机制会继续沿着作用域链向上查找直到全局作用域（global或浏览器中的window）如果找不到将不可被使用。 作用域也可以根据代码层次分层，以便子作用域可以访问父作用域，通常是指沿着链式的作用域链查找，而不能从父作用域引用子作用域中的变量和引用</p>
</blockquote>
<h3 id="1-2-全局作用域"><a href="#1-2-全局作用域" class="headerlink" title="1.2 全局作用域"></a>1.2 全局作用域</h3><p>变量在函数或者代码块<code>&#123;&#125;</code>外定义，即为全局作用域。不过，在函数或者代码块<code>&#123;&#125;</code>内未定义的变量也是拥有全局作用域的（不推荐）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> carName = <span class="string">&quot;Volvo&quot;</span>;</span><br><span class="line"><span class="comment">// 此处可调用 carName 变量</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 函数内可调用 carName 变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码中变量 <code>carName</code> 就是在函数外定义的，它是拥有全局作用域的。这个变量可以在任意地方被读取或者修改，当然如果变量在函数内没有声明（没有使用 var 关键字），该变量依然为全局变量。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此处可调用 carName 变量</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     carName = <span class="string">&quot;Volvo&quot;</span>;</span><br><span class="line">    <span class="comment">// 此处可调用 carName 变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上实例中 carName 在函数内，但是拥有全局作用域，它将作为 global 或者 window 的属性存在。</p>
<blockquote>
<p>[!Warning]<br>在函数内部或代码块中没有定义的变量实际上是作为 window/global 的属性存在，而不是全局变量。换句话说没有使用 var 定义的变量虽然拥有全局作用域，但是它是可以被 delete 的，而全局变量不可以。</p>
</blockquote>
<blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://www.runoob.com/js/js-scope.html">https://www.runoob.com/js/js-scope.html</a></p>
</blockquote>
<h3 id="1-3-函数作用域"><a href="#1-3-函数作用域" class="headerlink" title="1.3 函数作用域"></a>1.3 函数作用域</h3><p>在函数内部定义的变量，就是局部作用域。函数作用域内，对外是封闭的，从外层的作用域无法直接访问函数内部的作用域！</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> testValue = <span class="string">&#x27;inner&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(testValue);		<span class="comment">// 报错：ReferenceError: testValue is not defined</span></span><br></pre></td></tr></table></figure>

<p>如果想读取函数内的变量，必须借助 return 或者闭包。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> testValue = <span class="string">&#x27;inner&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> testValue + value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(bar(<span class="string">&#x27;fun&#x27;</span>));		<span class="comment">// &quot;innerfun&quot;</span></span><br></pre></td></tr></table></figure>

<p>这是借助 return 的方式，下面是闭包的方式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> testValue = <span class="string">&#x27;inner&#x27;</span>;</span><br><span class="line">  <span class="keyword">var</span> rusult = testValue + value;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">innser</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> rusult;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> innser();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(bar(<span class="string">&#x27;fun&#x27;</span>));		<span class="comment">// &quot;innerfun&quot;</span></span><br></pre></td></tr></table></figure>

<p>通俗的讲，return 是函数对外交流的出口，而 return 可以返回的是函数，根据作用域的规则，函数内部的子函数是可以获取函数作用域内的变量的。</p>
<h3 id="1-4-块状作用域"><a href="#1-4-块状作用域" class="headerlink" title="1.4 块状作用域"></a>1.4 块状作用域</h3><p>在JavaScript中块状作用域不被支持，就像上述知识一样，除了全局作用域就是函数作用域，一直没有自己的块状作用域。在 ES6 中已经改变了这个现象，块状作用域得到普及。关于什么是块，只要认识 <code>&#123;&#125;</code> 就可以了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line">  <span class="built_in">console</span>.log(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个代码中，<code> if 后 &#123;&#125;</code> 就是“块”，这个里面的变量就是拥有这个块状作用域，按照规则，<code>&#123;&#125;</code> 之外是无法访问这个变量的。</p>
<h3 id="1-5-动态作用域"><a href="#1-5-动态作用域" class="headerlink" title="1.5 动态作用域"></a>1.5 动态作用域</h3><p>在 JavaScript 中对 this 的指向时而清楚时而模糊，其实结合作用域会对 this 有一个清晰的理解。不妨先来看下这段代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.a = <span class="number">3</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test.bind(&#123; <span class="attr">a</span>: <span class="number">2</span> &#125;)() <span class="comment">// 2</span></span><br><span class="line">test() <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>在这里 bind 已经把作用域的范围进行了修改指向了 <code>&#123; a: 2 &#125;</code>，而 this 指向的是当前作用域对象。接下来我们再思考另一个问题：作用域是在代码编写的时候就已经决定了呢，还是在代码执行的过程中才决定的？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> carName = <span class="string">&quot; Volvo&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此处可调用 carName 变量</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 函数内可调用 carName 变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在看看这段代码，写代码的时候就知道 carName 就是全局作用域，函数内部的用 var 定义的变量就是函数作用域。这个也就是专业术语：词法作用域。通俗的讲变量的作用域是在定义时决定而不是执行时决定，也就是说词法作用域取决于源码，通过静态分析就能确定，因此词法作用域也叫做静态作用域。相反，只能在执行阶段才能决定变量的作用域，那就是动态作用域。看看下面的代码是遵循了动态作用域还是静态作用域呢？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(a); <span class="comment">// 2  (不是 3!)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">	foo();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">bar();</span><br></pre></td></tr></table></figure>

<p>为什么会这样？</p>
<p>如果按照动态作用域分析：当 foo() 不能为 a 解析出一个变量引用时，它不会沿着嵌套的作用域链向上走一层，而是沿着调用栈向上走，以找到 foo() 是 从何处 被调用的。因为 foo() 是从 bar() 中被调用的，它就会在 bar() 的作用域中检查变量，并且在这里找到持有值 3 的 a。</p>
<p>如果按照静态作用域分析：foo执行的时候没有找到 a 这个变量，它会按照代码书写的顺序往上找，也就是 foo 定义的外层，就找到了 var a=2 ，而不是 foo 调用的 bar 内找。所以结果就是 2。</p>
<p>从这个示例可以看出 JavaScript 默认采用词法（静态）作用域，如果要开启动态作用域请借助 bind、with、eval 等。</p>
<h3 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="@ 扩展阅读"></a>@ 扩展阅读</h3><ol>
<li>什么是作用域：<a target="_blank" rel="noopener" href="https://www.kancloud.cn/kancloud/you-dont-know-js-scope-closures/516610">https://www.kancloud.cn/kancloud/you-dont-know-js-scope-closures/516610</a></li>
<li>JavaScript深入之词法作用域和动态作用域：<a target="_blank" rel="noopener" href="https://github.com/mqyqingfeng/Blog/issues/3">https://github.com/mqyqingfeng/Blog/issues/3</a></li>
<li>深入理解JS中声明提升、作用域（链）和<code>this</code>关键字：<a target="_blank" rel="noopener" href="https://github.com/creeperyang/blog/issues/16">https://github.com/creeperyang/blog/issues/16</a></li>
</ol>
<h2 id="02、let和const"><a href="#02、let和const" class="headerlink" title="02、let和const"></a>02、let和const</h2><p>知道了作用域，就很好理解 Let 和 Const 的作用了，它可以让变量声明更加完美。</p>
<h3 id="2-1-Let"><a href="#2-1-Let" class="headerlink" title="2.1 Let"></a>2.1 Let</h3><h4 id="2-1-1-let-声明的变量拥有块级作用域"><a href="#2-1-1-let-声明的变量拥有块级作用域" class="headerlink" title="2.1.1 let 声明的变量拥有块级作用域"></a>2.1.1 let 声明的变量拥有块级作用域</h4><p>这个其实在讲作用域的时候应该就很明确了，可以看下代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>

<p><code>a</code>变量是在代码块<code>&#123;&#125;</code>中使用 let 定义的，它的作用域是这个代码块内部，外部无法访问。</p>
<h4 id="2-1-2-let-声明的全局变量不是全局对象的属性"><a href="#2-1-2-let-声明的全局变量不是全局对象的属性" class="headerlink" title="2.1.2 let 声明的全局变量不是全局对象的属性"></a>2.1.2 let 声明的全局变量不是全局对象的属性</h4><p>这就意味着，你不可以通过 <code>window.变量名</code> 的方式访问这些变量，而 var 声明的全局变量是 window 的属性，是可以通过 window.变量名 的方式访问的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.a); <span class="comment">//1</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.a); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<h4 id="2-1-3-用let重定义变量会抛出一个语法错误"><a href="#2-1-3-用let重定义变量会抛出一个语法错误" class="headerlink" title="2.1.3 用let重定义变量会抛出一个语法错误"></a>2.1.3 用let重定义变量会抛出一个语法错误</h4><p>这个很容易理解，使用 var 可以重复定义，使用 let 却不可以。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span></span><br><span class="line"><span class="built_in">console</span>.log(a)  <span class="comment">//2</span></span><br></pre></td></tr></table></figure>

<p>如果是 let ，则会报错</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">2</span></span><br><span class="line"><span class="comment">// VM131:1 Uncaught SyntaxError: Identifier &#x27;a&#x27; has already been declared at &lt;anonymous&gt;:1:1</span></span><br></pre></td></tr></table></figure>

<h4 id="2-1-4-let声明的变量不会进行变量提升"><a href="#2-1-4-let声明的变量不会进行变量提升" class="headerlink" title="2.1.4 let声明的变量不会进行变量提升"></a>2.1.4 let声明的变量不会进行变量提升</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a)</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test() <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>

<p>上述代码中，<code>a</code> 的调用在声明之前，所以它的值是 undefined，而不是 Uncaught ReferenceError。实际上因为 var 会导致变量提升，上述代码和下面的代码等同：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a</span><br><span class="line">  <span class="built_in">console</span>.log(a)</span><br><span class="line">  a = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test() <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>

<p>而对于 let 而言，变量的调用是不能先于声明的，看如下代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a)</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test()</span><br><span class="line"><span class="comment">// Uncaught ReferenceError: Cannot access &#x27;a&#x27; before initialization</span></span><br></pre></td></tr></table></figure>

<p>在这个代码中，<code>a</code> 的调用是在声明之前，因为 let 没有发生变量提升，所有读取 a 的时候，并没有找到，而在调用之后才找到 let 对 <code>a</code> 的定义，所以按照 tc39 的定义会报错。</p>
<h3 id="2-2-Const"><a href="#2-2-Const" class="headerlink" title="2.2 Const"></a>2.2 Const</h3><p><code>const</code>除了具有<code>let</code>的块级作用域和不会变量提升外，还有就是它定义的是常量，在用<code>const</code>定义变量后，我们就不能修改它了，对变量的修改会抛出异常。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PI = <span class="number">3.1415</span>;</span><br><span class="line"><span class="built_in">console</span>.log(PI);</span><br><span class="line">PI = <span class="number">22</span>;</span><br><span class="line"><span class="built_in">console</span>.log(PI);</span><br><span class="line"><span class="comment">// Uncaught TypeError: Assignment to constant variable.</span></span><br></pre></td></tr></table></figure>

<p>这个代码块中因为对 <code>PI</code> 尝试修改，导致浏览器报错，这就说明 const 定义的变量是不能被修改的，它是只读的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PI</span><br><span class="line">PI = <span class="number">3.1415</span></span><br><span class="line"><span class="comment">// Uncaught SyntaxError: Missing initializer in const declaration</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>[!DANGER]<br>const 声明的变量必须进行初始化，不然会抛出异常 Uncaught SyntaxError: Missing initializer in const declaration。</p>
</blockquote>
<h3 id="扩展阅读-1"><a href="#扩展阅读-1" class="headerlink" title="@ 扩展阅读"></a>@ 扩展阅读</h3><ol>
<li>内存管理：<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Memory_Management">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Memory_Management</a></li>
</ol>
<h2 id="03、数组-Array"><a href="#03、数组-Array" class="headerlink" title="03、数组-Array"></a>03、数组-Array</h2><p>在 ES6 中新增了很多实用的原生 API，开发者对 Array 的操控性更强，如 for…of、from、of、fill、find、findIndex等。</p>
<h3 id="3-1-for…of"><a href="#3-1-for…of" class="headerlink" title="3.1 for…of"></a>3.1 for…of</h3><p>看这个名字就知道这个语法是用来遍历数组的，我们简单回忆下原始的数组遍历方法是怎样的？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(array[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>后来语法有所升级，到 ES5 遍历数组的 API 多了起来，其中有 forEach、every、filter等，同样的功能可以用 forEach 或者 every 来实现。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">array.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">i</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>这个语法看起来要简洁很多，不需要通过索引去访问数组项，然而它的缺点也是很明显，不支持 break、continue 等。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>].forEach(<span class="function"><span class="keyword">function</span>(<span class="params">i</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(i===<span class="number">2</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>这段代码的”本意”是从第一个元素开始遍历，遇到数组项 2 之后就结束遍历，不然打印出所遍历过的数值项。可是，事实让你大跌眼镜，因为它的输出是 1,3,4,5。</p>
<blockquote>
<p>[!DANGER]<br>forEach 的代码块中不能使用 break、continue，它会抛出异常。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>].every(<span class="function"><span class="keyword">function</span>(<span class="params">i</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(i===<span class="number">2</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>同样完成刚才的目标，使用 every 遍历就可以做到 break 那样的效果，简单的说 return false 等同于 break，return true 等同于 continue。如果不写，默认是 return false。</p>
<blockquote>
<p>[!DANGER]<br>every 的代码块中不能使用 break、continue，它会抛出异常。</p>
</blockquote>
<p>有的同学会说，还有 for…in 可以遍历数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> index <span class="keyword">in</span> array) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(array[index]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说的没错，for…in 确实可以遍历数组，而且还支持 continue、break等功能，但是它真的没有瑕疵吗？如果 array 有自定义属性，你发现也会被遍历出来(显然不合理)。这是因为 for…in 是为遍历对象创造的（{a:1,b:2}），不是为数组设计的。</p>
<blockquote>
<p>[!DANGER]<br>for…in代码块中不能有 return，不然会抛出异常。</p>
</blockquote>
<p>接下来就要步入正题，说说我们今天的主角：for…of。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> val <span class="keyword">of</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1,2,3</span></span><br></pre></td></tr></table></figure>

<p>上述代码中轻松实现了数组的遍历，乍一看没有觉得它有非常强大之处。我们不得不强调下，for…of 的来历和作用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (variable <span class="keyword">of</span> iterable) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看下这个伪代码，of 后面是 iterable 既不是 for 循环规定的 array，也不是 for…in 规定的 Object，而是 iterable。如果查查 iterable 的含义就很直观的感受到 for…of 遍历的是一切可遍历的元素（数组、对象、集合）等，不要小瞧这个功能，因为在 ES6 中允许开发者自定义遍历，换句话说任何数据结构都可以自定义一个遍历，这个遍历是不能被 for、for…in 理解和实现的。很抽象吧？我们来描述个场景吧。</p>
<blockquote>
<p>客户：老板给我来瓶最便宜的啤酒、最便宜的火腿肠、最便宜的打火机，多少钱？<br>商户：稍等，我算下</p>
</blockquote>
<p>作为程序员的我们需要考虑下数据结构，首先定一个价格对象 Price，然后为每个商品 A、B、C等定价，最后是根据用户的选择，输入系统并计算。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Price = &#123;</span><br><span class="line">  A: [<span class="number">1.5</span>, <span class="number">2.3</span>, <span class="number">4.5</span>],</span><br><span class="line">  B: [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>],</span><br><span class="line">  C: [<span class="number">0.5</span>, <span class="number">0.8</span>, <span class="number">1.2</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后给这个数据结构自定义遍历规则(Iterator)，希望对这个遍历之后可以输出 1.5、3、0.5。（先不要关心 Iterator 是怎么实现的，ES6的新增语法，后面会讲）。</p>
<p>面对这样的数据结构，for、forEach、every、for…in 都无能为力吧？使用 for…of 就木有问题，它就是为解决这种问题而生。</p>
<blockquote>
<p>[!TIP]<br>for…of是支持 break、continue的，所以在功能上非常贴近原生的 for。</p>
</blockquote>
<p><strong>思考</strong></p>
<ol>
<li>JavaScript 世界里有哪些元素是可遍历的？ 【数组，对象，集合】</li>
<li>如何给数据结构自定义遍历？【forof，自定义iterable规则】</li>
</ol>
<h3 id="3-2-Array-prototype-from"><a href="#3-2-Array-prototype-from" class="headerlink" title="3.2 Array.prototype.from()"></a>3.2 Array.prototype.from()</h3><p>数组是开发中经常用到的数据结构，它非常好用。在 JavaScript 的世界里有些对象被理解为数组，然而缺不能使用数组的原生 API，比如函数中的 arguments、DOM中的 NodeList等。当然，还有一些可遍历的对象，看上去都像数组却不能直接使用数组的 API，因为它们是伪数组（Array-Like）。要想对这些对象使用数组的 API 就要想办法把它们转化为数组，传统的做法是这样的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> args = [].slice.call(<span class="built_in">arguments</span>);</span><br><span class="line"><span class="keyword">let</span> imgs = [].slice.call(<span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;img&#x27;</span>));</span><br></pre></td></tr></table></figure>

<p>基本原理是使用 call 将数组的 api 应用在新的对象上，换句话说是利用改变函数的上下文来间接使用数组的 api。在 ES6 中提供了新的 api 来解决这个问题，就是 Array.from，代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> args = <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>);</span><br><span class="line"><span class="keyword">let</span> imgs = <span class="built_in">Array</span>.from(<span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;img&#x27;</span>));</span><br></pre></td></tr></table></figure>

<blockquote>
<p>[!TIP]<br>伪数组具备两个特征，1. 按索引方式储存数据 2. 具有length属性；如：<br>let arrLike = { 0: ‘a’, 1: ‘b’, 2: ‘c’, length: 3}</p>
</blockquote>
<p>难道 Array.from 只能用来将伪数组转换成数组吗，还有其他用法吗？这要来看下 Array.from 的几个参数：</p>
<p><strong>语法：</strong><code>Array.from(arrayLike[, mapFn[, thisArg]])</code></p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">含义</th>
<th align="left">必选</th>
</tr>
</thead>
<tbody><tr>
<td align="left">arrayLike</td>
<td align="left">想要转换成数组的伪数组对象或可迭代对象</td>
<td align="left">Y</td>
</tr>
<tr>
<td align="left">mapFn</td>
<td align="left">如果指定了该参数，新数组中的每个元素会执行该回调函数</td>
<td align="left">N</td>
</tr>
<tr>
<td align="left">thisArg</td>
<td align="left">可选参数，执行回调函数 mapFn 时 this 对象</td>
<td align="left">N</td>
</tr>
</tbody></table>
<p>看了这几个参数至少能看到 Array.from 还具备 map 的功能，比如我们想初始化一个长度为 5 的数组，每个数组元素默认为 1，之前的做法是这样的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = <span class="built_in">Array</span>(<span class="number">6</span>).join(<span class="string">&#x27; &#x27;</span>).split(<span class="string">&#x27;&#x27;</span>).map(<span class="function"><span class="params">item</span>=&gt;</span><span class="number">1</span>)</span><br><span class="line"><span class="comment">// [1,1,1,1,1]</span></span><br></pre></td></tr></table></figure>

<p>这样写虽然也能实现，但是用起来比较繁琐，使用 Array.from 就会简洁很多。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.from(&#123; <span class="attr">length</span>: <span class="number">5</span> &#125;, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="number">1</span> &#125;)</span><br></pre></td></tr></table></figure>

<p>这个代码看起来既简洁还容易理解，有咩有？</p>
<p><strong>思考</strong></p>
<ol>
<li>生成长度为 5 ，为何用的是 Array(6)； 【join函数返回的结果是一个有5个空格的字符串，所有再调用split之后返回的数组就是5了】</li>
</ol>
<h3 id="3-3-Array-prototype-of"><a href="#3-3-Array-prototype-of" class="headerlink" title="3.3 Array.prototype.of()"></a>3.3 Array.prototype.of()</h3><p>Array.of() 方法创建一个具有可变数量参数的新数组实例，而不考虑参数的数量或类型。</p>
<p>Array.of() 和 Array 构造函数之间的区别在于处理整数参数：Array.of(7) 创建一个具有单个元素 7 的数组，而 Array(7) 创建一个长度为7的空数组（注意：这是指一个有7个空位(empty)的数组，而不是由7个undefined组成的数组）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.of(<span class="number">7</span>);       <span class="comment">// [7]</span></span><br><span class="line"><span class="built_in">Array</span>.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>(<span class="number">7</span>);          <span class="comment">// [ , , , , , , ]</span></span><br><span class="line"><span class="built_in">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);    <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>

<p><strong>语法：</strong><code>Array.of(element0[, element1[, …[, elementN]]])</code></p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">含义</th>
<th align="left">必选</th>
</tr>
</thead>
<tbody><tr>
<td align="left">elementN</td>
<td align="left">任意个参数，将按顺序成为返回数组中的元素</td>
<td align="left">Y</td>
</tr>
</tbody></table>
<h3 id="3-4-Array-prototype-fill"><a href="#3-4-Array-prototype-fill" class="headerlink" title="3.4 Array.prototype.fill()"></a>3.4 Array.prototype.fill()</h3><p>fill() 方法用一个固定值填充一个数组中从起始索引到终止索引内的全部元素。不包括终止索引。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">array.fill(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="comment">// [1,0,3,4]</span></span><br></pre></td></tr></table></figure>

<p>这个操作是将 array 数组的第二个元素（索引为1）到第三个元素（索引为2）内的数填充为 0，不包括第三个元素，所以结果是 [1,0,3,4]</p>
<p><strong>技巧</strong></p>
<p>我们前面有提到用 Array.from 初始化为一个长度固定，元素为指定值的数组。如果用 fill 是否可以达到同样的效果呢？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>(<span class="number">5</span>).fill(<span class="number">1</span>)</span><br><span class="line"><span class="comment">// [1,1,1,1,1]</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>[!TIP]<br>fill 不具备遍历的功能，它是通过指定要操作的索引范围来进行，通过这道题目可以看出不指定索引会对所有元素进行操作</p>
</blockquote>
<p><strong>语法：</strong><code>arr.fill(value[, start[, end]])</code></p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">含义</th>
<th align="left">必选</th>
</tr>
</thead>
<tbody><tr>
<td align="left">value</td>
<td align="left">用来填充数组元素的值</td>
<td align="left">Y</td>
</tr>
<tr>
<td align="left">start</td>
<td align="left">起始索引，默认值为0</td>
<td align="left">N</td>
</tr>
<tr>
<td align="left">end</td>
<td align="left">终止索引，默认值为 this.length</td>
<td align="left">N</td>
</tr>
</tbody></table>
<h3 id="3-5-Array-prototype-find"><a href="#3-5-Array-prototype-find" class="headerlink" title="3.5 Array.prototype.find()"></a>3.5 Array.prototype.find()</h3><p>find() 方法返回数组中满足提供的测试函数的第一个元素的值，否则返回 undefined。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> array = [<span class="number">5</span>, <span class="number">12</span>, <span class="number">8</span>, <span class="number">130</span>, <span class="number">44</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> found = array.find(<span class="function"><span class="keyword">function</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> element &gt; <span class="number">10</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(found);</span><br><span class="line"><span class="comment">// 12</span></span><br></pre></td></tr></table></figure>

<p><strong>语法：</strong><code>arr.find(callback[, thisArg])</code></p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">含义</th>
<th align="left">必选</th>
</tr>
</thead>
<tbody><tr>
<td align="left">callback</td>
<td align="left">在数组每一项上执行的函数，接收 3 个参数，element、index、array</td>
<td align="left">Y</td>
</tr>
<tr>
<td align="left">thisArg</td>
<td align="left">执行回调时用作 this 的对象</td>
<td align="left">N</td>
</tr>
</tbody></table>
<h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h4><ol>
<li>find() 和 ES5 的 filter() 有什么区别？【find只返回第一次找到的元素，filter返回满足条件的所有元素】</li>
</ol>
<h3 id="3-6-Array-prototype-findIndex"><a href="#3-6-Array-prototype-findIndex" class="headerlink" title="3.6 Array.prototype.findIndex()"></a>3.6 Array.prototype.findIndex()</h3><p>findIndex()方法返回数组中满足提供的测试函数的第一个元素的索引。否则返回-1。其实这个和 find() 是成对的，不同的是它返回的是索引而不是值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> array = [<span class="number">5</span>, <span class="number">12</span>, <span class="number">8</span>, <span class="number">130</span>, <span class="number">44</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> found = array.findIndex(<span class="function"><span class="keyword">function</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> element &gt; <span class="number">10</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(found);</span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p><strong>语法：</strong><code>arr.findIndex(callback[, thisArg])</code></p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">含义</th>
<th align="left">必选</th>
</tr>
</thead>
<tbody><tr>
<td align="left">callback</td>
<td align="left">在数组每一项上执行的函数，接收 3 个参数，element、index、array</td>
<td align="left">Y</td>
</tr>
<tr>
<td align="left">thisArg</td>
<td align="left">执行回调时用作 this 的对象</td>
<td align="left">N</td>
</tr>
</tbody></table>
<h3 id="扩展阅读-2"><a href="#扩展阅读-2" class="headerlink" title="@ 扩展阅读"></a>@ 扩展阅读</h3><ol>
<li>Array：<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array</a></li>
</ol>
<h2 id="04、Class"><a href="#04、Class" class="headerlink" title="04、Class"></a>04、Class</h2><blockquote>
<p>Javascript是一种基于对象（object-based）的语言，你遇到的所有东西几乎都是对象。但是，它又不是一种真正的面向对象编程（OOP）语言，因为它的语法中没有class（类）。</p>
</blockquote>
<p>这是摘自阮一峰老师的博客，这句话放在 ES5 可以说不为过，然而到了 ES6 这么说就已经不严谨了。因为 ES6 中已经有了专属的 class 语法了。</p>
<p>有的同学喜欢函数式的编程方式，有的同学喜欢面向对象的编程思维，我们今天不论长短，重点讲述怎么使用 ES6 的 class 语法完成面向对象的开发。</p>
<h3 id="4-1-Intro"><a href="#4-1-Intro" class="headerlink" title="4.1 Intro"></a>4.1 Intro</h3><p>对于面向对象编程而言，更关注类的声明、属性、方法、静态方法、继承、多态、私有属性。</p>
<h3 id="4-2-Basic-Syntax"><a href="#4-2-Basic-Syntax" class="headerlink" title="4.2 Basic Syntax"></a>4.2 Basic Syntax</h3><p>首先我们要先来说明在 JavaScript 世界里如何声明一个 “类”。在 ES6 之前大家都是这么做的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> Animal = <span class="function"><span class="keyword">function</span> (<span class="params">type</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.type = type</span><br><span class="line">  <span class="built_in">this</span>.walk = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`I am walking`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> dog = <span class="keyword">new</span> Animal(<span class="string">&#x27;dog&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> monkey = <span class="keyword">new</span> Animal(<span class="string">&#x27;monkey&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>在上述代码中，我们定义了一个叫 Animal 的类，类中声明了一个属性 type、一个方法 walk；然后通过 new Animal 这个类生成实例，完成了类的定义和实例化。当然你也可以这样写：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> Animal = <span class="function"><span class="keyword">function</span> (<span class="params">type</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.type = type</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Animal.prototype.walk = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`I am walking`</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> dog = <span class="keyword">new</span> Animal(<span class="string">&#x27;dog&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> monkey = <span class="keyword">new</span> Animal(<span class="string">&#x27;monkey&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>在 ES6 中把类的声明专业化了，不在用 function 的方式了，请看：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="title">constructor</span> (<span class="params">type</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.type = type</span><br><span class="line">  &#125;</span><br><span class="line">  walk () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`I am walking`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> dog = <span class="keyword">new</span> Animal(<span class="string">&#x27;dog&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> monkey = <span class="keyword">new</span> Animal(<span class="string">&#x27;monkey&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>很明显，从定义上就很专业了，有构造函数、方法，但是 ES6 增加了新的数据类型 class 吗？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> Animal); <span class="comment">//function</span></span><br></pre></td></tr></table></figure>

<p>可以发现 class 的类型还是 function，和 ES5 貌似并没有什么区别，那么 class 中定义的方法在哪呢？我们知道只要是函数，就一定会有 prototype 对象。那么类的方法和 prototype 对象有什么关系呢？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(Animal.prototype);</span><br><span class="line"><span class="comment">// &#123;constructor: ƒ, walk: ƒ&#125;</span></span><br><span class="line"><span class="comment">//   constructor: class Animal</span></span><br><span class="line"><span class="comment">//   walk: ƒ walk()</span></span><br><span class="line"><span class="comment">//   __proto__:</span></span><br><span class="line"><span class="comment">//   constructor: ƒ Object()</span></span><br><span class="line"><span class="comment">//   hasOwnProperty: ƒ hasOwnProperty()</span></span><br><span class="line"><span class="comment">//   isPrototypeOf: ƒ isPrototypeOf()</span></span><br><span class="line"><span class="comment">//   propertyIsEnumerable: ƒ propertyIsEnumerable()</span></span><br><span class="line"><span class="comment">//   toLocaleString: ƒ toLocaleString()</span></span><br><span class="line"><span class="comment">//   toString: ƒ toString()</span></span><br><span class="line"><span class="comment">//   valueOf: ƒ valueOf()</span></span><br><span class="line"><span class="comment">//   __defineGetter__: ƒ __defineGetter__()</span></span><br><span class="line"><span class="comment">//   __defineSetter__: ƒ __defineSetter__()</span></span><br><span class="line"><span class="comment">//   __lookupGetter__: ƒ __lookupGetter__()</span></span><br><span class="line"><span class="comment">//   __lookupSetter__: ƒ __lookupSetter__()</span></span><br><span class="line"><span class="comment">//   get __proto__: ƒ __proto__()</span></span><br><span class="line"><span class="comment">//   set __proto__: ƒ __proto__()</span></span><br></pre></td></tr></table></figure>

<p>可以看出在 Animal.prototype 对象上有两个方法，一个是构造函数（constructor）、一个是自定义的方法（walk）。这是不是和 ES5 的第二种写法一模一样？我们再来看下属性，在 ES5 中有个 API 用来判断对象的自有属性（hasOwnProperty）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(dog.hasOwnProperty(<span class="string">&#x27;type&#x27;</span>)); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>这个表现也和 ES5 中直接使用 function 定义类的方式相同，所以得出一个结论：<strong>class 的方式是 function 方式的语法糖。</strong></p>
<h3 id="4-3-Setters-amp-Getters"><a href="#4-3-Setters-amp-Getters" class="headerlink" title="4.3 Setters &amp; Getters"></a>4.3 Setters &amp; Getters</h3><p>对于类中的属性，可以直接在 constructor 中通过 this 直接定义，还可以直接在类的顶层来定义：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="title">constructor</span> (<span class="params">type, age</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.type = type</span><br><span class="line">    <span class="built_in">this</span>._age = age</span><br><span class="line">  &#125;</span><br><span class="line">  get age () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._age</span><br><span class="line">  &#125;</span><br><span class="line">  set age (val) &#123;</span><br><span class="line">    <span class="built_in">this</span>._age = val</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个代码演示了，通过 get/set 来给类定一个属性，不过貌似没有说服力。因为 age 和 <code>_age</code> 都是类的属性，而且是相同的含义这样做感觉没有实际用途。但是如果一个属性是个只读的呢？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="title">constructor</span> (<span class="params">type</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.type = type</span><br><span class="line">  &#125;</span><br><span class="line">  get addr () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;北京动物园&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>毋庸赘述，大家都能看出来含义。再来看下如下的应用场景：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomHTMLElement</span> </span>&#123;</span><br><span class="line">  <span class="title">constructor</span> (<span class="params">element</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.element = element</span><br><span class="line">  &#125;</span><br><span class="line">  get html () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.element.innerHTML</span><br><span class="line">  &#125;</span><br><span class="line">  set html (value) &#123;</span><br><span class="line">    <span class="built_in">this</span>.element.innerHTML = value</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>利用 set/get 实现了对 element.innerHTML 的简单封装。可是，有时候我们真的需要设置一个私有属性(闭包)，然后通过一定的规则来限制对它的修改，利用 set/get就可以轻松实现。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> #age = <span class="number">1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">type</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.type = type</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">age</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> #age</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> <span class="title">age</span>(<span class="params">val</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (val &gt; <span class="number">0</span> &amp;&amp; val &lt; <span class="number">10</span>) &#123;</span><br><span class="line">      #age = val</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-4-Static-Methods"><a href="#4-4-Static-Methods" class="headerlink" title="4.4 Static Methods"></a>4.4 Static Methods</h3><p>静态方法是面向对象最常用的功能，在 ES5 中利用 function 实现的类是这样实现一个静态方法的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> Animal = <span class="function"><span class="keyword">function</span> (<span class="params">type</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.type = type</span><br><span class="line">  <span class="built_in">this</span>.walk = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`I am walking`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Animal.eat = <span class="function"><span class="keyword">function</span> (<span class="params">food</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`I am eating`</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 ES6 中使用 static 的标记是不是静态方法，代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="title">constructor</span> (<span class="params">type</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.type = type</span><br><span class="line">  &#125;</span><br><span class="line">  walk () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`I am walking`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> eat () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`I am eating`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有没有很清爽，代码可读性一下子就上来了。</p>
<h3 id="4-5-Sub-Classes"><a href="#4-5-Sub-Classes" class="headerlink" title="4.5 Sub Classes"></a>4.5 Sub Classes</h3><p>面向对象只所以可以应对复杂的项目实现，很大程度上要归功于继承。如果对继承概念不熟悉的同学，可以自行查询。在 ES5 中怎么实现继承呢？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义父类</span></span><br><span class="line"><span class="keyword">let</span> Animal = <span class="function"><span class="keyword">function</span> (<span class="params">type</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.type = type</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义方法</span></span><br><span class="line">Animal.prototype.walk = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`I am walking`</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义静态方法</span></span><br><span class="line">Animal.eat = <span class="function"><span class="keyword">function</span> (<span class="params">food</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`I am eating`</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义子类</span></span><br><span class="line"><span class="keyword">let</span> Dog = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 初始化父类</span></span><br><span class="line">  Animal.call(<span class="built_in">this</span>, <span class="string">&#x27;dog&#x27;</span>)</span><br><span class="line">  <span class="built_in">this</span>.run = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;I can run&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 继承</span></span><br><span class="line">Dog.prototype = Animal.prototype</span><br></pre></td></tr></table></figure>

<p>从代码上看，是不是很繁琐？而且阅读性也较差。再看看 ES6 是怎么解决这些问题的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="title">constructor</span> (<span class="params">type</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.type = type</span><br><span class="line">  &#125;</span><br><span class="line">  walk () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`I am walking`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> eat () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`I am eating`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="title">constructor</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="built_in">super</span>(<span class="string">&#x27;dog&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  run () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;I can run&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然 ES6 在类的定义上仅是 ES5 定义类的语法糖，但是从开发者的角度而言，开发更有效率了，代码可阅读性大大提升。</p>
<h3 id="扩展阅读-3"><a href="#扩展阅读-3" class="headerlink" title="@ 扩展阅读"></a>@ 扩展阅读</h3><ul>
<li>类：<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Classes">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Classes</a></li>
<li>Classes (ES6) Sample：<a target="_blank" rel="noopener" href="https://googlechrome.github.io/samples/classes-es6/">https://googlechrome.github.io/samples/classes-es6/</a></li>
<li>ES6 class：<a target="_blank" rel="noopener" href="https://www.kancloud.cn/kancloud/you-dont-know-js-this-object-prototypes/516675">https://www.kancloud.cn/kancloud/you-dont-know-js-this-object-prototypes/516675</a></li>
<li>Classes：<a target="_blank" rel="noopener" href="https://exploringjs.com/es6/ch_classes.html#sec_private-data-for-classes">https://exploringjs.com/es6/ch_classes.html#sec_private-data-for-classes</a></li>
<li>ES6 Class Tutorial：<a target="_blank" rel="noopener" href="https://vegibit.com/es6-class-tutorial/">https://vegibit.com/es6-class-tutorial/</a></li>
</ul>
<h2 id="05、Function"><a href="#05、Function" class="headerlink" title="05、Function"></a>05、Function</h2><h3 id="5-1-Default-Parameters"><a href="#5-1-Default-Parameters" class="headerlink" title="5.1 Default Parameters"></a>5.1 Default Parameters</h3><p>对于函数而言，经常会用到参数，关于参数的默认值通常都是写在函数体中，如在 ES5 的时候大家都会这么写：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span> (<span class="params">x, y, z</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (y === <span class="literal">undefined</span>)</span><br><span class="line">        y = <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">if</span> (z === <span class="literal">undefined</span>)</span><br><span class="line">        z = <span class="number">42</span>;</span><br><span class="line">    <span class="keyword">return</span> x + y + z;</span><br><span class="line">&#125;;</span><br><span class="line">f(<span class="number">1</span>) === <span class="number">50</span>;</span><br></pre></td></tr></table></figure>

<p>当一个函数有很多参数涉及初始化的时候，这样写代码极其丑陋，所以在 ES6 中改变了对这种知识的写法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span> (<span class="params">x, y = <span class="number">7</span>, z = <span class="number">42</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y + z</span><br><span class="line">&#125;</span><br><span class="line">f(<span class="number">1</span>) === <span class="number">50</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>[!TIP]<br>函数参数是从左到右解析，如果没有默认值会被解析成 undefined</p>
</blockquote>
<p>如果我们想让具体某个参数使用默认值，我们可以使用 undefined 进行赋值，如下段代码所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span> (<span class="params">x, y = <span class="number">7</span>, z = <span class="number">42</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y + z</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(f(<span class="number">1</span>, <span class="literal">undefined</span>, <span class="number">43</span>))<span class="comment">// 51</span></span><br></pre></td></tr></table></figure>

<p>在ES6中我们不仅可以给参数默认赋值具体的数值，同时参数赋值支持参数的逻辑运算进行赋值，如下段代码所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span> (<span class="params">x, y = <span class="number">7</span>, z = x + y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> z * <span class="number">0.5</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(f(<span class="number">1</span>, <span class="number">7</span>))<span class="comment">// 4</span></span><br></pre></td></tr></table></figure>

<p><strong>@拓展</strong></p>
<p>在函数体内，有时候需要判断函数有几个参数，一共有2个办法。在 ES5 中可以在函数体内使用 arguments 来判断。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span> (<span class="params">a, b = <span class="number">1</span>, c</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>.length)</span><br><span class="line">&#125;</span><br><span class="line">test(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>)<span class="comment">//2</span></span><br></pre></td></tr></table></figure>

<p>然而在 ES6 中不能再使用 arguments 来判断了，但可以借助 Function.length 来判断。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span> (<span class="params">a, b = <span class="number">1</span>, c</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(test.length)</span><br><span class="line">&#125;</span><br><span class="line">test(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>)<span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>细心的同学发现 Function.length 结果和 arguments 的结果不同！没错，Function.length 是统计第一个默认参数前面的变量数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span> (<span class="params">a = <span class="number">2</span>, b = <span class="number">1</span>, c</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(test.length)</span><br><span class="line">&#125;</span><br><span class="line">test(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>)<span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<h3 id="5-2-Rest-Parameter"><a href="#5-2-Rest-Parameter" class="headerlink" title="5.2 Rest Parameter"></a>5.2 Rest Parameter</h3><p>在写函数的时候，部分情况我们不是很确定参数有多少个，比如求和运算，之前都是这么做的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> num = <span class="number">0</span></span><br><span class="line">  <span class="built_in">Array</span>.prototype.forEach.call(<span class="built_in">arguments</span>, <span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">    num += item * <span class="number">1</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> num</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>))<span class="comment">// 6</span></span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>))<span class="comment">// 10</span></span><br></pre></td></tr></table></figure>

<p>其实在上面说过，这个代码在 ES5 中可以这么写，在 ES6 就不能这么写了，因为 arguments 的问题。现在需要这样写：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span> (<span class="params">...nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> num = <span class="number">0</span></span><br><span class="line">  nums.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">    num += item * <span class="number">1</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> num</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>))<span class="comment">// 6</span></span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>))<span class="comment">// 10</span></span><br></pre></td></tr></table></figure>

<p>当然，Rest Parameter 也可以和其他参数一起来用，比如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span> (<span class="params">base, ...nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> num = base</span><br><span class="line">  nums.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">    num += item * <span class="number">1</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> num</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">30</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>))<span class="comment">// 36</span></span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">30</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>))<span class="comment">// 40</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>[!WARNING]<br>arguments 不是数组，所以不能直接使用数组的原生 API 如 forEach，而 Rest Parameter 是数组，可以直接使用数组的原生 API。</p>
</blockquote>
<h3 id="5-3-Spread-Operator"><a href="#5-3-Spread-Operator" class="headerlink" title="5.3 Spread Operator"></a>5.3 Spread Operator</h3><p>Spread Operator 和 Rest Parameter 是形似但相反意义的操作符，简单的来说 Rest Parameter 是把不定的参数“收敛”到数组，而 Spread Operator 是把固定的数组内容“打散”到对应的参数。示例如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span> (<span class="params">x = <span class="number">1</span>, y = <span class="number">2</span>, z = <span class="number">3</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y + z</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sum(...[<span class="number">4</span>]))<span class="comment">// 9</span></span><br><span class="line"><span class="built_in">console</span>.log(sum(...[<span class="number">4</span>, <span class="number">5</span>]))<span class="comment">// 12</span></span><br><span class="line"><span class="built_in">console</span>.log(sum(...[<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]))<span class="comment">// 15</span></span><br></pre></td></tr></table></figure>

<p>大家可以好好体会下前面两个示例，Rest Parameter 用来解决函数参数不确定的场景，Spread Operator 用来解决已知参数集合应用到固定参数的函数上，如果没有这个语法，可能需要这样做：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span> (<span class="params">x = <span class="number">1</span>, y = <span class="number">2</span>, z = <span class="number">3</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y + z</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sum.apply(<span class="literal">null</span>, [<span class="number">4</span>]))<span class="comment">// 9</span></span><br><span class="line"><span class="built_in">console</span>.log(sum.apply(<span class="literal">null</span>, [<span class="number">4</span>, <span class="number">5</span>]))<span class="comment">// 12</span></span><br><span class="line"><span class="built_in">console</span>.log(sum.apply(<span class="literal">null</span>, [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]))<span class="comment">// 15</span></span><br></pre></td></tr></table></figure>

<p>这种代码是否似曾相识？所以有了 Spread Operator 你的操作将更加简单！</p>
<h3 id="5-4-Arrow-Function"><a href="#5-4-Arrow-Function" class="headerlink" title="5.4 Arrow Function"></a>5.4 Arrow Function</h3><p>箭头函数可以说是 ES6 很大的福利了，不管你是函数式爱好者还是面向对象开发者，函数是必须要用到的东西。之前声明函数需要使用 function，如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hello</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;say hello&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line"><span class="keyword">let</span> hello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;say hello&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在可以这样做了：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> hello = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;say hello&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果带参数该怎么做呢？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> hello = <span class="function">(<span class="params">name</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;say hello&#x27;</span>, name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">let</span> hello = <span class="function"><span class="params">name</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;say hello&#x27;</span>, name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>[!TIP]<br>如果只有一个参数，可以省略括号，如果大于一个参数一定要记得带括号</p>
</blockquote>
<p>函数的声明和参数写的很清楚了，那么对于返回值有什么要注意的地方呢？</p>
<ul>
<li><p><strong>如果返回值是表达式</strong></p>
<p>如果返回值是表达式可以省略 return 和 {}</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> pow = <span class="function"><span class="params">x</span> =&gt;</span> x * x</span><br></pre></td></tr></table></figure></li>
<li><p><strong>如果返回值是字面量对象</strong></p>
<p>如果返回值是字面量对象，一定要用小括号包起来</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = <span class="function">(<span class="params">name</span>) =&gt;</span> (&#123;</span><br><span class="line">  age: <span class="number">20</span>,</span><br><span class="line">  addr: <span class="string">&#x27;Beijing City&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p><strong>其他</strong></p>
<p>其他情况就要中规中矩的写好啦！</p>
</li>
</ul>
<p><strong>@拓展</strong></p>
<p>看上去箭头函数真的很漂亮，可是它有什么神秘之处吗？this，对，就是它。普通函数和箭头函数对 this 的处理方式是截然不同的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> test = &#123;</span><br><span class="line">  name: <span class="string">&#x27;test&#x27;</span>,</span><br><span class="line">  say: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(test.say())<span class="comment">// test</span></span><br></pre></td></tr></table></figure>

<p>这是用普通函数的写法，say 在被调用之后，this 指向的是调用 say 方法的对象，显示是 test 对象，所以 this === test，那么 <a target="_blank" rel="noopener" href="http://this.name/">this.name</a> 也就是 <a target="_blank" rel="noopener" href="http://test.name/">test.name</a>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> test = &#123;</span><br><span class="line">  name: <span class="string">&#x27;test&#x27;</span>,</span><br><span class="line">  say: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name, <span class="built_in">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(test.say())<span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>因为箭头函数中对 this 的处理是定义时，this 的指向也就是 test 外层的所指向的 window，而 window 没有 name 属性，所以结果是 undefined。</p>
<p><strong>练习</strong></p>
<ol>
<li>如何用箭头函数来实现一个数组排序的问题</li>
<li>箭头函数对 this 的处理还有什么妙用</li>
</ol>
<h3 id="扩展阅读-4"><a href="#扩展阅读-4" class="headerlink" title="@ 扩展阅读"></a>@ 扩展阅读</h3><ul>
<li>箭头函数：<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions</a></li>
<li>默认参数：<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Default_parameters">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Default_parameters</a></li>
</ul>
<h2 id="06、Object"><a href="#06、Object" class="headerlink" title="06、Object"></a>06、Object</h2><h3 id="6-1-Enhanced-Object-Properties"><a href="#6-1-Enhanced-Object-Properties" class="headerlink" title="6.1 Enhanced Object Properties"></a>6.1 Enhanced Object Properties</h3><ul>
<li><p><strong>Property Shorthand</strong></p>
<p>在 ES6 之前 Object 的属性必须是 key-value 形式，如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">obj = &#123; <span class="attr">x</span>: x, <span class="attr">y</span>: y &#125;;</span><br></pre></td></tr></table></figure>

<p>在 ES6 之后是可以用简写的形式来表达：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">0</span>, y = <span class="number">0</span></span><br><span class="line">obj = &#123; x, y &#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>Computed Property Names</strong></p>
<p>在 ES6 之前 Object 的 key 在定义时必须是字符串，如果想增加“动态”的 key，必须是先计算出 key，利用 <code>object[key] = value</code> 的方式来修改；</p>
<p>在 ES6 之后可以直接用变量或者表达式来定义 key。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  foo: <span class="string">&#x27;bar&#x27;</span>,</span><br><span class="line">  ([<span class="string">&#x27;baz&#x27;</span>+ quux()]): <span class="number">42</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>[!DANGER]<br>上述代码中不应该有()直接书写<code>[&#39;baz&#39;+ quux()]</code>就可以，之所以这么写是 markdown 高亮插件还不支持计算属性。</p>
</blockquote>
<p>而不用在这样写</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  foo: <span class="string">&#x27;bar&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">obj[<span class="string">&#x27;baz&#x27;</span> + quux()] = <span class="number">42</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>Method Properties</strong></p>
<p>从 ES6 开始对象内的方法可以简写，包括常规函数和异步函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  foo (a, b) &#123;</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line">  bar (x, y) &#123;</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line">  * quux (x, y) &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 ES5 时代只能这样写</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  foo: <span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line">  bar: <span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//  quux: no equivalent in ES5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>[!WARNING]<br>ES5 时代 Object 的属性只支持常规函数，对于异步函数是不支持的</p>
</blockquote>
</li>
</ul>
<h3 id="6-2-Set"><a href="#6-2-Set" class="headerlink" title="6.2 Set"></a>6.2 Set</h3><p>在 JavaScript 里通常使用 Array 或 Object 来存储数据。但是在频繁操作数据的过程中查找或者统计并需要手动来实现，并不能简单的直接使用。比如如何保证 Array 是去重的，如何统计 Object 的数据总数等，必须自己去手动实现类似的需求，不是很方便。在 ES6 中为了解决上述痛点，新增了数据结构 Set 和 Map，它们分别对应传统数据结构的“集合”和“字典”。首先，我们先来学习下 Set 数据结构。</p>
<ul>
<li><p><strong>生成 Set 实例</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br></pre></td></tr></table></figure>

<p>可以定义一个空的 Set 实例，也可以在实例化的同时传入默认的数据。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br></pre></td></tr></table></figure>

<blockquote>
<p>[!TIP]<br>初始化的参数必须是可遍历的，可以是数组或者自定义遍历的数据结构。</p>
</blockquote>
</li>
<li><p><strong>添加数据</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s.add(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">s.add(<span class="string">&#x27;goodbye&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.add(<span class="string">&#x27;hello&#x27;</span>).add(<span class="string">&#x27;goodbye&#x27;</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>[!NOTE]<br>敲黑板了，Set 数据结构不允许数据重复，所以添加重复的数据是无效的</p>
</blockquote>
</li>
<li><p><strong>删除数据</strong></p>
<p>删除数据分两种，一种是删除指定的数据，一种是删除全部数据。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除指定数据</span></span><br><span class="line">s.delete(<span class="string">&#x27;hello&#x27;</span>) <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 删除全部数据</span></span><br><span class="line">s.clear()</span><br></pre></td></tr></table></figure></li>
<li><p><strong>统计数据</strong></p>
<p>Set 可以快速进行统计数据，如数据是否存在、数据的总数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断是否包含数据项，返回 true 或 false</span></span><br><span class="line">s.has(<span class="string">&#x27;hello&#x27;</span>) <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 计算数据项总数</span></span><br><span class="line">s.size <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>查询数据</strong></p>
<ul>
<li>keys()：返回键名的遍历器</li>
<li>values()：返回键值的遍历器</li>
<li>entries()：返回键值对的遍历器</li>
<li>forEach()：使用回调函数遍历每个成员</li>
<li>for…of：可以直接遍历每个成员</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(s.keys()); <span class="comment">// SetIterator &#123;&quot;hello&quot;, &quot;goodbye&quot;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(s.values()); <span class="comment">// SetIterator &#123;&quot;hello&quot;, &quot;goodbye&quot;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(s.entries()); <span class="comment">// SetIterator &#123;&quot;hello&quot; =&gt; &quot;hello&quot;, &quot;goodbye&quot; =&gt; &quot;goodbye&quot;&#125;</span></span><br><span class="line">s.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item) <span class="comment">// hello // goodbye</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> s) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// hello</span></span><br><span class="line"><span class="comment">// goodbye</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>[!TIP]<br>不理解 SetIterator 没关系，后面会讲遍历器，耐心一点！</p>
</blockquote>
</li>
</ul>
<p><strong>@思考</strong></p>
<ol>
<li>因为 Set 中的值总是唯一的，所以需要判断两个值是否相等，那么 +0,-0,NaN,undefined可以被重复添加吗？</li>
<li>Set 对存储的类型是不限的，如果想限制只能存储对象，该怎么办？请使用 WeakSet!</li>
</ol>
<h3 id="6-3-Map"><a href="#6-3-Map" class="headerlink" title="6.3 Map"></a>6.3 Map</h3><p>前面我们讲过 Set 和 Map 的背景，Map 是用来实现字典的功能（Object 键值对）。我们来看下它的用法：</p>
<ul>
<li><p><strong>实例化</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([iterable])</span><br></pre></td></tr></table></figure>

<p>Iterable 可以是一个数组或者其他 iterable 对象，其元素为键值对(两个元素的数组，例如: [[ 1, ‘one’ ],[ 2, ‘two’ ]])。 每个键值对都会添加到新的 Map。null 会被当做 undefined。</p>
</li>
<li><p><strong>添加数据</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> keyObj = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> keyFunc = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> keyString = <span class="string">&#x27;a string&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加键</span></span><br><span class="line">map.set(keyString, <span class="string">&quot;和键&#x27;a string&#x27;关联的值&quot;</span>)</span><br><span class="line">map.set(keyObj, <span class="string">&#x27;和键keyObj关联的值&#x27;</span>)</span><br><span class="line">map.set(keyFunc, <span class="string">&#x27;和键keyFunc关联的值&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
<li><p><strong>删除数据</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除指定的数据</span></span><br><span class="line">map.delete(keyObj)</span><br><span class="line"><span class="comment">// 删除所有数据</span></span><br><span class="line">map.clear()</span><br></pre></td></tr></table></figure></li>
<li><p><strong>统计数据</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 统计所有 key-value 的总数</span></span><br><span class="line"><span class="built_in">console</span>.log(map.size) <span class="comment">//2</span></span><br><span class="line"><span class="comment">// 判断是否有 key-value</span></span><br><span class="line"><span class="built_in">console</span>.log(map.has(keyObj)) <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>查询数据</strong></p>
<ul>
<li>get() 方法返回某个 Map 对象中的一个指定元素</li>
<li>keys() 返回一个新的 Iterator 对象。它包含按照顺序插入 Map 对象中每个元素的 key 值</li>
<li>values() 方法返回一个新的 Iterator 对象。它包含按顺序插入Map对象中每个元素的 value 值</li>
<li>entries() 方法返回一个新的包含 [key, value] 对的 Iterator ?对象，返回的迭代器的迭代顺序与 Map 对象的插入顺序相同</li>
<li>forEach() 方法将会以插入顺序对 Map 对象中的每一个键值对执行一次参数中提供的回调函数</li>
<li>for…of 可以直接遍历每个成员</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(map.get(keyObj)) <span class="comment">// 和键keyObj关联的值</span></span><br><span class="line"><span class="built_in">console</span>.log(map.keys()) <span class="comment">// Iterator</span></span><br><span class="line"><span class="built_in">console</span>.log(map.values()) <span class="comment">// Iterator</span></span><br><span class="line"><span class="built_in">console</span>.log(map.entries()) <span class="comment">// Iterator</span></span><br><span class="line">map.forEach(<span class="function">(<span class="params">value, key, map</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value, key, map)</span><br><span class="line">&#125;, thisArg)</span><br><span class="line"><span class="keyword">for</span> ([key, value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key, value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map/forEach">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map/forEach</a></p>
</blockquote>
<p>其实 Object 也是按键值对存储和读取的，那么他俩之间除了我们之前说的区别以外还有其他的吗？</p>
<ul>
<li><p><strong>键的类型</strong></p>
<p>一个Object的键只能是字符串或者 Symbols，但一个 Map 的键可以是任意值，包括函数、对象、基本类型。</p>
</li>
<li><p><strong>键的顺序</strong></p>
<p>Map 中的键值是有序的，而添加到对象中的键则不是。因此，当对它进行遍历时，Map 对象是按插入的顺序返回键值。</p>
</li>
<li><p><strong>键值对的统计</strong></p>
<p>你可以通过 size 属性直接获取一个 Map 的键值对个数，而 Object 的键值对个数只能手动计算。</p>
</li>
<li><p><strong>键值对的遍历</strong></p>
<p>Map 可直接进行迭代，而 Object 的迭代需要先获取它的键数组，然后再进行迭代。</p>
</li>
<li><p><strong>性能</strong></p>
<p>Map 在涉及频繁增删键值对的场景下会有些性能优势。</p>
</li>
</ul>
</li>
</ul>
<h3 id="6-4-Object-assign"><a href="#6-4-Object-assign" class="headerlink" title="6.4 Object.assign()"></a>6.4 Object.assign()</h3><p>Object.assign() 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象，它将返回目标对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;</span><br><span class="line"><span class="keyword">const</span> source = &#123; <span class="attr">b</span>: <span class="number">4</span>, <span class="attr">c</span>: <span class="number">5</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> returnedTarget = <span class="built_in">Object</span>.assign(target, source)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(target)</span><br><span class="line"><span class="comment">// expected output: Object &#123; a: 1, b: 4, c: 5 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(returnedTarget)</span><br><span class="line"><span class="comment">// expected output: Object &#123; a: 1, b: 4, c: 5 &#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>基本语法</strong></p>
<blockquote>
<p>Object.assign(target, …sources)</p>
</blockquote>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">含义</th>
<th align="left">必选</th>
</tr>
</thead>
<tbody><tr>
<td align="left">target</td>
<td align="left">目标对象</td>
<td align="left">Y</td>
</tr>
<tr>
<td align="left">sources</td>
<td align="left">源对象</td>
<td align="left">N</td>
</tr>
</tbody></table>
<blockquote>
<p>[!TIP]<br>从语法上可以看出源对象的个数是不限制的（零个或多个），如果是零个直接返回目的对象，如果是多个相同属性的会被后边的源对象的属相覆盖。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="built_in">Object</span>.assign(&#123; <span class="attr">a</span>: <span class="number">1</span> &#125;)</span><br><span class="line"><span class="comment">// &#123;a: 1&#125;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>[!WARNING]<br>如果目的对象不是对象，则会自动转换为对象</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> t = <span class="built_in">Object</span>.assign(<span class="number">2</span>)</span><br><span class="line"><span class="comment">// Number &#123;2&#125;</span></span><br><span class="line"><span class="keyword">let</span> s = <span class="built_in">Object</span>.assign(<span class="number">2</span>, &#123; <span class="attr">a</span>: <span class="number">2</span> &#125;)</span><br><span class="line"><span class="comment">// Number &#123;2, a: 2&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>@思考</strong></p>
<ol>
<li>如果目标对象传入的是 undefined 和 null 将会怎样呢？</li>
<li>如果源对象的参数是 undefined 和 null 又会怎样呢？</li>
<li>如果目标对象是个嵌套的对象，子对象的属性会被覆盖吗？</li>
</ol>
<h3 id="扩展阅读-5"><a href="#扩展阅读-5" class="headerlink" title="@ 扩展阅读"></a>@ 扩展阅读</h3><ol>
<li>es6-enhanced-object-literals：<a target="_blank" rel="noopener" href="https://www.sitepoint.com/es6-enhanced-object-literals/">https://www.sitepoint.com/es6-enhanced-object-literals/</a></li>
<li>Object.assign()：<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/assign">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/assign</a></li>
</ol>
<h2 id="07、RegExp"><a href="#07、RegExp" class="headerlink" title="07、RegExp"></a>07、RegExp</h2><h3 id="7-1-Sticky"><a href="#7-1-Sticky" class="headerlink" title="7.1 Sticky"></a>7.1 Sticky</h3><p>除了u修饰符，ES6还为正则表达式添加了y修饰符，叫做“粘连”（sticky）修饰符。</p>
<p>y修饰符的作用与g修饰符类似，也是全局匹配，后一次匹配都从上一次匹配成功的下一个位置开始。不同之处在于，g修饰符只要剩余位置中存在匹配就可，而y修饰符确保匹配必须从剩余的第一个位置开始，这也就是“粘连”的涵义。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="string">&#x27;aaa_aa_a&#x27;</span></span><br><span class="line"><span class="keyword">const</span> r1 = <span class="regexp">/a+/g</span></span><br><span class="line"><span class="keyword">const</span> r2 = <span class="regexp">/a+/y</span></span><br><span class="line"></span><br><span class="line">r1.exec(s) <span class="comment">// [&quot;aaa&quot;]</span></span><br><span class="line">r2.exec(s) <span class="comment">// [&quot;aaa&quot;]</span></span><br><span class="line"></span><br><span class="line">r1.exec(s) <span class="comment">// [&quot;aa&quot;]</span></span><br><span class="line">r2.exec(s) <span class="comment">// null</span></span><br></pre></td></tr></table></figure>

<p>上面代码有两个正则表达式，一个使用g修饰符，另一个使用y修饰符。这两个正则表达式各执行了两次，第一次执行的时候，两者行为相同，剩余字符串都是_aa_a。由于g修饰没有位置要求，所以第二次执行会返回结果，而y修饰符要求匹配必须从头部开始，所以返回null。</p>
<p>如果改一下正则表达式，保证每次都能头部匹配，y修饰符就会返回结果了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="string">&#x27;aaa_aa_a&#x27;</span></span><br><span class="line"><span class="keyword">const</span> r = <span class="regexp">/a+_/y</span></span><br><span class="line"></span><br><span class="line">r.exec(s) <span class="comment">// [&quot;aaa_&quot;]</span></span><br><span class="line">r.exec(s) <span class="comment">// [&quot;aa_&quot;]</span></span><br></pre></td></tr></table></figure>

<p>上面代码每次匹配，都是从剩余字符串的头部开始。</p>
<p>使用lastIndex属性，可以更好地说明y修饰符。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> REGEX = <span class="regexp">/a/g</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定从2号位置（y）开始匹配</span></span><br><span class="line">REGEX.lastIndex = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配成功</span></span><br><span class="line"><span class="keyword">const</span> match = REGEX.exec(<span class="string">&#x27;xaya&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在3号位置匹配成功</span></span><br><span class="line"><span class="built_in">console</span>.log(match.index) <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下一次匹配从4号位开始</span></span><br><span class="line"><span class="built_in">console</span>.log(REGEX.lastIndex) <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4号位开始匹配失败</span></span><br><span class="line">REGEX.exec(<span class="string">&#x27;xaxa&#x27;</span>) <span class="comment">// null</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，lastIndex属性指定每次搜索的开始位置，g修饰符从这个位置开始向后搜索，直到发现匹配为止。</p>
<p>y修饰符同样遵守lastIndex属性，但是要求必须在lastIndex指定的位置发现匹配。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> REGEX = <span class="regexp">/a/y</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定从2号位置开始匹配</span></span><br><span class="line">REGEX.lastIndex = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不是粘连，匹配失败</span></span><br><span class="line">REGEX.exec(<span class="string">&#x27;xaya&#x27;</span>) <span class="comment">// null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定从3号位置开始匹配</span></span><br><span class="line">REGEX.lastIndex = <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3号位置是粘连，匹配成功</span></span><br><span class="line"><span class="keyword">const</span> match = REGEX.exec(<span class="string">&#x27;xaxa&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(match.index) <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(REGEX.lastIndex) <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>

<p>进一步说，y修饰符号隐含了头部匹配的标志^。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> reg = <span class="regexp">/b/y</span></span><br><span class="line">reg.exec(<span class="string">&#x27;aba&#x27;</span>)</span><br><span class="line"><span class="comment">// null</span></span><br><span class="line"><span class="built_in">console</span>.log(reg.lastIndex);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>[!NOTE]<br>sticky 模式在正则匹配过程中只会影响两件事：</p>
<ol>
<li>匹配必须从 re.lastIndex 开始（相当于正则表达中的 ^）</li>
<li>如果匹配到会修改 re.lastIndex（相当于 g 模式）</li>
</ol>
</blockquote>
<h3 id="7-2-Unicode"><a href="#7-2-Unicode" class="headerlink" title="7.2 Unicode"></a>7.2 Unicode</h3><p>ES6对正则表达式添加了u修饰符，含义为“Unicode模式”，用来正确处理大于 <code>\uFFFF</code> 的Unicode字符。也就是说，会正确处理四个字节的UTF-16编码。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/^\uD83D/u.test(<span class="string">&#x27;\uD83D\uDC2A&#x27;</span>)</span><br><span class="line"><span class="comment">// false</span></span><br><span class="line">/^\uD83D/.test(<span class="string">&#x27;\uD83D\uDC2A&#x27;</span>)</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>\uD83D\uDC2A</code>是一个四个字节的UTF-16编码，代表一个字符 “🐪”。但是，ES5不支持四个字节的UTF-16编码，会将其识别为两个字符，导致第二行代码结果为true。加了u修饰符以后，ES6就会识别其为一个字符，所以第一行代码结果为false。</p>
<p>一旦加上u修饰符号，就会修改下面这些正则表达式的行为。</p>
<p><strong>(1) 点字符</strong></p>
<p>点（.）字符在正则表达式中，含义是除了换行符以外的任意单个字符。对于码点大于 0xFFFF 的 Unicode 字符，点字符不能识别，必须加上u修饰符。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&#x27;𠮷&#x27;</span>; <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">/^.$/.test(s) <span class="comment">// false</span></span><br><span class="line">/^.$/u.test(s) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面代码表示，如果不添加u修饰符，正则表达式就会认为字符串为两个字符，从而匹配失败。</p>
<blockquote>
<p>[!NOTE]<br>‘𠮷’这个字读 jí，是’吉’字的异形体，Unicode 码点 <a target="_blank" rel="noopener" href="https://www.fileformat.info/info/unicode/char/20bb7/index.htm">U+20BB7</a></p>
</blockquote>
<p><strong>(2) Unicode字符表示法</strong></p>
<p>ES6新增了使用大括号表示Unicode字符，这种表示法在正则表达式中必须加上u修饰符，才能识别。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/\u&#123;<span class="number">61</span>&#125;/.test(<span class="string">&#x27;a&#x27;</span>) <span class="comment">// false</span></span><br><span class="line">/\u&#123;<span class="number">61</span>&#125;/u.test(<span class="string">&#x27;a&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">/\u&#123;20BB7&#125;/u.test(<span class="string">&#x27;𠮷&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面代码表示，如果不加u修饰符，正则表达式无法识别\u{61}这种表示法，只会认为这匹配61个连续的u。</p>
<p><strong>(3) 量词</strong></p>
<p>使用u修饰符后，所有量词都会正确识别码点大于0xFFFF的Unicode字符。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/a&#123;<span class="number">2</span>&#125;/.test(<span class="string">&#x27;aa&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">/a&#123;<span class="number">2</span>&#125;/u.test(<span class="string">&#x27;aa&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">/𠮷&#123;<span class="number">2</span>&#125;/.test(<span class="string">&#x27;𠮷𠮷&#x27;</span>) <span class="comment">// false</span></span><br><span class="line">/𠮷&#123;<span class="number">2</span>&#125;/u.test(<span class="string">&#x27;𠮷𠮷&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>另外，只有在使用u修饰符的情况下，Unicode表达式当中的大括号才会被正确解读，否则会被解读为量词。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/^\u&#123;<span class="number">3</span>&#125;$/.test(<span class="string">&#x27;uuu&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，由于正则表达式没有u修饰符，所以大括号被解读为量词。加上u修饰符，就会被解读为Unicode表达式。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/\u&#123;20BB7&#125;&#123;<span class="number">2</span>&#125;/u.test(<span class="string">&#x27;𠮷𠮷&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>使用 u 修饰符之后 Unicode 表达式+量词也是可以的。</p>
<p><strong>(4) 预定义模式</strong></p>
<p>u修饰符也影响到预定义模式，能否正确识别码点大于0xFFFF的Unicode字符。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/^\S$/.test(<span class="string">&#x27;𠮷&#x27;</span>) <span class="comment">// false</span></span><br><span class="line">/^\S$/u.test(<span class="string">&#x27;𠮷&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面代码的\S是预定义模式，匹配所有不是空格的字符。只有加了u修饰符，它才能正确匹配码点大于0xFFFF的Unicode字符。</p>
<p>利用这一点，可以写出一个正确返回字符串长度的函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">codePointLength</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> result = text.match(<span class="regexp">/[\s\S]/gu</span>);</span><br><span class="line">  <span class="keyword">return</span> result ? result.length : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> s = <span class="string">&#x27;𠮷𠮷&#x27;</span>;</span><br><span class="line"></span><br><span class="line">s.length <span class="comment">// 4</span></span><br><span class="line">codePointLength(s) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p><strong>(5) i修饰符</strong></p>
<p>有些Unicode字符的编码不同，但是字型很相近，比如，\u004B与\u212A都是大写的K。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/[a-z]/i.test(<span class="string">&#x27;\u212A&#x27;</span>) <span class="comment">// false</span></span><br><span class="line">/[a-z]/iu.test(<span class="string">&#x27;\u212A&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，不加u修饰符，就无法识别非规范的K字符。</p>
<p><strong>@思考</strong></p>
<ol>
<li>sticky 模式有什么实际应用场景吗？</li>
<li>上面提到 <code>\uD83D\uDC2A</code> 是四个字节，加了 u 标识符会正确识别出是两个字符，那么在 JavaScript 里一个字符是几个字节？</li>
<li>U+20BB7 是如何计算出 “\uD842\uDFB7” 的？</li>
</ol>
<h3 id="扩展阅读-6"><a href="#扩展阅读-6" class="headerlink" title="@ 扩展阅读"></a>@ 扩展阅读</h3><ol>
<li>Unicode 及编码方式概述：<a target="_blank" rel="noopener" href="https://www.ibm.com/developerworks/cn/java/unicode-programming-language/index.html">https://www.ibm.com/developerworks/cn/java/unicode-programming-language/index.html</a></li>
<li>Unicode 转 UTF-16 的转码公式：<a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2014/12/unicode.html">http://www.ruanyifeng.com/blog/2014/12/unicode.html</a></li>
<li>New regular expression features in ECMAScript 6：<a target="_blank" rel="noopener" href="http://2ality.com/2015/07/regexp-es6.html">http://2ality.com/2015/07/regexp-es6.html</a></li>
<li>sticky：<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/sticky">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/sticky</a></li>
</ol>
<h2 id="08、Template"><a href="#08、Template" class="headerlink" title="08、Template"></a>08、Template</h2><p>在 ES6 之前对字符串的处理是相当的麻烦，看如下场景：</p>
<p><strong>1. 字符串很长要换行</strong></p>
<p>字符串很长包括几种情形一个是开发时输入的文本内容，一个是接口数据返回的文本内容。如果对换行符处理不当，就会带来异常。</p>
<p><strong>2. 字符串中有变量或者表达式</strong></p>
<p>如果字符串不是静态内容，往往是需要加载变量或者表达式，这个也是很常见的需求。之前的做法是字符串拼接：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">20</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> c = <span class="string">&#x27;JavaScript&#x27;</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;My age is &#x27;</span> + (a + b) + <span class="string">&#x27; and I love &#x27;</span> + c</span><br><span class="line"><span class="built_in">console</span>.log(str)</span><br></pre></td></tr></table></figure>

<p>如果字符串有大量的变量和表达式，这个拼接简直是噩梦。</p>
<p><strong>3. 字符串中有逻辑运算</strong></p>
<p>我们通常写代码都是有逻辑运算的，对于字符串也是一样，它包含的内容不是静态的，通常是根据一定的规则在动态变化。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> retailPrice = <span class="number">20</span></span><br><span class="line"><span class="keyword">var</span> wholesalePrice = <span class="number">16</span></span><br><span class="line"><span class="keyword">var</span> type = <span class="string">&#x27;retail&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> showTxt = <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (type === <span class="string">&#x27;retail&#x27;</span>) &#123;</span><br><span class="line">  showTxt += <span class="string">&#x27;您此次的购买单价是：&#x27;</span> + retailPrice</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  showTxt += <span class="string">&#x27;您此次的批发价是：&#x27;</span> + wholesalePrice</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看到这样的代码一定会感到很熟悉，通常大家的做法是使用上述的字符串拼接+逻辑判断，或者采用字符串模板类库来操作。</p>
<h3 id="8-1-String-Literals"><a href="#8-1-String-Literals" class="headerlink" title="8.1 String Literals"></a>8.1 String Literals</h3><p>看了上述的应用场景，就要引入 String Literals 话题，这个是用来解决字符串拼接问题，从 ES6 开始可以这样定义字符串了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">`string text`</span></span><br><span class="line"></span><br><span class="line"><span class="string">`string text line 1</span></span><br><span class="line"><span class="string"> string text line 2`</span></span><br><span class="line"></span><br><span class="line"><span class="string">`string text <span class="subst">$&#123;expression&#125;</span> string text`</span></span><br></pre></td></tr></table></figure>

<p>在这里你可以任意插入变量或者表达式，只要用 <code>$&#123;&#125;</code> 包起来就好。</p>
<blockquote>
<p>[!WARNING]<br>这里的符号是反引号，也就是数字键 1 左边的键，不是单引号或者双引号</p>
</blockquote>
<p>这样就可以轻松解决字符串包含变量或者表达式的问题了，对于多行的字符串，之前是这样处理</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;string text line 1\n&#x27;</span> +</span><br><span class="line"><span class="string">&#x27;string text line 2&#x27;</span>);</span><br><span class="line"><span class="comment">// &quot;string text line 1</span></span><br><span class="line"><span class="comment">// string text line 2&quot;</span></span><br></pre></td></tr></table></figure>

<p>现在可以这样做了</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">`string text line 1</span></span><br><span class="line"><span class="string">string text line 2`</span>);</span><br><span class="line"><span class="comment">// &quot;string text line 1</span></span><br><span class="line"><span class="comment">// string text line 2&quot;</span></span><br></pre></td></tr></table></figure>

<p>完全不需要 <code>\n</code> 来参与。</p>
<h3 id="8-2-Tag-Literals"><a href="#8-2-Tag-Literals" class="headerlink" title="8.2 Tag Literals"></a>8.2 Tag Literals</h3><p>前面的字符串字面量解决了字符串拼接的问题，对于包含复杂逻辑的字符串并不是简单的表达式能搞定的。所以需要另一种解决方案：Tag Literals，还是看上述那个例子:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> retailPrice = <span class="number">20</span></span><br><span class="line"><span class="keyword">var</span> wholesalePrice = <span class="number">16</span></span><br><span class="line"><span class="keyword">var</span> type = <span class="string">&#x27;retail&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> showTxt = <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (type === <span class="string">&#x27;retail&#x27;</span>) &#123;</span><br><span class="line">  showTxt += <span class="string">&#x27;您此次的购买单价是：&#x27;</span> + retailPrice</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  showTxt += <span class="string">&#x27;您此次的批发价是：&#x27;</span> + wholesalePrice</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在可以定义一个 Tag 函数，然后用这个 Tag 函数来充当一个模板引擎：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Price</span> (<span class="params">strings, type</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> s1 = strings[<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">const</span> retailPrice = <span class="number">20</span></span><br><span class="line">  <span class="keyword">const</span> wholesalePrice = <span class="number">16</span></span><br><span class="line">  <span class="keyword">let</span> txt = <span class="string">&#x27;&#x27;</span></span><br><span class="line">  <span class="keyword">if</span> (type === <span class="string">&#x27;retail&#x27;</span>) &#123;</span><br><span class="line">    txt = <span class="string">`购买单价是：<span class="subst">$&#123;retailPrice&#125;</span>`</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    txt = <span class="string">`批发价是：<span class="subst">$&#123;wholesalePrice&#125;</span>`</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;s1&#125;</span><span class="subst">$&#123;txt&#125;</span>`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> showTxt = Price<span class="string">`您此次的<span class="subst">$&#123;<span class="string">&#x27;retail&#x27;</span>&#125;</span>`</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(showTxt) <span class="comment">//您此次的购买单价是：20</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>[!TIP]<br>strings 参数指的是 Tag 函数后面被变量分割开的字符串集合，type 参数是对应第一个变量，Tag 函数可以有多个 type 类似的参数</p>
</blockquote>
<p><strong>练习</strong></p>
<ol>
<li>用 Tag 函数解决下你业务中的一个字符串模板的问题</li>
</ol>
<h3 id="扩展阅读-7"><a href="#扩展阅读-7" class="headerlink" title="@ 扩展阅读"></a>@ 扩展阅读</h3><ol>
<li>模板字符串：<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/template_strings">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/template_strings</a></li>
<li>A guide to JavaScript Template Literals：<a target="_blank" rel="noopener" href="https://flaviocopes.com/javascript-template-literals/">https://flaviocopes.com/javascript-template-literals/</a></li>
</ol>
<h2 id="09、Desctructuring"><a href="#09、Desctructuring" class="headerlink" title="09、Desctructuring"></a>09、Desctructuring</h2><p>在 ES6 中新增了变量赋值的方式：解构赋值。如果对这个概念不了解，我们可以快速展示一个小示例一睹风采：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;Ilya&#x27;</span>, <span class="string">&#x27;Kantor&#x27;</span>]</span><br><span class="line"><span class="keyword">let</span> firstName = arr[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">let</span> surname = arr[<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<p>想从数组中找出有意义的项要单独赋值给变量（一一的写），在 ES6 中就可以这样写了：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [firstName, surname] = [<span class="string">&#x27;Ilya&#x27;</span>, <span class="string">&#x27;Kantor&#x27;</span>]</span><br><span class="line"><span class="built_in">console</span>.log(firstName) <span class="comment">// Ilya</span></span><br><span class="line"><span class="built_in">console</span>.log(surname) <span class="comment">// Kantor</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>[!TIP]<br>解构赋值重点是在赋值，赋值的元素是要拷贝出来赋值给变量，赋值的元素本身是不会被改变的。</p>
</blockquote>
<p>是不是非常的刺激，在解构赋值里用的最多的就是 Object 和 Array ，我们可以分别来看下两者的解构赋值是如何操作的。</p>
<h3 id="9-1-Array-Destructuring"><a href="#9-1-Array-Destructuring" class="headerlink" title="9.1 Array Destructuring"></a>9.1 Array Destructuring</h3><p>上述的小示例已经在描述数组的解构赋值了，可是那只是开始。</p>
<ul>
<li><p><strong>可以跳过赋值元素</strong></p>
<p>如果想忽略数组的某个元素对变量进行赋值，可以使用逗号来处理。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// second element is not needed</span></span><br><span class="line"><span class="keyword">let</span> [firstName, , title] = [<span class="string">&quot;Julius&quot;</span>, <span class="string">&quot;Caesar&quot;</span>, <span class="string">&quot;Consul&quot;</span>, <span class="string">&quot;of the Roman Republic&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( title ); <span class="comment">// Consul</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>赋值元素可以是任意可遍历的对象</strong></p>
<p>赋值的元素不仅是数组，它可以是任意可遍历的对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, b, c] = <span class="string">&quot;abc&quot;</span>; <span class="comment">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span></span><br><span class="line"><span class="keyword">let</span> [one, two, three] = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br></pre></td></tr></table></figure></li>
<li><p><strong>左边的变量</strong></p>
<p>被赋值的变量还可以是对象的属性，不局限于单纯的变量。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;&#125;;</span><br><span class="line">[user.name, user.surname] = <span class="string">&quot;Ilya Kantor&quot;</span>.split(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(user.name); <span class="comment">// Ilya</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>循环体</strong></p>
<p>解构赋值在循环体中的应用，可以配合 entries 使用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  name: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  age: <span class="number">30</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// loop over keys-and-values</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> <span class="built_in">Object</span>.entries(user)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;key&#125;</span>:<span class="subst">$&#123;value&#125;</span>`</span>); <span class="comment">// name:John, then age:30</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，对于 map 对象依然适用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">user.set(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;John&quot;</span>);</span><br><span class="line">user.set(<span class="string">&quot;age&quot;</span>, <span class="string">&quot;30&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> user.entries()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;key&#125;</span>:<span class="subst">$&#123;value&#125;</span>`</span>); <span class="comment">// name:John, then age:30</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>rest 参数</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [name1, name2, ...rest] = [<span class="string">&quot;Julius&quot;</span>, <span class="string">&quot;Caesar&quot;</span>, <span class="string">&quot;Consul&quot;</span>, <span class="string">&quot;of the Roman Republic&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(name1); <span class="comment">// Julius</span></span><br><span class="line"><span class="built_in">console</span>.log(name2); <span class="comment">// Caesar</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Note that type of `rest` is Array.</span></span><br><span class="line"><span class="built_in">console</span>.log(rest[<span class="number">0</span>]); <span class="comment">// Consul</span></span><br><span class="line"><span class="built_in">console</span>.log(rest[<span class="number">1</span>]); <span class="comment">// of the Roman Republic</span></span><br><span class="line"><span class="built_in">console</span>.log(rest.length); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>[!WARNING]<br>我们可以使用 rest 来接受赋值数组的剩余元素，不过要确保这个 rest 参数是放在被赋值变量的最后一个位置上。</p>
</blockquote>
</li>
<li><p><strong>默认值</strong></p>
<p>如果数组的内容少于变量的个数，并不会报错，没有分配到内容的变量会是 undefined。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [firstName, surname] = [];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(firstName); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(surname); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>当然你也可以给变量赋予默认值，防止 undefined 的情况出现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// default values</span></span><br><span class="line"><span class="keyword">let</span> [name = <span class="string">&quot;Guest&quot;</span>, surname = <span class="string">&quot;Anonymous&quot;</span>] = [<span class="string">&quot;Julius&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(name);    <span class="comment">// Julius (from array)</span></span><br><span class="line"><span class="built_in">console</span>.log(surname); <span class="comment">// Anonymous (default used)</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="9-2-Object-Destructuring"><a href="#9-2-Object-Destructuring" class="headerlink" title="9.2 Object Destructuring"></a>9.2 Object Destructuring</h3><ul>
<li><p><strong>基本用法</strong></p>
<p>解构赋值除了可以应用在 Array，也可以应用在 Object。基本的语法如下：</p>
<blockquote>
<p>let {var1, var2} = {var1:…, var2…}</p>
</blockquote>
<p>大致的意思是我们有一个 Object 想把里面的属性分别拿出来而无需通过调用属性的方式赋值给指定的变量。具体的做法是在赋值的左侧声明一个和 Object 结构等同的模板，然后把关心属性的 value 指定为新的变量即可。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> options = &#123;</span><br><span class="line">  title: <span class="string">&quot;Menu&quot;</span>,</span><br><span class="line">  width: <span class="number">100</span>,</span><br><span class="line">  height: <span class="number">200</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123;title, width, height&#125; = options;</span><br><span class="line"></span><br><span class="line">alert(title);  <span class="comment">// Menu</span></span><br><span class="line">alert(width);  <span class="comment">// 100</span></span><br><span class="line">alert(height); <span class="comment">// 200</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>[!TIP]<br>在这个结构赋值的过程中，左侧的“模板”结构要与右侧的 Object 一致，但是属性的顺序无需一致。</p>
</blockquote>
<p>上述的赋值左侧是采用了对象简写的方式，类似于：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;<span class="attr">title</span>: title, <span class="attr">width</span>: width, <span class="attr">height</span>: height&#125; = options;</span><br></pre></td></tr></table></figure>

<p>如果不想这么写或者想使用其他的变量名，可以自定义的，如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;<span class="attr">width</span>: w, <span class="attr">height</span>: h, title&#125; = options;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>默认值</strong></p>
<p>当然，这个赋值的过程中也是可以指定默认值的，这样做：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> options = &#123;</span><br><span class="line">  title: <span class="string">&quot;Menu&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123;width = <span class="number">100</span>, height = <span class="number">200</span>, title&#125; = options;</span><br><span class="line"></span><br><span class="line">alert(title);  <span class="comment">// Menu</span></span><br><span class="line">alert(width);  <span class="comment">// 100</span></span><br><span class="line">alert(height); <span class="comment">// 200</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>rest 运算符</strong></p>
<p>如果我们想象操作数组一样，只关心指定的属性，其他可以暂存到一个变量下，这就要用到 rest 运算符了</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> options = &#123;</span><br><span class="line">  title: <span class="string">&quot;Menu&quot;</span>,</span><br><span class="line">  height: <span class="number">200</span>,</span><br><span class="line">  width: <span class="number">100</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123;title, ...rest&#125; = options;</span><br><span class="line"></span><br><span class="line"><span class="comment">// now title=&quot;Menu&quot;, rest=&#123;height: 200, width: 100&#125;</span></span><br><span class="line">alert(rest.height);  <span class="comment">// 200</span></span><br><span class="line">alert(rest.width);   <span class="comment">// 100</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>嵌套对象</strong></p>
<p>如果一个 Array 或者 Object 比较复杂，它嵌套了 Array 或者 Object，那只要被赋值的结构和右侧赋值的元素一致就好了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> options = &#123;</span><br><span class="line">  size: &#123;</span><br><span class="line">    width: <span class="number">100</span>,</span><br><span class="line">    height: <span class="number">200</span></span><br><span class="line">  &#125;,</span><br><span class="line">  items: [<span class="string">&quot;Cake&quot;</span>, <span class="string">&quot;Donut&quot;</span>],</span><br><span class="line">  extra: <span class="literal">true</span>    <span class="comment">// something extra that we will not destruct</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// destructuring assignment on multiple lines for clarity</span></span><br><span class="line"><span class="keyword">let</span> &#123;</span><br><span class="line">  size: &#123; <span class="comment">// put size here</span></span><br><span class="line">    width,</span><br><span class="line">    height</span><br><span class="line">  &#125;,</span><br><span class="line">  items: [item1, item2], <span class="comment">// assign items here</span></span><br><span class="line">  title = <span class="string">&quot;Menu&quot;</span> <span class="comment">// not present in the object (default value is used)</span></span><br><span class="line">&#125; = options;</span><br><span class="line"></span><br><span class="line">alert(title);  <span class="comment">// Menu</span></span><br><span class="line">alert(width);  <span class="comment">// 100</span></span><br><span class="line">alert(height); <span class="comment">// 200</span></span><br><span class="line">alert(item1);  <span class="comment">// Cake</span></span><br><span class="line">alert(item2);  <span class="comment">// Donut</span></span><br></pre></td></tr></table></figure>

<p>这个原理其实很简单，如果不理解可以看下图：<br>![图片描](F:/wujiang/笔记/01_前端开发系列/10_Node/09_ES6/imgs/wj003.png %}</p>
</li>
</ul>
<p><strong>思考</strong></p>
<ol>
<li>有时候我们写一个函数需要传入很多参数，而且很多参数是可选的，是否可以利用解构赋值来简化操作呢？</li>
<li>如何在业务开发中对接口数据进行解构赋值呢？</li>
</ol>
<h3 id="扩展阅读-8"><a href="#扩展阅读-8" class="headerlink" title="@ 扩展阅读"></a>@ 扩展阅读</h3><ol>
<li>Destructuring Assignment：<a target="_blank" rel="noopener" href="https://www.sitepoint.com/es6-destructuring-assignment/">https://www.sitepoint.com/es6-destructuring-assignment/</a></li>
<li>ES6 JavaScript Destructuring in Depth：<a target="_blank" rel="noopener" href="https://ponyfoo.com/articles/es6-destructuring-in-depth">https://ponyfoo.com/articles/es6-destructuring-in-depth</a></li>
<li>解构赋值：<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment</a></li>
</ol>
<h2 id="10、Promise"><a href="#10、Promise" class="headerlink" title="10、Promise"></a>10、Promise</h2><h3 id="10-1-Callbacks"><a href="#10-1-Callbacks" class="headerlink" title="10.1 Callbacks"></a>10.1 Callbacks</h3><p>JavaScipt 中的许多操作都是异步的，比如我们想加载一个脚本资源，可以把这个操作封装在一个 loadScript(src) 函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadScript</span> (<span class="params">src</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> script = <span class="built_in">document</span>.createElement(<span class="string">&#x27;script&#x27;</span>)</span><br><span class="line">  script.src = src</span><br><span class="line">  <span class="built_in">document</span>.head.append(script)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数的作用是加载一个新的脚本。当使用 <code>&lt;script src=&quot;…&quot;&gt;</code> 将其添加到文档中时，浏览器就会对它进行加载和执行。我们可以像这样使用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加载并执行脚本</span></span><br><span class="line">loadScript(<span class="string">&#x27;/my/script.js&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>函数是异步调用的，因为操作不是此刻（加载脚本）完成的，而是之后。调用初始化脚本加载，然后继续执行。当脚本正在被加载时，下面的代码可能已经完成了执行，如果加载需要时间，那么同一时间，其他脚本可能也会被运行。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">loadScript(<span class="string">&#x27;/my/script.js&#x27;</span>);</span><br><span class="line"><span class="comment">// 下面的代码在加载脚本时，不会等待脚本被加载完成</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>现在，我们假设想在新脚本被加载完成时，被立即使用。它可能声明了新函数，因此我们想要运行它们。但如果我们在 loadScript(…) 调用后，立即那么做，就会导致操作失败。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">loadScript(<span class="string">&#x27;/my/script.js&#x27;</span>); <span class="comment">// 脚本含有 &quot;function newFunction() &#123;…&#125;&quot;</span></span><br><span class="line">newFunction(); <span class="comment">// 没有这个函数！</span></span><br></pre></td></tr></table></figure>

<p>很明显，浏览器没有时间去加载脚本。因此，对新函数的立即调用失败了。loadScript 函数并没有提供追踪加载完成时方法。脚本加载然后最终的运行，仅此而已。但我们希望了解脚本何时加载完成，以使用其中的新函数和新变量。我们将 callback 函数作为第二个参数添加至 loadScript 中，函数在脚本加载时被执行：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadScript</span> (<span class="params">src, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> script = <span class="built_in">document</span>.createElement(<span class="string">&#x27;script&#x27;</span>)</span><br><span class="line">  script.src = src</span><br><span class="line">  script.onload = <span class="function">() =&gt;</span> callback(script)</span><br><span class="line">  <span class="built_in">document</span>.head.append(script)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果现在你想从脚本中调用新函数，我们应该在回调函数中那么写：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">loadScript(<span class="string">&#x27;/my/script.js&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 在脚本被加载后，回调才会被运行</span></span><br><span class="line">  newFunction(); <span class="comment">// 现在起作用了</span></span><br><span class="line">  ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这个过程大家并不陌生，可是如果在回调之后再回调呢？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">loadScript(<span class="string">&#x27;/my/script.js&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">script</span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">`Cool, the <span class="subst">$&#123;script.src&#125;</span> is loaded, let&#x27;s load one more`</span>)</span><br><span class="line">  loadScript(<span class="string">&#x27;/my/script2.js&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">script</span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">`Cool, the second script is loaded`</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">loadScript(<span class="string">&#x27;/my/script.js&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">script</span>) </span>&#123;</span><br><span class="line">  loadScript(<span class="string">&#x27;/my/script2.js&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">script</span>) </span>&#123;</span><br><span class="line">    loadScript(<span class="string">&#x27;/my/script3.js&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">script</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// ...在所有脚本被加载后继续操作</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>这两个小的场景都是在描述按顺序加载不同的脚本，采用了回调之后再回调的连锁过程。可以看出，这样的代码嵌套层级多了之后就是噩梦，还好我们上述只考虑了正常的情况，如果再把异常考虑进来代码大概是这个样子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">loadScript(<span class="string">&#x27;1.js&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">error, script</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (error) &#123;</span><br><span class="line">    handleError(error)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    loadScript(<span class="string">&#x27;2.js&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">error, script</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        handleError(error)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        loadScript(<span class="string">&#x27;3.js&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">error, script</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (error) &#123;</span><br><span class="line">            handleError(error)</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// ...加载所有脚本后继续 (*)</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>上述代码中：</p>
<ul>
<li>我们加载 1.js，如果没有发生错误；</li>
<li>我们加载 2.js，如果没有发生错误；</li>
<li>我们加载 3.js，如果没有发生错误 —— 做其他操作。</li>
</ul>
<p>如果嵌套变多，代码层次就会变深，维护难度也随之增加，尤其是如果我们有一个不是 … 的真实代码，就会包含更多的循环，条件语句等。这有时称为 “回调地狱” 或者“回调金字塔”。</p>
<h3 id="10-2-Promise-Syntax"><a href="#10-2-Promise-Syntax" class="headerlink" title="10.2 Promise Syntax"></a>10.2 Promise Syntax</h3><p>首先要说明 Promise 就是为了解决“回调地狱”问题的，它可以将异步操作的处理变得很优雅。如果我们使用 Promise 来解决上面那个问题该怎么做呢？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadScript</span> (<span class="params">src</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> script = <span class="built_in">document</span>.createElement(<span class="string">&#x27;script&#x27;</span>)</span><br><span class="line">    script.src = src</span><br><span class="line">    script.onload = <span class="function">() =&gt;</span> resolve(script)</span><br><span class="line">    script.onerror = <span class="function">(<span class="params">err</span>) =&gt;</span> reject(err)</span><br><span class="line">    <span class="built_in">document</span>.head.append(script)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">loadScript(<span class="string">&#x27;1.js&#x27;</span>)</span><br><span class="line">  .then(loadScript(<span class="string">&#x27;2.js&#x27;</span>), <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(loadScript(<span class="string">&#x27;3.js&#x27;</span>), <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<p>我们先来看下 Promise 的基本用法，并思考有哪些应用场景可以发挥它的长处。</p>
<p><strong>基本语法</strong></p>
<blockquote>
<p>new Promise( function(resolve, reject) {…} );</p>
</blockquote>
<p>通过创建 Promise 对象开启一个异步操作的过程，一般用几步完成多次异步操作：</p>
<ol>
<li><strong>new Promise(fn) 返回一个Promise 对象</strong></li>
<li><strong>在fn 中指定异步等处理</strong></li>
<li>处理结果正常的话，调用resolve(处理结果值)</li>
<li>处理结果错误的话，调用reject(Error对象)</li>
</ol>
<p>我们根据这个语法尝试自己封装一个 Ajax 的方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getURL</span> (<span class="params">URL</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> req = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">    req.open(<span class="string">&#x27;GET&#x27;</span>, URL, <span class="literal">true</span>)</span><br><span class="line">    req.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (req.status === <span class="number">200</span>) &#123;</span><br><span class="line">        resolve(req.responseText)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        reject(<span class="keyword">new</span> <span class="built_in">Error</span>(req.statusText))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    req.onerror = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      reject(<span class="keyword">new</span> <span class="built_in">Error</span>(req.statusText))</span><br><span class="line">    &#125;</span><br><span class="line">    req.send()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 运行示例</span></span><br><span class="line"><span class="keyword">var</span> URL = <span class="string">&#x27;http://httpbin.org/get&#x27;</span></span><br><span class="line">getURL(URL).then(<span class="function"><span class="keyword">function</span> <span class="title">onFulfilled</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value)</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span> <span class="title">onRejected</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.error(error)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>getURL 只有在通过XHR取得结果状态为200时才会调用 resolve ，也就是只有数据取得成功时，而其他情况（取得失败）时则会调用 reject 方法。</p>
<p>resolve(req.responseText) 在response的内容中加入了参数。 resolve方法的参数并没有特别的规则，基本上把要传给回调函数参数放进去就可以了。 ( then 方法可以接收到这个参数值)</p>
<blockquote>
<p>[!NOTE]<br>实际上 Promise 用起来还是比较简单的，是不是可以动手试一试去封装自己业务中应用到的异步操作了（之前用回调写的）？</p>
</blockquote>
<p>在这里必须说明下 Promise 内部是有状态的(pending、fulfilled、rejected)，Promise 对象根据状态来确定执行哪个方法。Promise 在实例化的时候状态是默认 pending 的，当异步操作是完成的，状态会被修改为 fulfilled，如果异步操作遇到异常，状态会被修改为 rejected，可以通过下面两幅图来看下状态的走向：</p>
<img src="/2019/07/17/ES6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/wj004.png" class="">

<p><strong>状态转换</strong></p>
<blockquote>
<p>[!WARNING]<br>状态转化是单向的，不可逆转，已经确定的状态（fulfilled/rejected）无法转回初始状态（pending），而且只能是从 pending 到 fulfilled 或者 rejected</p>
</blockquote>
<h3 id="10-3-Promise-prototype-then"><a href="#10-3-Promise-prototype-then" class="headerlink" title="10.3 Promise.prototype.then()"></a>10.3 Promise.prototype.then()</h3><p><strong>基本语法</strong></p>
<blockquote>
<p>promise.then(onFulfilled, onRejected);</p>
</blockquote>
<p><strong>示例</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  resolve(<span class="string">&#x27;传递给then的值&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value)</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.error(error)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>这段代码创建一个 Promise 对象，定义了处理 onFulfilled 和 onRejected 的函数（handler），然后返回这个 Promise 对象。这个 Promise 对象会在变为 resolve 或者 reject 的时候分别调用相应注册的回调函数。</p>
<ul>
<li>当 handler 返回一个正常值的时候，这个值会传递给 Promise 对象的 onFulfilled 方法。</li>
<li>定义的 handler 中产生异常的时候，这个值则会传递给 Promise 对象的 onRejected 方法。</li>
</ul>
<h3 id="10-4-Promise-resolve"><a href="#10-4-Promise-resolve" class="headerlink" title="10.4 Promise.resolve()"></a>10.4 Promise.resolve()</h3><p>一般情况下我们都会使用 <code>new Promise()</code> 来创建 Promise 对象，但是除此之外我们也可以使用其他方法。在这里，我们将会学习如何使用 <code>Promise.resolve</code> 和 <code>Promise.reject</code> 这两个方法。静态方法 Promise.resolve(value) 可以认为是 new Promise() 方法的快捷方式。比如 Promise.resolve(42) 可以认为是以下代码的语法糖。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">  resolve(<span class="number">42</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>在这段代码中的 resolve(42) 会让这个 Promise 对象立即进入确定（即resolved）状态，并将 42 传递给后面 then 里所指定的 onFulfilled 函数。方法 Promise.resolve(value) 的返回值也是一个 Promise 对象，所以我们可以像下面那样接着对其返回值进行 .then 调用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="number">42</span>).then(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>Promise.resolve 作为 new Promise() 的快捷方式，在进行 Promise 对象的初始化或者编写测试代码的时候都非常方便。</p>
<h3 id="10-4-Promise-reject"><a href="#10-4-Promise-reject" class="headerlink" title="10.4 Promise.reject()"></a>10.4 Promise.reject()</h3><p>Promise.reject(error) 是和 Promise.resolve(value) 类似的静态方法，是 new Promise() 方法的快捷方式。比如 Promise.reject(new Error(“出错了”)) 就是下面代码的语法糖形式。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;出错了&#x27;</span>))</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>这段代码的功能是调用该Promise 对象通过then指定的 onRejected 函数，并将错误（Error）对象传递给这个 onRejected 函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;BOOM!&#x27;</span>))</span><br></pre></td></tr></table></figure>

<h3 id="10-5-Promise-prototype-catch"><a href="#10-5-Promise-prototype-catch" class="headerlink" title="10.5 Promise.prototype.catch()"></a>10.5 Promise.prototype.catch()</h3><p>捕获异常是程序质量保障最基本的要求，可以使用 Promise 对象的 catch 方法来捕获异步操作过程中出现的任何异常。</p>
<p><strong>基本语法</strong></p>
<blockquote>
<p>p.catch(onRejected);</p>
</blockquote>
<blockquote>
<p>p.catch(function(reason) {<br>// rejection<br>});</p>
</blockquote>
<p><strong>示例</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;es&#x27;</span>))</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test().catch(<span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.message) <span class="comment">// es</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>这个代码展示了如何使用 catch 捕获 Promise 对象中的异常，有的同学会问 catch 捕获的是 Promise 内部的 Error 还是 Reject？上面的示例既用了 reject 也用了 Error，到底是哪个触发的这个捕获呢？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;wrong&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test().catch(<span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.message) <span class="comment">// wrong</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>这个代码对比着上个代码就能明显感受出来的，throw Error 和 reject 都触发了 catch 的捕获，而第一个用法中虽然也有 Error 但是它不是 throw，只是 reject 的参数是 Error 对象，换句话说 new Error 不会触发 catch，而是 reject。</p>
<blockquote>
<p>[!WARNING]<br>不建议在 Promise 内部使用 throw 来触发异常，而是使用 <code>reject(new Error())</code> 的方式来做，因为 throw 的方式并没有改变 Pronise 的状态</p>
</blockquote>
<h3 id="10-6-Promise-all"><a href="#10-6-Promise-all" class="headerlink" title="10.6 Promise.all()"></a>10.6 Promise.all()</h3><p><strong>基本语法</strong></p>
<blockquote>
<p>Promise.all(promiseArray);</p>
</blockquote>
<p><strong>示例</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="built_in">Promise</span>.resolve(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="built_in">Promise</span>.resolve(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">var</span> p3 = <span class="built_in">Promise</span>.resolve(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">Promise</span>.all([p1, p2, p3]).then(<span class="function"><span class="keyword">function</span> (<span class="params">results</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(results) <span class="comment">// [1, 2, 3]</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>Promise.all 生成并返回一个新的 Promise 对象，所以它可以使用 Promise 实例的所有方法。参数传递promise数组中所有的 Promise 对象都变为resolve的时候，该方法才会返回， 新创建的 Promise 则会使用这些 promise 的值。如果参数中的任何一个promise为reject的话，则整个Promise.all调用会立即终止，并返回一个reject的新的 Promise 对象。由于参数数组中的每个元素都是由 Promise.resolve 包装（wrap）的，所以Paomise.all 可以处理不同类型的 promose对象。</p>
<h3 id="10-7-Promise-race"><a href="#10-7-Promise-race" class="headerlink" title="10.7 Promise.race()"></a>10.7 Promise.race()</h3><p><strong>基本语法</strong></p>
<blockquote>
<p>Promise.race(promiseArray);</p>
</blockquote>
<p><strong>示例</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="built_in">Promise</span>.resolve(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="built_in">Promise</span>.resolve(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">var</span> p3 = <span class="built_in">Promise</span>.resolve(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">Promise</span>.race([p1, p2, p3]).then(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value) <span class="comment">// 1</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>Promise.race 生成并返回一个新的 Promise 对象。参数 promise 数组中的任何一个 Promise 对象如果变为 resolve 或者 reject 的话， 该函数就会返回，并使用这个 Promise 对象的值进行 resolve 或者 reject。</p>
<h3 id="扩展阅读-9"><a href="#扩展阅读-9" class="headerlink" title="@ 扩展阅读"></a>@ 扩展阅读</h3><ol>
<li>Promise：<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise</a></li>
<li>fetch：<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API/Using_Fetch">https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API/Using_Fetch</a></li>
<li>JavaScript Promise：<a target="_blank" rel="noopener" href="https://developers.google.com/web/fundamentals/primers/promises?hl=zh-cn">https://developers.google.com/web/fundamentals/primers/promises?hl=zh-cn</a></li>
<li>ES6 Promises in Depth：<a target="_blank" rel="noopener" href="https://ponyfoo.com/articles/es6-promises-in-depth">https://ponyfoo.com/articles/es6-promises-in-depth</a></li>
<li>Using Promises：<a target="_blank" rel="noopener" href="http://ccoenraets.github.io/es6-tutorial/promises/">http://ccoenraets.github.io/es6-tutorial/promises/</a></li>
<li>JavaScript Promises for Dummies：<a target="_blank" rel="noopener" href="https://scotch.io/tutorials/javascript-promises-for-dummies">https://scotch.io/tutorials/javascript-promises-for-dummies</a></li>
</ol>
<h2 id="11、Reflect"><a href="#11、Reflect" class="headerlink" title="11、Reflect"></a>11、Reflect</h2><p>Reflect 是一个内置的对象，它提供拦截 JavaScript 操作的方法，这些方法与处理器对象的方法相同。Reflect不是一个函数对象，因此它是不可构造的。</p>
<blockquote>
<p>[!TIP]<br>与大多数全局对象不同，Reflect没有构造函数。你不能将其与一个new运算符一起使用，或者将Reflect对象作为一个函数来调用。Reflect的所有属性和方法都是静态的（就像Math对象）</p>
</blockquote>
<h3 id="11-1-Reflect-apply"><a href="#11-1-Reflect-apply" class="headerlink" title="11.1 Reflect.apply()"></a>11.1 Reflect.apply()</h3><p><strong>语法</strong></p>
<blockquote>
<p>Reflect.apply(target, thisArgument, argumentsList)</p>
</blockquote>
<p><strong>解释</strong></p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">含义</th>
<th align="left">必选</th>
</tr>
</thead>
<tbody><tr>
<td align="left">target</td>
<td align="left">目标函数</td>
<td align="left">Y</td>
</tr>
<tr>
<td align="left">thisArgument</td>
<td align="left">target函数调用时绑定的this对象</td>
<td align="left">N</td>
</tr>
<tr>
<td align="left">argumentsList</td>
<td align="left">target函数调用时传入的实参列表，该参数应该是一个类数组的对象</td>
<td align="left">N</td>
</tr>
</tbody></table>
<p><strong>示例</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Reflect</span>.apply(<span class="built_in">Math</span>.floor, <span class="literal">undefined</span>, [<span class="number">1.75</span>]) <span class="comment">// 1;</span></span><br><span class="line"><span class="built_in">Reflect</span>.apply(<span class="built_in">String</span>.fromCharCode, <span class="literal">undefined</span>, [<span class="number">104</span>, <span class="number">101</span>, <span class="number">108</span>, <span class="number">108</span>, <span class="number">111</span>]) <span class="comment">// &quot;hello&quot;</span></span><br><span class="line"><span class="built_in">Reflect</span>.apply(<span class="built_in">RegExp</span>.prototype.exec, <span class="regexp">/ab/</span>, [<span class="string">&#x27;confabulation&#x27;</span>]).index  <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">Reflect</span>.apply(<span class="string">&#x27;&#x27;</span>.charAt, <span class="string">&#x27;ponies&#x27;</span>, [<span class="number">3</span>]) <span class="comment">// &quot;i&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>ES5 对比</strong></p>
<p>该方法与ES5中Function.prototype.apply()方法类似：调用一个方法并且显式地指定this变量和参数列表(arguments) ，参数列表可以是数组，或类似数组的对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.apply.call(<span class="built_in">Math</span>.floor, <span class="literal">undefined</span>, [<span class="number">1.75</span>]);</span><br></pre></td></tr></table></figure>

<h3 id="11-2-Reflect-construct"><a href="#11-2-Reflect-construct" class="headerlink" title="11.2 Reflect.construct()"></a>11.2 Reflect.construct()</h3><p>Reflect.construct() 方法的行为有点像 new 操作符 构造函数，相当于运行 new target(…args)。</p>
<p><strong>语法</strong></p>
<blockquote>
<p>Reflect.construct(target, argumentsList[, newTarget])</p>
</blockquote>
<p><strong>解释</strong></p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">含义</th>
<th align="left">必选</th>
</tr>
</thead>
<tbody><tr>
<td align="left">target</td>
<td align="left">被运行的目标函数</td>
<td align="left">Y</td>
</tr>
<tr>
<td align="left">argumentsList</td>
<td align="left">调用构造函数的数组或者伪数组</td>
<td align="left">Y</td>
</tr>
<tr>
<td align="left">newTarget</td>
<td align="left">该参数为构造函数， 参考 new.target 操作符，如果没有newTarget参数， 默认和target一样</td>
<td align="left">N</td>
</tr>
</tbody></table>
<blockquote>
<p>[!WARNING]<br>如果target或者newTarget不是构造函数，抛出TypeError</p>
</blockquote>
<p>Reflect.construct允许你使用可变的参数来调用构造函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> Foo(...args);</span><br><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Reflect</span>.construct(Foo, args);</span><br></pre></td></tr></table></figure>

<p><strong>示例</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> d = <span class="built_in">Reflect</span>.construct(<span class="built_in">Date</span>, [<span class="number">1776</span>, <span class="number">6</span>, <span class="number">4</span>])</span><br><span class="line">d <span class="keyword">instanceof</span> <span class="built_in">Date</span> <span class="comment">// true</span></span><br><span class="line">d.getFullYear() <span class="comment">// 1776</span></span><br></pre></td></tr></table></figure>

<p>如果使用 newTarget 参数，则表示继承了 newTarget 这个超类：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">someConstructor</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> result = <span class="built_in">Reflect</span>.construct(<span class="built_in">Array</span>, [], someConstructor)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Reflect</span>.getPrototypeOf(result) <span class="comment">// 输出：someConstructor.prototype</span></span><br><span class="line"><span class="built_in">Array</span>.isArray(result) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="11-3-Reflect-defineProperty"><a href="#11-3-Reflect-defineProperty" class="headerlink" title="11.3 Reflect.defineProperty()"></a>11.3 Reflect.defineProperty()</h3><p>静态方法 Reflect.defineProperty() 基本等同于 Object.defineProperty() 方法，唯一不同是返回 Boolean 值。</p>
<p><strong>语法</strong></p>
<blockquote>
<p>Reflect.defineProperty(target, propertyKey, attributes)</p>
</blockquote>
<p><strong>解释</strong></p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">含义</th>
<th align="left">必选</th>
</tr>
</thead>
<tbody><tr>
<td align="left">target</td>
<td align="left">目标对象</td>
<td align="left">Y</td>
</tr>
<tr>
<td align="left">propertyKey</td>
<td align="left">要定义或修改的属性的名称</td>
<td align="left">Y</td>
</tr>
<tr>
<td align="left">attributes</td>
<td align="left">要定义或修改的属性的描述</td>
<td align="left">Y</td>
</tr>
</tbody></table>
<p><strong>示例</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> student = &#123;&#125;</span><br><span class="line"><span class="built_in">Reflect</span>.defineProperty(student, <span class="string">&#x27;name&#x27;</span>, &#123; <span class="attr">value</span>: <span class="string">&#x27;Mike&#x27;</span> &#125;) <span class="comment">// true</span></span><br><span class="line">student.name <span class="comment">// &quot;Mike&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="11-4-Reflect-deleteProperty"><a href="#11-4-Reflect-deleteProperty" class="headerlink" title="11.4 Reflect.deleteProperty()"></a>11.4 Reflect.deleteProperty()</h3><p>Reflect.deleteProperty 允许你删除一个对象上的属性。返回一个 Boolean 值表示该属性是否被成功删除。它几乎与非严格的 delete operator 相同。</p>
<p><strong>语法</strong></p>
<blockquote>
<p>Reflect.deleteProperty(target, propertyKey)</p>
</blockquote>
<p><strong>解释</strong></p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">含义</th>
<th align="left">必选</th>
</tr>
</thead>
<tbody><tr>
<td align="left">target</td>
<td align="left">删除属性的目标对象</td>
<td align="left">Y</td>
</tr>
<tr>
<td align="left">propertyKey</td>
<td align="left">将被删除的属性的名称</td>
<td align="left">Y</td>
</tr>
</tbody></table>
<p><strong>示例</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="built_in">Reflect</span>.deleteProperty(obj, <span class="string">&quot;x&quot;</span>); <span class="comment">// true</span></span><br><span class="line">obj; <span class="comment">// &#123; y: 2 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="built_in">Reflect</span>.deleteProperty(arr, <span class="string">&quot;3&quot;</span>); <span class="comment">// true</span></span><br><span class="line">arr; <span class="comment">// [1, 2, 3, , 5]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果属性不存在，返回 true</span></span><br><span class="line"><span class="built_in">Reflect</span>.deleteProperty(&#123;&#125;, <span class="string">&quot;foo&quot;</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果属性不可配置，返回 false</span></span><br><span class="line"><span class="built_in">Reflect</span>.deleteProperty(<span class="built_in">Object</span>.freeze(&#123;<span class="attr">foo</span>: <span class="number">1</span>&#125;), <span class="string">&quot;foo&quot;</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h3 id="11-5-Reflect-get"><a href="#11-5-Reflect-get" class="headerlink" title="11.5 Reflect.get()"></a>11.5 Reflect.get()</h3><p>Reflect.get() 方法的工作方式，就像从 object (target[propertyKey]) 中获取属性，但它是作为一个函数执行的。</p>
<p><strong>语法</strong></p>
<blockquote>
<p>Reflect.get(target, propertyKey[, receiver])</p>
</blockquote>
<p><strong>解释</strong></p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">含义</th>
<th align="left">必选</th>
</tr>
</thead>
<tbody><tr>
<td align="left">target</td>
<td align="left">需要取值的目标对象</td>
<td align="left">Y</td>
</tr>
<tr>
<td align="left">propertyKey</td>
<td align="left">需要获取的值的键值</td>
<td align="left">Y</td>
</tr>
<tr>
<td align="left">receiver</td>
<td align="left">如果遇到 getter，此值将提供给目标调用</td>
<td align="left">N</td>
</tr>
</tbody></table>
<p><strong>示例</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Object</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span> &#125;</span><br><span class="line"><span class="built_in">Reflect</span>.get(obj, <span class="string">&#x27;x&#x27;</span>) <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Array</span></span><br><span class="line"><span class="built_in">Reflect</span>.get([<span class="string">&#x27;zero&#x27;</span>, <span class="string">&#x27;one&#x27;</span>], <span class="number">1</span>) <span class="comment">// &quot;one&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Proxy with a get handler</span></span><br><span class="line"><span class="keyword">var</span> x = &#123; <span class="attr">p</span>: <span class="number">1</span> &#125;</span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Proxy</span>(x, &#123;</span><br><span class="line">  get (t, k, r) &#123; <span class="keyword">return</span> k + <span class="string">&#x27;bar&#x27;</span> &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">Reflect</span>.get(obj, <span class="string">&#x27;foo&#x27;</span>) <span class="comment">// &quot;foobar&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="11-6-Reflect-getOwnPropertyDescriptor"><a href="#11-6-Reflect-getOwnPropertyDescriptor" class="headerlink" title="11.6 Reflect.getOwnPropertyDescriptor()"></a>11.6 Reflect.getOwnPropertyDescriptor()</h3><p>静态方法 Reflect.getOwnPropertyDescriptor() 与 Object.getOwnPropertyDescriptor() 方法相似。如果在对象中存在，则返回给定的属性的属性描述符，否则返回 undefined。</p>
<p><strong>语法</strong></p>
<blockquote>
<p>Reflect.getOwnPropertyDescriptor(target, propertyKey)</p>
</blockquote>
<p><strong>解释</strong></p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">含义</th>
<th align="left">必选</th>
</tr>
</thead>
<tbody><tr>
<td align="left">target</td>
<td align="left">需要寻找属性的目标对象</td>
<td align="left">Y</td>
</tr>
<tr>
<td align="left">propertyKey</td>
<td align="left">获取自己的属性描述符的属性的名称</td>
<td align="left">N</td>
</tr>
</tbody></table>
<p><strong>示例</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Reflect</span>.getOwnPropertyDescriptor(&#123; <span class="attr">x</span>: <span class="string">&#x27;hello&#x27;</span> &#125;, <span class="string">&#x27;x&#x27;</span>)</span><br><span class="line"><span class="comment">// &#123;value: &quot;hello&quot;, writable: true, enumerable: true, configurable: true&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Reflect</span>.getOwnPropertyDescriptor(&#123; <span class="attr">x</span>: <span class="string">&#x27;hello&#x27;</span> &#125;, <span class="string">&#x27;y&#x27;</span>)</span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Reflect</span>.getOwnPropertyDescriptor([], <span class="string">&#x27;length&#x27;</span>)</span><br><span class="line"><span class="comment">// &#123;value: 0, writable: true, enumerable: false, configurable: false&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>对比</strong></p>
<p>如果该方法的第一个参数不是一个对象（一个原始值），那么将造成 TypeError 错误。而对于 Object.getOwnPropertyDescriptor，非对象的第一个参数将被强制转换为一个对象处理。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Reflect</span>.getOwnPropertyDescriptor(<span class="string">&quot;foo&quot;</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// TypeError: &quot;foo&quot; is not non-null object</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(<span class="string">&quot;foo&quot;</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// &#123; value: &quot;f&quot;, writable: false, enumerable: true, configurable: false &#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="11-7-Reflect-getPrototypeOf"><a href="#11-7-Reflect-getPrototypeOf" class="headerlink" title="11.7 Reflect.getPrototypeOf()"></a>11.7 Reflect.getPrototypeOf()</h3><p>静态方法 Reflect.getPrototypeOf() 与 Object.getPrototypeOf() 方法是一样的。都是返回指定对象的原型（即，内部的 [[Prototype]] 属性的值）。</p>
<p><strong>语法</strong></p>
<blockquote>
<p>Reflect.getPrototypeOf(target)</p>
</blockquote>
<p><strong>解释</strong></p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">含义</th>
<th align="left">必选</th>
</tr>
</thead>
<tbody><tr>
<td align="left">target</td>
<td align="left">获取原型的目标对象</td>
<td align="left">Y</td>
</tr>
</tbody></table>
<h3 id="11-8-Reflect-has"><a href="#11-8-Reflect-has" class="headerlink" title="11.8 Reflect.has()"></a>11.8 Reflect.has()</h3><p>Reflect.has 用于检查一个对象是否拥有某个属性， 相当于in 操作符</p>
<p><strong>语法</strong></p>
<blockquote>
<p>Reflect.has(target, propertyKey)</p>
</blockquote>
<p><strong>解释</strong></p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">含义</th>
<th align="left">必选</th>
</tr>
</thead>
<tbody><tr>
<td align="left">target</td>
<td align="left">获取原型的目标对象</td>
<td align="left">Y</td>
</tr>
<tr>
<td align="left">propertyKey</td>
<td align="left">属性名，需要检查目标对象是否存在此属性</td>
<td align="left">Y</td>
</tr>
</tbody></table>
<h3 id="11-9-Reflect-isExtensible"><a href="#11-9-Reflect-isExtensible" class="headerlink" title="11.9 Reflect.isExtensible()"></a>11.9 Reflect.isExtensible()</h3><p>Reflect.isExtensible 判断一个对象是否可扩展 （即是否能够添加新的属性），它与 Object.isExtensible() 方法一样。</p>
<p><strong>语法</strong></p>
<blockquote>
<p>Reflect.isExtensible(target)</p>
</blockquote>
<p><strong>解释</strong></p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">含义</th>
<th align="left">必选</th>
</tr>
</thead>
<tbody><tr>
<td align="left">target</td>
<td align="left">获取原型的目标对象</td>
<td align="left">Y</td>
</tr>
</tbody></table>
<h3 id="11-10-Reflect-ownKeys"><a href="#11-10-Reflect-ownKeys" class="headerlink" title="11.10 Reflect.ownKeys()"></a>11.10 Reflect.ownKeys()</h3><p>Reflect.ownKeys 方法返回一个由目标对象自身的属性键组成的数组。它的返回值等同于 Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target))</p>
<p><strong>语法</strong></p>
<blockquote>
<p>Reflect.ownKeys(target)</p>
</blockquote>
<p><strong>解释</strong></p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">含义</th>
<th align="left">必选</th>
</tr>
</thead>
<tbody><tr>
<td align="left">target</td>
<td align="left">获取原型的目标对象</td>
<td align="left">Y</td>
</tr>
</tbody></table>
<p><strong>示例</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Reflect</span>.ownKeys(&#123;<span class="attr">z</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">2</span>, <span class="attr">x</span>: <span class="number">1</span>&#125;); <span class="comment">// [ &quot;z&quot;, &quot;y&quot;, &quot;x&quot; ]</span></span><br><span class="line"><span class="built_in">Reflect</span>.ownKeys([]); <span class="comment">// [&quot;length&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sym = <span class="built_in">Symbol</span>.for(<span class="string">&quot;comet&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> sym2 = <span class="built_in">Symbol</span>.for(<span class="string">&quot;meteor&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> obj = &#123;[sym]: <span class="number">0</span>, <span class="string">&quot;str&quot;</span>: <span class="number">0</span>, <span class="string">&quot;773&quot;</span>: <span class="number">0</span>, <span class="string">&quot;0&quot;</span>: <span class="number">0</span>,</span><br><span class="line">           [sym2]: <span class="number">0</span>, <span class="string">&quot;-1&quot;</span>: <span class="number">0</span>, <span class="string">&quot;8&quot;</span>: <span class="number">0</span>, <span class="string">&quot;second str&quot;</span>: <span class="number">0</span>&#125;;</span><br><span class="line"><span class="built_in">Reflect</span>.ownKeys(obj);</span><br><span class="line"><span class="comment">// [ &quot;0&quot;, &quot;8&quot;, &quot;773&quot;, &quot;str&quot;, &quot;-1&quot;, &quot;second str&quot;, Symbol(comet), Symbol(meteor) ]</span></span><br><span class="line"><span class="comment">// Indexes in numeric order,</span></span><br><span class="line"><span class="comment">// strings in insertion order,</span></span><br><span class="line"><span class="comment">// symbols in insertion order</span></span><br></pre></td></tr></table></figure>

<h3 id="11-11-Reflect-preventExtensions"><a href="#11-11-Reflect-preventExtensions" class="headerlink" title="11.11 Reflect.preventExtensions()"></a>11.11 Reflect.preventExtensions()</h3><p>Reflect.preventExtensions 方法阻止新属性添加到对象 例如：防止将来对对象的扩展被添加到对象中)。该方法与 Object.preventExtensions() 方法一致</p>
<p><strong>语法</strong></p>
<blockquote>
<p>Reflect.preventExtensions(target)</p>
</blockquote>
<p><em>解释</em>*</p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">含义</th>
<th align="left">必选</th>
</tr>
</thead>
<tbody><tr>
<td align="left">target</td>
<td align="left">获取原型的目标对象</td>
<td align="left">Y</td>
</tr>
</tbody></table>
<p><strong>示例</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Objects are extensible by default.</span></span><br><span class="line"><span class="keyword">var</span> empty = &#123;&#125;;</span><br><span class="line"><span class="built_in">Reflect</span>.isExtensible(empty); <span class="comment">// === true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ...but that can be changed.</span></span><br><span class="line"><span class="built_in">Reflect</span>.preventExtensions(empty);</span><br><span class="line"><span class="built_in">Reflect</span>.isExtensible(empty); <span class="comment">// === false</span></span><br><span class="line"><span class="built_in">Reflect</span>.preventExtensions(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// TypeError: 1 is not an object</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.preventExtensions(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<h3 id="11-12-Reflect-set"><a href="#11-12-Reflect-set" class="headerlink" title="11.12 Reflect.set()"></a>11.12 Reflect.set()</h3><p>Reflect.set 方法允许你在对象上设置属性。它的作用是给属性赋值并且就像 property accessor 语法一样，但是它是以函数的方式。</p>
<p><strong>语法</strong></p>
<blockquote>
<p>Reflect.set(target, propertyKey, value[, receiver])</p>
</blockquote>
<p><em>解释</em>*</p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">含义</th>
<th align="left">必选</th>
</tr>
</thead>
<tbody><tr>
<td align="left">target</td>
<td align="left">获取原型的目标对象</td>
<td align="left">Y</td>
</tr>
<tr>
<td align="left">propertyKey</td>
<td align="left">设置的属性的名称</td>
<td align="left">Y</td>
</tr>
<tr>
<td align="left">value</td>
<td align="left">设置的值</td>
<td align="left">Y</td>
</tr>
<tr>
<td align="left">receiver</td>
<td align="left">如果遇到 setter，this 将提供给目标调用</td>
<td align="left">N</td>
</tr>
</tbody></table>
<p><strong>示例</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Object</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="built_in">Reflect</span>.set(obj, <span class="string">&quot;prop&quot;</span>, <span class="string">&quot;value&quot;</span>); <span class="comment">// true</span></span><br><span class="line">obj.prop; <span class="comment">// &quot;value&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Array</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="string">&quot;duck&quot;</span>, <span class="string">&quot;duck&quot;</span>, <span class="string">&quot;duck&quot;</span>];</span><br><span class="line"><span class="built_in">Reflect</span>.set(arr, <span class="number">2</span>, <span class="string">&quot;goose&quot;</span>); <span class="comment">// true</span></span><br><span class="line">arr[<span class="number">2</span>]; <span class="comment">// &quot;goose&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// It can truncate an array.</span></span><br><span class="line"><span class="built_in">Reflect</span>.set(arr, <span class="string">&quot;length&quot;</span>, <span class="number">1</span>); <span class="comment">// true</span></span><br><span class="line">arr; <span class="comment">// [&quot;duck&quot;];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// With just one argument, propertyKey and value are &quot;undefined&quot;.</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="built_in">Reflect</span>.set(obj); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Reflect</span>.getOwnPropertyDescriptor(obj, <span class="string">&quot;undefined&quot;</span>);</span><br><span class="line"><span class="comment">// &#123; value: undefined, writable: true, enumerable: true, configurable: true &#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="11-13-Reflect-setPrototypeOf"><a href="#11-13-Reflect-setPrototypeOf" class="headerlink" title="11.13 Reflect.setPrototypeOf()"></a>11.13 Reflect.setPrototypeOf()</h3><p>Reflect.setPrototypeOf 方法改变指定对象的原型 （即，内部的 [[Prototype]] 属性值）</p>
<p><strong>语法</strong></p>
<blockquote>
<p>Reflect.setPrototypeOf(target, prototype)</p>
</blockquote>
<p><em>解释</em>*</p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">含义</th>
<th align="left">必选</th>
</tr>
</thead>
<tbody><tr>
<td align="left">target</td>
<td align="left">获取原型的目标对象</td>
<td align="left">Y</td>
</tr>
<tr>
<td align="left">prototype</td>
<td align="left">对象的新原型 （一个对象或 null）</td>
<td align="left">Y</td>
</tr>
</tbody></table>
<p><strong>示例</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Reflect</span>.setPrototypeOf(&#123;&#125;, <span class="built_in">Object</span>.prototype); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// It can change an object&#x27;s [[Prototype]] to null.</span></span><br><span class="line"><span class="built_in">Reflect</span>.setPrototypeOf(&#123;&#125;, <span class="literal">null</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Returns false if target is not extensible.</span></span><br><span class="line"><span class="built_in">Reflect</span>.setPrototypeOf(<span class="built_in">Object</span>.freeze(&#123;&#125;), <span class="literal">null</span>); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Returns false if it cause a prototype chain cycle.</span></span><br><span class="line"><span class="keyword">var</span> target = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> proto = <span class="built_in">Object</span>.create(target);</span><br><span class="line"><span class="built_in">Reflect</span>.setPrototypeOf(target, proto); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>[!WARNING]<br>对于以上所有 API 第一个参数是 Object 的，如果给定的不是 Object 则抛出一个 TypeError 异常</p>
</blockquote>
<h3 id="扩展阅读-10"><a href="#扩展阅读-10" class="headerlink" title="@ 扩展阅读"></a>@ 扩展阅读</h3><ol>
<li>ES6 Reflection in Depth：<a target="_blank" rel="noopener" href="https://ponyfoo.com/articles/es6-reflection-in-depth">https://ponyfoo.com/articles/es6-reflection-in-depth</a></li>
<li>Reflect Usage：<a target="_blank" rel="noopener" href="https://www.stefanjudis.com/today-i-learned/the-global-reflect-object-its-use-cases-and-things-to-watch-out-for/">https://www.stefanjudis.com/today-i-learned/the-global-reflect-object-its-use-cases-and-things-to-watch-out-for/</a></li>
</ol>
<h2 id="12、Proxy"><a href="#12、Proxy" class="headerlink" title="12、Proxy"></a>12、Proxy</h2><p>在 ES6 标准中新增的一个非常强大的功能是 Proxy，它可以自定义一些常用行为如查找、赋值、枚举、函数调用等。通过 Proxy 这个名称也可以看出来它包含了“代理”的含义，只要有“代理”的诉求都可以考虑使用 Proxy 来实现。</p>
<h3 id="12-1-Basic-Syntax"><a href="#12-1-Basic-Syntax" class="headerlink" title="12.1 Basic Syntax"></a>12.1 Basic Syntax</h3><p><strong>语法</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler)</span><br></pre></td></tr></table></figure>

<p><strong>解释</strong></p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">含义</th>
<th align="left">必选</th>
</tr>
</thead>
<tbody><tr>
<td align="left">target</td>
<td align="left">用 Proxy 包装的目标对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理）</td>
<td align="left">Y</td>
</tr>
<tr>
<td align="left">handler</td>
<td align="left">一个对象，其属性是当执行一个操作时定义代理的行为的函数</td>
<td align="left">Y</td>
</tr>
</tbody></table>
<p>MDN 给出的解释偏官方，通俗的讲第一个参数 target 就是用来代理的“对象”，被代理之后它是不能直接被访问的，而 handler 就是实现代理的过程。</p>
<p><strong>场景</strong></p>
<p>我们经常读取一个对象的 key-value：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> o = &#123;</span><br><span class="line">  name: <span class="string">&#x27;xiaoming&#x27;</span>,</span><br><span class="line">  age: <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(o.name) <span class="comment">// xiaoming</span></span><br><span class="line"><span class="built_in">console</span>.log(o.age) <span class="comment">// 20</span></span><br><span class="line"><span class="built_in">console</span>.log(o.from) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>当我们读取 from 的时候返回的是 undefined，因为 o 这个对象中没有这个 key-value。想想看我们在读取数据的时候，这个数据经常是聚合的，当大家没有按照规范来的时候或者数据缺失的情况下，经常会出现这种“乌龙”现象。如果我们不想在调用 key 的时候返回 undefined，之前的做法是这样的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(o.from || <span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>如果我们对所有代码都是这种写法，那阅读性和观赏性就不得而知了。值得庆幸的是，ES6 的 Proxy 可以让我们轻松的解决这一问题：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> o = &#123;</span><br><span class="line">  name: <span class="string">&#x27;xiaoming&#x27;</span>,</span><br><span class="line">  age: <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> handler = &#123;</span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params">obj, key</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.has(obj, key) ? obj[key] : <span class="string">&#x27;&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>(o, handler)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(p.from)</span><br></pre></td></tr></table></figure>

<p>这个代码是想表达如果 o 对象有这个 key-value 则直接返回，如果没有一律返回 <code>&#39;&#39;</code>，当然这里是自定义，大家可以根据自己的需要来写适合自己业务的规则。</p>
<h3 id="12-2-Schema-Validation"><a href="#12-2-Schema-Validation" class="headerlink" title="12.2 Schema Validation"></a>12.2 Schema Validation</h3><p>刚才对数据的“读操作”进行了拦截，接下来我们描述下“写操作”进行拦截。</p>
<p><strong>场景 1</strong></p>
<p>从服务端获取的数据希望是只读，不允许在任何一个环节被修改。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// response.data 是 JSON 格式的数据，来自服务端的响应</span></span><br><span class="line"><span class="comment">// 在 ES5 中只能通过遍历把所有的属性设置为只读</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key] <span class="keyword">of</span> <span class="built_in">Object</span>.entries(response.data)) &#123;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(response.data, key, &#123;</span><br><span class="line">    writable: <span class="literal">false</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们使用 Proxy 就简单很多了：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> data = <span class="keyword">new</span> <span class="built_in">Proxy</span>(response.data, &#123;</span><br><span class="line">  <span class="function"><span class="title">set</span>(<span class="params">obj, key, value</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>场景 2</strong></p>
<p>对于数据交互而言，校验是不可或缺的一个环境，传统的做法是将校验写在了业务逻辑里，导致代码耦合度较高。如果大家使用 Proxy 就可以将代码设计的非常灵活。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Validator.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (obj, key, value) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Reflect</span>.has(key) &amp;&amp; value &gt; <span class="number">20</span>) &#123;</span><br><span class="line">    obj[key] = value</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Validator <span class="keyword">from</span> <span class="string">&#x27;./Validator&#x27;</span></span><br><span class="line"><span class="keyword">let</span> data = <span class="keyword">new</span> <span class="built_in">Proxy</span>(response.data, &#123;</span><br><span class="line">  set: Validator</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>场景 3</strong></p>
<p>如果对读写进行监控，可以这样写：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> validator = &#123;</span><br><span class="line">  <span class="function"><span class="title">set</span>(<span class="params">target, key, value</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (key === <span class="string">&#x27;age&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> value !== <span class="string">&#x27;number&#x27;</span> || <span class="built_in">Number</span>.isNaN(value)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;Age must be a number&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (value &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;Age must be a positive number&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> person = &#123; <span class="attr">age</span>: <span class="number">27</span> &#125;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(person, validator)</span><br><span class="line">proxy.age = <span class="string">&#x27;foo&#x27;</span></span><br><span class="line"><span class="comment">// &lt;- TypeError: Age must be a number</span></span><br><span class="line">proxy.age = <span class="literal">NaN</span></span><br><span class="line"><span class="comment">// &lt;- TypeError: Age must be a number</span></span><br><span class="line">proxy.age = <span class="number">0</span></span><br><span class="line"><span class="comment">// &lt;- TypeError: Age must be a positive number</span></span><br><span class="line">proxy.age = <span class="number">28</span></span><br><span class="line"><span class="built_in">console</span>.log(person.age)</span><br><span class="line"><span class="comment">// &lt;- 28</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加监控</span></span><br><span class="line"><span class="built_in">window</span>.addEventListener(</span><br><span class="line">  <span class="string">&#x27;error&#x27;</span>,</span><br><span class="line">  e =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e.message) <span class="comment">// Uncaught TypeError: Age must be a number</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">true</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><strong>场景 4</strong></p>
<p>什么实例一个对象，每个对象都有一个自己的 id 而且只读。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="title">constructor</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;</span><br><span class="line">      id: <span class="built_in">Math</span>.random().toString(<span class="number">36</span>).slice(-<span class="number">8</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  get id () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.proxy.id</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="12-3-Revocable-Proxies"><a href="#12-3-Revocable-Proxies" class="headerlink" title="12.3 Revocable Proxies"></a>12.3 Revocable Proxies</h3><p>除了使用常规的代理，还可以创建临时的代理，这个临时可以理解为：代理可以取消。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> dinosaur = &#123;</span><br><span class="line">  name: <span class="string">&#x27;Fred&#x27;</span>,</span><br><span class="line">  isDangerous: <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dinoProxy = <span class="built_in">Proxy</span>.revocable(dinosaur, &#123;</span><br><span class="line">  get: <span class="function">(<span class="params">target, property</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;RAWRRRRRRRR&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// We need this assignment because the `revocable` method returns an object with the proxified object and the revoke method</span></span><br><span class="line"><span class="keyword">const</span> proxifiedDinosaur = dinoProxy.proxy</span><br><span class="line"></span><br><span class="line"><span class="comment">// Now everytime we access a property in our `proxifiedDinosaur` it gets intercepted by the `get` trap in our handler</span></span><br><span class="line"><span class="built_in">console</span>.log(proxifiedDinosaur.name) <span class="comment">// &quot;RAWRRRRRRRR&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(proxifiedDinosaur.isDangerous) <span class="comment">// &quot;RAWRRRRRRRR&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Now, if we call `revoke` on our `dinoProxy` we get a TypeError when accessing properties on `proxifiedDinosaur`</span></span><br><span class="line">dinoProxy.revoke()</span><br><span class="line"><span class="built_in">console</span>.log(proxifiedDinosaur.name) <span class="comment">// TypeError: Cannot perform &#x27;get&#x27; on a proxy that has been revoked</span></span><br><span class="line"><span class="built_in">console</span>.log(proxifiedDinosaur.isDangerous) <span class="comment">// TypeError: Cannot perform &#x27;get&#x27; on a proxy that has been revoked</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>[!TIP]<br>一旦 revoke 被调用，proxy 就失效了，这也就起到了“临时”代理的作用</p>
</blockquote>
<h3 id="扩展阅读-11"><a href="#扩展阅读-11" class="headerlink" title="@ 扩展阅读"></a>@ 扩展阅读</h3><ol>
<li>ES6 Proxies in Depth：<a target="_blank" rel="noopener" href="https://ponyfoo.com/articles/es6-proxies-in-depth">https://ponyfoo.com/articles/es6-proxies-in-depth</a></li>
<li>Meta Programming In JavaScript - Part Three: Proxies and Reflection：<a target="_blank" rel="noopener" href="https://lucasfcosta.com/2016/11/15/Meta-Programming-in-JavaScript-Part-Three.html">https://lucasfcosta.com/2016/11/15/Meta-Programming-in-JavaScript-Part-Three.html</a></li>
<li>How to Use Proxies：<a target="_blank" rel="noopener" href="https://www.sitepoint.com/es6-proxies/">https://www.sitepoint.com/es6-proxies/</a></li>
<li>ES6 Proxies in practice：](<a target="_blank" rel="noopener" href="https://habr.com/en/post/448214/">https://habr.com/en/post/448214/</a>)</li>
</ol>
<h2 id="13、Generator"><a href="#13、Generator" class="headerlink" title="13、Generator"></a>13、Generator</h2><h3 id="13-1-Intro"><a href="#13-1-Intro" class="headerlink" title="13.1 Intro"></a>13.1 Intro</h3><p>什么是 JavaScript Generators 呢？通俗的讲 Generators 是可以用来控制迭代器的函数。它们可以暂停，然后在任何时候恢复。如果这句话不好理解，可以看下接下来的示例。</p>
<p><strong>1. 常规循环</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i += <span class="number">1</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// this will return immediately 0 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4</span></span><br></pre></td></tr></table></figure>

<p><strong>2. 利用 Generator</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">generatorForLoop</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i += <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="built_in">console</span>.log(i)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> genForLoop = generatorForLoop()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(genForLoop.next()) <span class="comment">// first console.log - 0</span></span><br><span class="line"><span class="built_in">console</span>.log(genForLoop.next()) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(genForLoop.next()) <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(genForLoop.next()) <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(genForLoop.next()) <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>

<p>对比下代码，常规的循环只能一次遍历完所有值，Generator 可以通过调用 next 方法拿到依次遍历的值，让遍历的执行变得“可控”。</p>
<h3 id="13-2-Basic-Syntax"><a href="#13-2-Basic-Syntax" class="headerlink" title="13.2 Basic Syntax"></a>13.2 Basic Syntax</h3><h4 id="13-2-1-语法"><a href="#13-2-1-语法" class="headerlink" title="13.2.1 语法"></a>13.2.1 语法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">gen</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> g = gen()</span><br><span class="line"><span class="comment">// &quot;Generator &#123; &#125;&quot;</span></span><br></pre></td></tr></table></figure>

<p>这个是 Generator 的定义方法，有几个点值得注意：</p>
<ol>
<li>比普通函数多一个 <code>*</code></li>
<li>函数内部用<code>yield</code> 来控制程序的执行的“暂停”</li>
<li>函数的返回值通过调用 next 来“恢复”程序执行</li>
</ol>
<blockquote>
<p>[!DANGER]<br>Generator 函数的定义不能使用箭头函数，否则会触发 SyntaxError 错误</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> generator = *<span class="function">() =&gt;</span> &#123;&#125; <span class="comment">// SyntaxError</span></span><br><span class="line"><span class="keyword">let</span> generator = ()* =&gt; &#123;&#125; <span class="comment">// SyntaxError</span></span><br><span class="line"><span class="keyword">let</span> generator = <span class="function">(<span class="params">*</span>) =&gt;</span> &#123;&#125; <span class="comment">// SyntaxError</span></span><br></pre></td></tr></table></figure>

<p>这些做法都是错误的❌。</p>
<h4 id="13-2-2-yield-表达式"><a href="#13-2-2-yield-表达式" class="headerlink" title="13.2.2 yield 表达式"></a>13.2.2 yield 表达式</h4><blockquote>
<p>yield 关键字用来暂停和恢复一个生成器函数</p>
</blockquote>
<p>关于 yield 表达式，要熟记几个知识点：</p>
<ol>
<li><p>yield 表达式的返回值是 undefined，但是遍历器对象的 next 方法可以修改这个默认值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">gen</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> val</span><br><span class="line">  val = <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`1:<span class="subst">$&#123;val&#125;</span>`</span>) <span class="comment">// 1:undefined</span></span><br><span class="line">  val = <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`2:<span class="subst">$&#123;val&#125;</span>`</span>) <span class="comment">// 2:undefined</span></span><br><span class="line">  val = <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`3:<span class="subst">$&#123;val&#125;</span>`</span>) <span class="comment">// 3:undefined</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = gen()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(g.next()) <span class="comment">// &#123;value: 1, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(g.next()) <span class="comment">// &#123;value: 2, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(g.next()) <span class="comment">// &#123;value: 3, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(g.next()) <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>从这个代码可以看出来，yield 表达式的返回值是 undefined。</p>
<ol start="2">
<li><p>yeild * 是委托给另一个遍历器对象或者可遍历对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">gen</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> val</span><br><span class="line">  val = <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`1:<span class="subst">$&#123;val&#125;</span>`</span>) <span class="comment">// 1:undefined</span></span><br><span class="line">  val = <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`2:<span class="subst">$&#123;val&#125;</span>`</span>) <span class="comment">// 2:undefined</span></span><br><span class="line">  val = <span class="keyword">yield</span> [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`3:<span class="subst">$&#123;val&#125;</span>`</span>) <span class="comment">// 3:undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Generator 对象的 next 方法，遇到 yield 就暂停，并返回一个对象，这个对象包括两个属性：value 和 done。</p>
</li>
</ol>
<p>参考步骤1 的代码可以明确看出来，执行第一句 <code>g.next</code> gen 代码执行到 yield 1，程序暂停，此时返回了一个对象：{value: 1, done: false}</p>
<h4 id="13-2-3-方法"><a href="#13-2-3-方法" class="headerlink" title="13.2.3 方法"></a>13.2.3 方法</h4><p>Generator 对象有几个方法，next、return、throw。</p>
<p><strong>- next([value])</strong></p>
<p>前面我们讲了，Generator 对象通过 next 方法来获取每一次遍历的结果，这个方法返回一个对象，这个对象包含两个属性：value 和 done。value 是指当前程序的运行结果，done 表示遍历是否结束。</p>
<p>其实 next 是可以接受参数的，这个参数可以让你在 Generator 外部给内部传递数据，而这个参数就是作为 yield 的返回值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">gen</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> val = <span class="number">100</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`before <span class="subst">$&#123;val&#125;</span>`</span>)</span><br><span class="line">    val = <span class="keyword">yield</span> val</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`return <span class="subst">$&#123;val&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = gen()</span><br><span class="line"><span class="built_in">console</span>.log(g.next(<span class="number">20</span>).value)</span><br><span class="line"><span class="comment">// before 100</span></span><br><span class="line"><span class="comment">// 100</span></span><br><span class="line"><span class="built_in">console</span>.log(g.next(<span class="number">30</span>).value)</span><br><span class="line"><span class="comment">// return 30</span></span><br><span class="line"><span class="comment">// before 30</span></span><br><span class="line"><span class="comment">// 30</span></span><br><span class="line"><span class="built_in">console</span>.log(g.next(<span class="number">40</span>).value)</span><br><span class="line"><span class="comment">// return 40</span></span><br><span class="line"><span class="comment">// before 40</span></span><br><span class="line"><span class="comment">// 40</span></span><br></pre></td></tr></table></figure>

<p>如果对上面的话和代码不理解，可以把 <code>console.log(g.next(30).value)</code> 和 <code>console.log(g.next(40).value)</code>注释掉。你会发现 只输出了 before 100 和 100，这是为什么呢？下面我们来还原下这段代码的执行过程：</p>
<ol>
<li>g.next(20) 这句代码会执行 gen 内部的代码，遇到第一个 yield 暂停。所以 <code>console.log(</code>before ${val}<code>)</code> 执行输出了 <code>before 100</code>，此时的 val 是 100，所以执行到 yield val 返回了 100，注意 <code>yield val</code> 并没有赋值给 val。</li>
<li>g.next(30) 这句代码会继续执行 gen 内部的代码，也就是 <code>val = yield val</code> 这句，因为 next 传入了 30，所以 yield val 这个返回值就是 30，因此 val 被赋值 30，执行到<code>console.log(</code>return ${val}<code>)</code>输出了 30，此时没有遇到 yield 代码继续执行，也就是 while 的判断，继续执行<code>console.log(</code>before ${val}<code>)</code> 输出了 <code>before 30</code>，再执行遇到了<code>yield val</code>程序暂停。</li>
<li>g.next(40) 重复步骤 2。</li>
</ol>
<p><strong>- return()</strong></p>
<p>return 方法可以让 Generator 遍历终止，有点类似 for 循环的 break。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">gen</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = gen()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(g.next()) <span class="comment">// &#123;value: 1, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(g.return()) <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(g.next()) <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure>

<p>从 done 可以看出代码执行已经结束。</p>
<p>当然 return 也可以传入参数，作为返回的 value 值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">gen</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = gen()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(g.next()) <span class="comment">// &#123;value: 1, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(g.return(<span class="number">100</span>)) <span class="comment">// &#123;value: 100, done: true&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(g.next()) <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>- throw()</strong></p>
<p>可以通过 throw 方法在 Generator 外部控制内部执行的“终断”。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">gen</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">yield</span> <span class="number">42</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(e.message)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> g = gen()</span><br><span class="line"><span class="built_in">console</span>.log(g.next()) <span class="comment">// &#123; value: 42, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(g.next()) <span class="comment">// &#123; value: 42, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(g.next()) <span class="comment">// &#123; value: 42, done: false &#125;</span></span><br><span class="line"><span class="comment">// 中断操作</span></span><br><span class="line">g.throw(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;break&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(g.next()) <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>[!TIP]<br>如果想退出遍历 catch 之后可以配合 <code>return false</code> 使用，能起到 “break” 的作用</p>
</blockquote>
<h3 id="Scene-Practice"><a href="#Scene-Practice" class="headerlink" title="Scene Practice"></a>Scene Practice</h3><p>Generator 相对抽象些，我们多列举一些应用场景帮助大家理解。</p>
<h4 id="场景1"><a href="#场景1" class="headerlink" title="场景1"></a>场景1</h4><p>我们在商品搞活动的时候，通常会有抽奖的环节。回忆下抽奖的流程：</p>
<ol>
<li>满足1000积分的可以抽一等奖（一名）</li>
<li>满足500积分的可以抽二等奖（三名）</li>
<li>满足50积分的可以抽三等奖（五名）</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">draw</span> (<span class="params">first = <span class="number">1</span>, second = <span class="number">3</span>, third = <span class="number">5</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> firstPrize = [<span class="string">&#x27;1A&#x27;</span>, <span class="string">&#x27;1B&#x27;</span>, <span class="string">&#x27;1C&#x27;</span>, <span class="string">&#x27;1D&#x27;</span>, <span class="string">&#x27;1E&#x27;</span>, <span class="string">&#x27;1F&#x27;</span>, <span class="string">&#x27;1G&#x27;</span>, <span class="string">&#x27;1H&#x27;</span>, <span class="string">&#x27;1I&#x27;</span>, <span class="string">&#x27;1J&#x27;</span>, <span class="string">&#x27;1K&#x27;</span>, <span class="string">&#x27;1L&#x27;</span>, <span class="string">&#x27;1M&#x27;</span>, <span class="string">&#x27;1N&#x27;</span>]<span class="comment">// 满足1000积分的名单</span></span><br><span class="line">  <span class="keyword">let</span> secondPrize = [<span class="string">&#x27;2O&#x27;</span>, <span class="string">&#x27;2P&#x27;</span>, <span class="string">&#x27;2Q&#x27;</span>, <span class="string">&#x27;2R&#x27;</span>, <span class="string">&#x27;2S&#x27;</span>, <span class="string">&#x27;2T&#x27;</span>, <span class="string">&#x27;2U&#x27;</span>, <span class="string">&#x27;2V&#x27;</span>, <span class="string">&#x27;2W&#x27;</span>, <span class="string">&#x27;2X&#x27;</span>, <span class="string">&#x27;2Y&#x27;</span>, <span class="string">&#x27;2Z&#x27;</span>] <span class="comment">// 满足500积分的名单</span></span><br><span class="line">  <span class="keyword">let</span> thirdPrize = [<span class="string">&#x27;31&#x27;</span>, <span class="string">&#x27;32&#x27;</span>, <span class="string">&#x27;33&#x27;</span>, <span class="string">&#x27;34&#x27;</span>, <span class="string">&#x27;35&#x27;</span>, <span class="string">&#x27;36&#x27;</span>, <span class="string">&#x27;37&#x27;</span>, <span class="string">&#x27;38&#x27;</span>, <span class="string">&#x27;39&#x27;</span>] <span class="comment">// 满足50积分的名单</span></span><br><span class="line">  <span class="keyword">let</span> count = <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> random</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (count &lt; first) &#123;</span><br><span class="line">      random = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * firstPrize.length)</span><br><span class="line">      <span class="keyword">yield</span> firstPrize[random]</span><br><span class="line">      count++</span><br><span class="line">      firstPrize.splice(random, <span class="number">1</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (count &lt; first + second) &#123;</span><br><span class="line">      random = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * secondPrize.length)</span><br><span class="line">      <span class="keyword">yield</span> secondPrize[random]</span><br><span class="line">      count++</span><br><span class="line">      secondPrize.splice(random, <span class="number">1</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (count &lt; first + second + third) &#123;</span><br><span class="line">      random = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * thirdPrize.length)</span><br><span class="line">      <span class="keyword">yield</span> thirdPrize[random]</span><br><span class="line">      count++</span><br><span class="line">      thirdPrize.splice(random, <span class="number">1</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> t = draw()</span><br><span class="line"><span class="built_in">console</span>.log(t.next().value)</span><br><span class="line"><span class="built_in">console</span>.log(t.next().value)</span><br><span class="line"><span class="built_in">console</span>.log(t.next().value)</span><br><span class="line"><span class="built_in">console</span>.log(t.next().value)</span><br><span class="line"><span class="built_in">console</span>.log(t.next().value)</span><br><span class="line"><span class="built_in">console</span>.log(t.next().value)</span><br><span class="line"><span class="built_in">console</span>.log(t.next().value)</span><br><span class="line"><span class="built_in">console</span>.log(t.next().value)</span><br><span class="line"><span class="built_in">console</span>.log(t.next().value)</span><br></pre></td></tr></table></figure>

<p>从这个代码可以看出来，每次执行都是临时 random，如果是普通函数就只能用三个循环，依次 random 所有名单，这个函数返回所有中奖的名单，而不是每次返回单个名单。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">draw</span> (<span class="params">first = <span class="number">1</span>, second = <span class="number">3</span>, third = <span class="number">5</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> firstPrize = [<span class="string">&#x27;1A&#x27;</span>, <span class="string">&#x27;1B&#x27;</span>, <span class="string">&#x27;1C&#x27;</span>, <span class="string">&#x27;1D&#x27;</span>, <span class="string">&#x27;1E&#x27;</span>, <span class="string">&#x27;1F&#x27;</span>, <span class="string">&#x27;1G&#x27;</span>, <span class="string">&#x27;1H&#x27;</span>, <span class="string">&#x27;1I&#x27;</span>, <span class="string">&#x27;1J&#x27;</span>, <span class="string">&#x27;1K&#x27;</span>, <span class="string">&#x27;1L&#x27;</span>, <span class="string">&#x27;1M&#x27;</span>, <span class="string">&#x27;1N&#x27;</span>]<span class="comment">// 满足1000积分的名单</span></span><br><span class="line">  <span class="keyword">let</span> secondPrize = [<span class="string">&#x27;2O&#x27;</span>, <span class="string">&#x27;2P&#x27;</span>, <span class="string">&#x27;2Q&#x27;</span>, <span class="string">&#x27;2R&#x27;</span>, <span class="string">&#x27;2S&#x27;</span>, <span class="string">&#x27;2T&#x27;</span>, <span class="string">&#x27;2U&#x27;</span>, <span class="string">&#x27;2V&#x27;</span>, <span class="string">&#x27;2W&#x27;</span>, <span class="string">&#x27;2X&#x27;</span>, <span class="string">&#x27;2Y&#x27;</span>, <span class="string">&#x27;2Z&#x27;</span>] <span class="comment">// 满足500积分的名单</span></span><br><span class="line">  <span class="keyword">let</span> thirdPrize = [<span class="string">&#x27;31&#x27;</span>, <span class="string">&#x27;32&#x27;</span>, <span class="string">&#x27;33&#x27;</span>, <span class="string">&#x27;34&#x27;</span>, <span class="string">&#x27;35&#x27;</span>, <span class="string">&#x27;36&#x27;</span>, <span class="string">&#x27;37&#x27;</span>, <span class="string">&#x27;38&#x27;</span>, <span class="string">&#x27;39&#x27;</span>] <span class="comment">// 满足50积分的名单</span></span><br><span class="line">  <span class="keyword">let</span> result = []</span><br><span class="line">  <span class="keyword">let</span> random</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; first; i++) &#123;</span><br><span class="line">    random = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * firstPrize.length)</span><br><span class="line">    result = result.concat(firstPrize.splice(random, <span class="number">1</span>))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; second; i++) &#123;</span><br><span class="line">    random = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * secondPrize.length)</span><br><span class="line">    result = result.concat(secondPrize.splice(random, <span class="number">1</span>))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; third; i++) &#123;</span><br><span class="line">    random = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * thirdPrize.length)</span><br><span class="line">    result = result.concat(thirdPrize.splice(random, <span class="number">1</span>))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> t = draw()</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> t) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大家对比下普通函数和 Generator 的两种写法，哪个体验更好呢？我们总结一下：</p>
<ul>
<li>如果用普通函数的来写，主持人说现在获得一等奖的名单时，其实二等奖和三等奖已经确定了，如果观众知道内幕是不是要不开心了。</li>
<li>如果用Generator来写，主持人每宣布一个名单时，下一个的中奖人他也不知道，这才是真正意义的抽奖体验吧。</li>
</ul>
<h4 id="场景2"><a href="#场景2" class="headerlink" title="场景2"></a>场景2</h4><p>我们经常玩一些小游戏，比如数数字，遇到 3 的倍数就要跳过，从 1 一直往下数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">count</span> (<span class="params">x = <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (x % <span class="number">3</span> !== <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">yield</span> x</span><br><span class="line">    &#125;</span><br><span class="line">    x++</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> num = count()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(num.next().value)</span><br><span class="line"><span class="built_in">console</span>.log(num.next().value)</span><br><span class="line"><span class="built_in">console</span>.log(num.next().value)</span><br><span class="line"><span class="built_in">console</span>.log(num.next().value)</span><br><span class="line"><span class="built_in">console</span>.log(num.next().value)</span><br></pre></td></tr></table></figure>

<p>通过 Generator 我们就能轻松实现，只要调用 num.next 我们就知道下一个数是什么了，而使用普通函数却没法做到。不信你试试看？</p>
<p><strong>练习</strong></p>
<ol>
<li>用 Generator 实现一个斐波那契数列？</li>
<li>用 Generator 给自定义数据结构写一个遍历器？</li>
</ol>
<h3 id="扩展阅读-12"><a href="#扩展阅读-12" class="headerlink" title="@ 扩展阅读"></a>@ 扩展阅读</h3><ol>
<li>What are JavaScript Generators and how to use them：<a target="_blank" rel="noopener" href="https://codeburst.io/what-are-javascript-generators-and-how-to-use-them-c6f2713fd12e">https://codeburst.io/what-are-javascript-generators-and-how-to-use-them-c6f2713fd12e</a></li>
<li>The Basics Of ES6 Generators：<a target="_blank" rel="noopener" href="https://davidwalsh.name/es6-generators">https://davidwalsh.name/es6-generators</a></li>
<li>A Practical Introduction to ES6 Generator Functions：<a target="_blank" rel="noopener" href="https://davidtang.io/2016/10/15/a-practical-introduction-to-es6-generator-functions.html">https://davidtang.io/2016/10/15/a-practical-introduction-to-es6-generator-functions.html</a></li>
<li>斐波那契数列：<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97">https://baike.baidu.com/item/斐波那契数列</a></li>
<li>Generators：<a target="_blank" rel="noopener" href="https://exploringjs.com/es6/ch_generators.html">https://exploringjs.com/es6/ch_generators.html</a></li>
</ol>
<h2 id="14、Iterator"><a href="#14、Iterator" class="headerlink" title="14、Iterator"></a>14、Iterator</h2><h3 id="14-1-Iterable"><a href="#14-1-Iterable" class="headerlink" title="14.1 Iterable"></a>14.1 Iterable</h3><blockquote>
<p>处理集合中的每个项是很常见的操作。JavaScript 提供了许多迭代集合的方法，从简单的for循环到map()和filter()。迭代器和生成器将迭代的概念直接带入核心语言，并提供了一种机制来自定义for…of循环的行为。</p>
</blockquote>
<p>如果对 MDN 这个描述理解不是很到位的话，可以看下接下来这个小示例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> authors = &#123;</span><br><span class="line">  allAuthors: &#123;</span><br><span class="line">    fiction: [</span><br><span class="line">      <span class="string">&#x27;Agatha Christie&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;J. K. Rowling&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;Dr. Seuss&#x27;</span></span><br><span class="line">    ],</span><br><span class="line">    scienceFiction: [</span><br><span class="line">      <span class="string">&#x27;Neal Stephenson&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;Arthur Clarke&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;Isaac Asimov&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;Robert Heinlein&#x27;</span></span><br><span class="line">    ],</span><br><span class="line">    fantasy: [</span><br><span class="line">      <span class="string">&#x27;J. R. R. Tolkien&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;J. K. Rowling&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;Terry Pratchett&#x27;</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个数据结构是汇总了所有作者，每个作者按创作性质进行了分类。如果我们想获取所有作者的名单，该怎么做呢？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> author <span class="keyword">of</span> authors) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(author)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>[!DANGER]<br>你发现这个遍历遇到了报错：Uncaught TypeError: authors is not iterable</p>
</blockquote>
<p>有的同学会说可以这样做：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> authors) &#123;</span><br><span class="line">  <span class="keyword">let</span> r = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> k <span class="keyword">in</span> authors[key]) &#123;</span><br><span class="line">    r = r.concat(authors[key][k])</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(r)</span><br><span class="line">  <span class="comment">// [&quot;Agatha Christie&quot;, &quot;J. K. Rowling&quot;, &quot;Dr. Seuss&quot;, &quot;Neal Stephenson&quot;, &quot;Arthur Clarke&quot;, &quot;Isaac Asimov&quot;, &quot;Robert Heinlein&quot;, &quot;J. R. R. Tolkien&quot;, &quot;J. K. Rowling&quot;, &quot;Terry Pratchett&quot;]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个做法确实可以，实际上也是手动实现的遍历加数据合并，这其实不算是遍历。这个小节就是讲述如何给这种自定义的数据结构进行遍历。</p>
<h3 id="14-2-Iterator"><a href="#14-2-Iterator" class="headerlink" title="14.2 Iterator"></a>14.2 Iterator</h3><p>Iterator 就是 ES6 中用来实现自定义遍历的接口，按照上述的示例，我们来实现下这个接口：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">authors[<span class="built_in">Symbol</span>.iterator] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> allAuthors = <span class="built_in">this</span>.allAuthors</span><br><span class="line">  <span class="keyword">let</span> keys = <span class="built_in">Reflect</span>.ownKeys(allAuthors)</span><br><span class="line">  <span class="keyword">let</span> values = []</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    next () &#123;</span><br><span class="line">      <span class="keyword">if</span> (!values.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (keys.length) &#123;</span><br><span class="line">          values = allAuthors[keys[<span class="number">0</span>]]</span><br><span class="line">          keys.shift()</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        done: !values.length,</span><br><span class="line">        value: values.shift()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个代码在数据结构上部署了 Iterator 接口，我们就可以用 for…of 来遍历代码了：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> authors) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;value&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从代码上我们看到了自定义遍历器的强大，但是我们怎么理解 Iterator 呢？首先，要理解几个概念：可迭代协议和迭代器协议。</p>
<p><strong>1. 迭代器协议</strong></p>
<table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">值</th>
<th align="left">必选</th>
</tr>
</thead>
<tbody><tr>
<td align="left">next</td>
<td align="left">返回一个对象的无参函数，被返回对象拥有两个属性：done 和 value</td>
<td align="left">Y</td>
</tr>
</tbody></table>
<p>这是两个概念：可迭代协议、迭代器协议。通俗的讲，迭代器协议要求符合以下条件：</p>
<ol>
<li>首先，它是一个对象</li>
<li>其次，这个对象包含一个无参函数 next</li>
<li>最后，next 返回一个对象，对象包含 done 和 value 属性。其中 done 表示遍历是否结束，value 返回当前遍历的值。</li>
</ol>
<blockquote>
<p>[!DANGER]<br>如果 next 函数返回一个非对象值（比如false和undefined) 会展示一个 TypeError (“iterator.next() returned a non-object value”) 的错误</p>
</blockquote>
<p><strong>2. 可迭代协议</strong></p>
<p>可迭代协议允许 JavaScript 对象去定义或定制它们的迭代行为, 例如（定义）在一个 for…of 结构中什么值可以被循环（得到）。一些内置类型都是内置的可迭代类型并且有默认的迭代行为, 比如 Array or Map, 另一些类型则不是 (比如Object) 。</p>
<p>为了变成可迭代对象， 一个对象必须实现 @@iterator 方法, 意思是这个对象（或者它原型链 prototype chain 上的某个对象）必须有一个名字是 Symbol.iterator 的属性:</p>
<table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">值</th>
<th align="left">必选</th>
</tr>
</thead>
<tbody><tr>
<td align="left">[Symbol.iterator]</td>
<td align="left">返回一个对象的无参函数，被返回对象符合迭代器协议</td>
<td align="left">Y</td>
</tr>
</tbody></table>
<p>如果让一个对象是可遍历的，就要遵守可迭代协议，该协议要求对象要部署一个以 Symbol.iterator 为 key 的键值对，而 value 就是一个无参函数，这个函数返回的对象要遵守迭代器协议。</p>
<p><strong>Generator</strong></p>
<p>熟悉了 Generator 之后，发现它是天然满足可迭代协议的。上述的代码我们可以用 Generator 来实现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">authors[<span class="built_in">Symbol</span>.iterator] = <span class="function"><span class="keyword">function</span> * (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> allAuthors = <span class="built_in">this</span>.allAuthors</span><br><span class="line">  <span class="keyword">let</span> keys = <span class="built_in">Reflect</span>.ownKeys(allAuthors)</span><br><span class="line">  <span class="keyword">let</span> values = []</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!values.length) &#123;</span><br><span class="line">      <span class="keyword">if</span> (keys.length) &#123;</span><br><span class="line">        values = allAuthors[keys[<span class="number">0</span>]]</span><br><span class="line">        keys.shift()</span><br><span class="line">        <span class="keyword">yield</span> values.shift()</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">yield</span> values.shift()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同一个场景，同一个数据结构，写法确实不同的，利用 Generator 就不再需要显示的写迭代协议了（next方法和包含 done、value 属性的返回对象）。</p>
<p><strong>练习</strong></p>
<ol>
<li>什么是自定义遍历，如果有复杂的数据结构会使用自定义遍历了吗？</li>
<li>什么是迭代协议、可迭代协议？</li>
<li>Generator 和 Iterator 的关联关系理解了吗？</li>
</ol>
<h3 id="扩展阅读-13"><a href="#扩展阅读-13" class="headerlink" title="@ 扩展阅读"></a>@ 扩展阅读</h3><ol start="2">
<li>ES6 迭代器：Iterator, Iterable 和 Generator：<a target="_blank" rel="noopener" href="https://harttle.land/2018/09/29/es6-iterators.html">https://harttle.land/2018/09/29/es6-iterators.html</a></li>
<li>ES6 Iterators and Generators in Practice：<a target="_blank" rel="noopener" href="http://www.zsoltnagy.eu/es6-iterators-and-generators-in-practice/">http://www.zsoltnagy.eu/es6-iterators-and-generators-in-practice/</a></li>
<li>ES6 Generators and Iterators: a Developer’s Guide：<a target="_blank" rel="noopener" href="https://www.sitepoint.com/ecmascript-2015-generators-and-iterators/">https://www.sitepoint.com/ecmascript-2015-generators-and-iterators/</a></li>
</ol>
<h2 id="15、module"><a href="#15、module" class="headerlink" title="15、module"></a>15、module</h2><p>在 ES6 之前，JS 文件之间的导入、导出是需要借助 require.js、sea.js。现在，大家可以使用 import、export 来实现原生 JavaScript 的导入、导出了。</p>
<h3 id="15-1-export"><a href="#15-1-export" class="headerlink" title="15.1 export"></a>15.1 export</h3><ol>
<li><p>导出变量或者常量</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> name = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> addr = <span class="string">&#x27;BeiJing City&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> list = [<span class="number">1</span>, <span class="number">2</span> , <span class="number">3</span>]</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line"><span class="keyword">let</span> addr = <span class="string">&#x27;BeiJing City&#x27;</span></span><br><span class="line"><span class="keyword">var</span> list = [<span class="number">1</span>, <span class="number">2</span> , <span class="number">3</span>]</span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">	name,</span><br><span class="line">	addr,</span><br><span class="line">	list</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>导出函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">say</span> (<span class="params">content</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(content);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;run&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> say = <span class="function">(<span class="params">content</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(content);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> run = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">&#x27;run&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">	say,</span><br><span class="line">	run</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>导出 Object</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> (&#123;</span><br><span class="line"> code: <span class="number">0</span>,</span><br><span class="line"> message: <span class="string">&#x27;success&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> data = &#123;</span><br><span class="line">  code: <span class="number">0</span>,</span><br><span class="line">  message: <span class="string">&#x27;success&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">  data</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>导出 Class</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.id = <span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">  Test</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.id = <span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>修改导出名称</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line"><span class="keyword">let</span> addr = <span class="string">&#x27;BeiJing City&#x27;</span></span><br><span class="line"><span class="keyword">var</span> list = [<span class="number">1</span>, <span class="number">2</span> , <span class="number">3</span>]</span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">  name <span class="keyword">as</span> cname,</span><br><span class="line">  addr <span class="keyword">as</span> caddr,</span><br><span class="line">  list</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>设置默认导出</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line"><span class="keyword">let</span> addr = <span class="string">&#x27;BeiJing City&#x27;</span></span><br><span class="line"><span class="keyword">var</span> list = [<span class="number">1</span>, <span class="number">2</span> , <span class="number">3</span>]</span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">  name <span class="keyword">as</span> cname,</span><br><span class="line">  addr <span class="keyword">as</span> caddr</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> list</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="15-2-import"><a href="#15-2-import" class="headerlink" title="15.2 import"></a>15.2 import</h3><ol>
<li><p>直接导入</p>
<p>假设导出模块 A 是这样的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line"><span class="keyword">let</span> addr = <span class="string">&#x27;BeiJing City&#x27;</span></span><br><span class="line"><span class="keyword">var</span> list = [<span class="number">1</span>, <span class="number">2</span> , <span class="number">3</span>]</span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">  name <span class="keyword">as</span> cname,</span><br><span class="line">  addr <span class="keyword">as</span> caddr</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> list</span><br></pre></td></tr></table></figure>

<p>则导入：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> list, &#123;cname, caddr&#125; <span class="keyword">from</span> A</span><br></pre></td></tr></table></figure></li>
<li><p>修改导入名称</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> list, &#123;cname <span class="keyword">as</span> name, caddr&#125; <span class="keyword">from</span> A</span><br></pre></td></tr></table></figure></li>
<li><p>批量导入</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> list, * <span class="keyword">as</span> mod <span class="keyword">from</span> A</span><br><span class="line"><span class="built_in">console</span>.log(list);</span><br><span class="line"><span class="built_in">console</span>.log(mod.cname);</span><br><span class="line"><span class="built_in">console</span>.log(mod.caddr);</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="扩展阅读-14"><a href="#扩展阅读-14" class="headerlink" title="@ 扩展阅读"></a>@ 扩展阅读</h3><ol>
<li>Modules：<a target="_blank" rel="noopener" href="https://exploringjs.com/es6/ch_modules.html">https://exploringjs.com/es6/ch_modules.html</a></li>
<li>import, export, default cheatsheet：<a target="_blank" rel="noopener" href="https://hackernoon.com/import-export-default-require-commandjs-javascript-nodejs-es6-vs-cheatsheet-different-tutorial-example-5a321738b50f">https://hackernoon.com/import-export-default-require-commandjs-javascript-nodejs-es6-vs-cheatsheet-different-tutorial-example-5a321738b50f</a></li>
<li>ECMAScript 6 modules: the final syntax：<a target="_blank" rel="noopener" href="https://2ality.com/2014/09/es6-modules-final.html">https://2ality.com/2014/09/es6-modules-final.html</a></li>
</ol>
<h1 id="二、ES7-2016"><a href="#二、ES7-2016" class="headerlink" title="二、ES7(2016)"></a>二、ES7(2016)</h1><h2 id="01、Array-prototype-includes"><a href="#01、Array-prototype-includes" class="headerlink" title="01、Array.prototype.includes"></a>01、Array.prototype.includes</h2><p>Array.prototype.includes() 方法用来判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 true，否则返回false。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> array1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(array1.includes(<span class="number">2</span>))</span><br><span class="line"><span class="comment">// expected output: true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> pets = [<span class="string">&#x27;cat&#x27;</span>, <span class="string">&#x27;dog&#x27;</span>, <span class="string">&#x27;bat&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(pets.includes(<span class="string">&#x27;cat&#x27;</span>))</span><br><span class="line"><span class="comment">// expected output: true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(pets.includes(<span class="string">&#x27;at&#x27;</span>))</span><br><span class="line"><span class="comment">// expected output: false</span></span><br></pre></td></tr></table></figure>

<p>在 ES7 之前想判断数组中是否包含一个元素，基本可以这样写：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(array1.find(<span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123; <span class="keyword">return</span> item === <span class="number">2</span> &#125;))</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(array1.filter(<span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123; <span class="keyword">return</span> item === <span class="number">2</span> &#125;).length &gt; <span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>所以在 ES7 可以简单的语法就能判断数组中是否包含某元素。</p>
<h2 id="02、Math-pow"><a href="#02、Math-pow" class="headerlink" title="02、Math.pow"></a>02、Math.pow</h2><blockquote>
<p>Math.pow() 函数返回基数（base）的指数（exponent）次幂，即 baseexponent</p>
</blockquote>
<p>我们一直都是这样用的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">3</span>)) <span class="comment">// 8（2的三次方）</span></span><br></pre></td></tr></table></figure>

<p>在 ES7 可以这样写了：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span> ** <span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<h1 id="三、ES8-2017"><a href="#三、ES8-2017" class="headerlink" title="三、ES8(2017)"></a>三、ES8(2017)</h1><h2 id="01、Async-Await"><a href="#01、Async-Await" class="headerlink" title="01、Async/Await"></a>01、Async/Await</h2><p>async 和 await 是 Promise 的拓展，如果对 Promise 还不了解的话，请移步 <a href="">Promise</a> 章节进行学习。</p>
<p>我们知道 JavaScript 是单线程的，使用 Promise 之后可以让我们书写异步操作更加简单，而 async 是让我们写起 Promise 像同步操作。看下示例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">firstAsync</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">27</span></span><br><span class="line">&#125;</span><br><span class="line">firstAsync().then(<span class="built_in">console</span>.log) <span class="comment">// 27</span></span><br></pre></td></tr></table></figure>

<p>这块代码成功的输出了 27，仔细观察发现 <code>firstAsync()</code> 的返回值竟然有 then 方法，在 JavaScript 世界里只有原生的 Promise 对象拥有 then 方法，来验证下我们的猜测？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(firstAsync() <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>所以，所以，所以想获得一个 Promise 对象，可以不再 <code>new Promise</code> 了。</p>
<blockquote>
<p>[!TIP]<br>async 函数显式返回的不是 Promise 的话，会自动包装成 Promise 对象</p>
</blockquote>
<p>也就是说上面的代码等同于：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">firstAsync</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(<span class="number">27</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>async 的作用我们清楚了，await呢？话不多说：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">firstAsync</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> resolve(<span class="string">&quot;Now it&#x27;s done!&quot;</span>), <span class="number">1000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// wait until the promise returns us a value</span></span><br><span class="line">  <span class="keyword">let</span> result = <span class="keyword">await</span> promise</span><br><span class="line"></span><br><span class="line">  <span class="comment">// &quot;Now it&#x27;s done!&quot;</span></span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">firstAsync().then(<span class="built_in">console</span>.log)</span><br></pre></td></tr></table></figure>

<p>这段代码使用了 await，从这个字面的意思看就是“等待”，它等什么呢？很简单，它等 Promise 返回结果。上面代码的意思是 async 开启了一个 Promise 对象，这个函数内部嵌套了一个 Promise 操作，这个操作需要等 1 秒才返回 “Now it’s done!” 这个结果。也就是说 await 在拿到这个结果之前不会继续执行，一直等到结果才往后继续执行，也就是 async function 声明的 Promise 才会响应（console.log才执行）。</p>
<p><strong>思考</strong></p>
<ol>
<li>聪明的同学一定会反问：await 后面必须是 Promise 对象吗，如果不是会怎样？</li>
<li>await 可以脱离 async 单独使用吗？</li>
</ol>
<p><strong>答案</strong></p>
<p><strong>1. await 后面一定是 Promise 对象，如果不是会自动包装成 Promise 对象</strong></p>
<ul>
<li><p><strong>常数</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">firstAsync</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="keyword">await</span> <span class="number">27</span></span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">firstAsync().then(<span class="built_in">console</span>.log) <span class="comment">// 27</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>对象</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">firstAsync</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="keyword">await</span> &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">firstAsync().then(<span class="built_in">console</span>.log) <span class="comment">// &#123; a: 1 &#125;</span></span><br></pre></td></tr></table></figure>

<p>其他类型请大家自行验证，一句话总结：非 Promise 对象将用 Promise.resolve 来包装，而 await 后边的值作为 resolve 的参数。</p>
</li>
</ul>
<p><strong>2. await 不可以脱离 async 单独使用</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">firstAsync</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> promise = <span class="built_in">Promise</span>.resolve(<span class="number">10</span>);</span><br><span class="line">  <span class="keyword">let</span> result = <span class="keyword">await</span> promise; <span class="comment">// Syntax error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>[!DANGER]<br>await 只能在 async 标记的函数内部使用，单独使用会触发 Syntax error。</p>
</blockquote>
<h2 id="02、Object-values-Object-keys"><a href="#02、Object-values-Object-keys" class="headerlink" title="02、Object.values()/Object.keys()"></a>02、Object.values()/Object.keys()</h2><blockquote>
<p>Object.values() 返回一个数组，其元素是在对象上找到的可枚举属性值。属性的顺序与通过手动循环对象的属性值所给出的顺序相同(for…in，但是for…in还会遍历原型上的属性值)。</p>
</blockquote>
<p>比如我们用对象存储了全班的成绩表，key 是姓名，value 是分数，如果我们想获取所有的学生名单或者全班的分数，之前只能通过用 for…in 遍历并存储到数组中，现在可以直接获取到：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> grade = &#123;</span><br><span class="line">  <span class="string">&#x27;lilei&#x27;</span>: <span class="number">98</span>,</span><br><span class="line">  <span class="string">&#x27;hanmei&#x27;</span>: <span class="number">87</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.values(grade)) <span class="comment">// [98, 87]</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>[!TIP]<br>Object.values 是在对象上找到可枚举的属性的值，所以只要这个对象是可枚举的就可以，不只是 {} 这种形式。</p>
</blockquote>
<p><strong>练习</strong></p>
<ol>
<li>试试获取 Set 或者 Map 对象的属性值。</li>
<li>Object.values 和 Iterator 有什么关联呢？</li>
</ol>
<h2 id="03、Object-entries"><a href="#03、Object-entries" class="headerlink" title="03、Object.entries"></a>03、Object.entries</h2><blockquote>
<p>Object.entries()方法返回一个给定对象自身可枚举属性的键值对数组，其排列与使用 for…in 循环遍历该对象时返回的顺序一致。（区别在于 for-in 循环也枚举原型链中的属性）</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> grade = &#123;</span><br><span class="line">  <span class="string">&#x27;lilei&#x27;</span>: <span class="number">98</span>,</span><br><span class="line">  <span class="string">&#x27;hanmei&#x27;</span>: <span class="number">87</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> grade) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key, value) <span class="comment">// Uncaught TypeError: grade is not iterable</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们知道 Object 是不可直接遍历的，上述代码足以说明直接遍历触发了错误。如果使用 Object.entries() 则可以完成遍历任务。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> grade = &#123;</span><br><span class="line">  <span class="string">&#x27;lilei&#x27;</span>: <span class="number">98</span>,</span><br><span class="line">  <span class="string">&#x27;hanmei&#x27;</span>: <span class="number">87</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [k, v] <span class="keyword">of</span> <span class="built_in">Object</span>.entries(grade)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(k, v)</span><br><span class="line">  <span class="comment">// lilei 98</span></span><br><span class="line">  <span class="comment">// hanmei 87</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码确实成功的遍历了出来，但是上边说过 Object.entries 返回的是数组，这里面还用了数组的解构赋值，很多同学不明白是怎么结合的，其实很简单，看下 Object.entries 的返回值就好了：</p>
<img src="/2019/07/17/ES6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/wj005.png" class="">

<p>结合这个图还有解构赋值的原理，就明白上述的代码是怎么工作的了。</p>
<p><strong>思考</strong></p>
<ol>
<li>Object.keys()、Object.values()、Object.entries()三者有什么关联？</li>
</ol>
<h2 id="04、String-padding"><a href="#04、String-padding" class="headerlink" title="04、String padding"></a>04、String padding</h2><p>在 ES8 中 String 新增了两个实例函数 <code>String.prototype.padStart</code> 和 <code>String.prototype.padEnd</code>，允许将空字符串或其他字符串添加到原始字符串的开头或结尾。这两个方法有什么用武之地呢？回忆下我们处理日期的时候经常要格式化，比如 01、02、10等。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; <span class="number">31</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (i &lt; <span class="number">10</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`0<span class="subst">$&#123;i&#125;</span>`</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之前输出1号到31号，需要手动判断是否小于10号，小于的在前面增加 0。现在可以这样做了：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; <span class="number">31</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i.toString().padStart(<span class="number">2</span>, <span class="string">&#x27;0&#x27;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们来看下 padStart 的语法就明白是怎么个意思了。</p>
<blockquote>
<p>str.padStart(targetLength [, padString])</p>
</blockquote>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">含义</th>
<th align="left">必选</th>
</tr>
</thead>
<tbody><tr>
<td align="left">targetLength</td>
<td align="left">目标字符要保持的长度值</td>
<td align="left">Y</td>
</tr>
<tr>
<td align="left">padString</td>
<td align="left">如果目标字符的长度不够需要的补白字符，默认为空</td>
<td align="left">N</td>
</tr>
</tbody></table>
<p>String.prototype.padStart 和 String.prototype.padEnd 用法是相同的，只是一个在开头补白一个在结尾。我们讲解个 padEnd 的小示例：输出一个格式化的表格。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = &#123;</span><br><span class="line">  Portland: <span class="string">&#x27;78/50&#x27;</span>,</span><br><span class="line">  Dublin: <span class="string">&#x27;88/52&#x27;</span>,</span><br><span class="line">  Lima: <span class="string">&#x27;58/40&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.entries(data).map(<span class="function">(<span class="params">[city, temp]</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`City: <span class="subst">$&#123;city.padEnd(<span class="number">16</span>)&#125;</span> Weather: <span class="subst">$&#123;temp&#125;</span>`</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>利用这个代码输出的内容就是美观的，效果如下：</p>
<img src="/2019/07/17/ES6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/wj006.png" class="">

<p>如果注释下 padEnd 看下效果对比下？</p>
<h2 id="05、Object-getOwnPropertyDescriptors"><a href="#05、Object-getOwnPropertyDescriptors" class="headerlink" title="05、Object.getOwnPropertyDescriptors()"></a>05、Object.getOwnPropertyDescriptors()</h2><p>想理解 Object.getOwnPropertyDescriptors 这个方法之前，首先要弄懂什么是描述符(descriptor)？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = &#123;</span><br><span class="line">  Portland: <span class="string">&#x27;78/50&#x27;</span>,</span><br><span class="line">  Dublin: <span class="string">&#x27;88/52&#x27;</span>,</span><br><span class="line">  Lima: <span class="string">&#x27;58/40&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还是上述那个对象，这里有 key 和 value，上边的代码把所有的 key、value 遍历出来，如果我们不想让 Lima 这个属性和值被枚举怎么办？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty(data, <span class="string">&#x27;Lima&#x27;</span>, &#123;</span><br><span class="line">  enumerable: <span class="literal">false</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.entries(data).map(<span class="function">(<span class="params">[city, temp]</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`City: <span class="subst">$&#123;city.padEnd(<span class="number">16</span>)&#125;</span> Weather: <span class="subst">$&#123;temp&#125;</span>`</span>)</span><br><span class="line">  <span class="comment">// City: Portland         Weather: 78/50</span></span><br><span class="line">  <span class="comment">// City: Dublin           Weather: 88/52</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>很成功，Lima 没有被遍历出来，那么 defineProperty 的第三个参数就是描述符(descriptor)。这个描述符包括几个属性：</p>
<ul>
<li>value [属性的值]</li>
<li>writable [属性的值是否可被改变]</li>
<li>enumerable [属性的值是否可被枚举]</li>
<li>configurable [描述符本身是否可被修改，属性是否可被删除]</li>
</ul>
<p>如果想查看更多细节，访问 Object.defineProperty：</p>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty</a>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(data, <span class="string">&#x27;Lima&#x27;</span>))</span><br><span class="line"><span class="comment">// &#123;value: &quot;58/40&quot;, writable: true, enumerable: false, configurable: true&#125;</span></span><br></pre></td></tr></table></figure>

<p>这个是获取对象指定属性的描述符，如果想获取对象的所有属性的描述符：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptors(data))</span><br></pre></td></tr></table></figure>

<p>返回数据：</p>
<img src="/2019/07/17/ES6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/wj007.png" class="">

<h3 id="refernce"><a href="#refernce" class="headerlink" title="refernce"></a>refernce</h3><ol start="2">
<li>Async/await：<a target="_blank" rel="noopener" href="https://javascript.info/async-await">https://javascript.info/async-await</a></li>
<li>SharedArrayBuffer：<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer)</a></li>
<li>Atomics：<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Atomics">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Atomics</a></li>
</ol>
<h1 id="四、ES9-2018"><a href="#四、ES9-2018" class="headerlink" title="四、ES9(2018)"></a>四、ES9(2018)</h1><h2 id="01、for-await-of"><a href="#01、for-await-of" class="headerlink" title="01、for await of"></a>01、for await of</h2><p>我们知道 for…of 是同步运行的，有时候一些任务集合是异步的，那这种遍历怎么办呢？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Gen</span> (<span class="params">time</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      resolve(time)</span><br><span class="line">    &#125;, time)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> arr = [Gen(<span class="number">2000</span>), Gen(<span class="number">100</span>), Gen(<span class="number">3000</span>)]</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> arr) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">Date</span>.now(), item.then(<span class="built_in">console</span>.log))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test()</span><br><span class="line"><span class="comment">// 1560090138232 Promise &#123;&lt;pending&gt;&#125;</span></span><br><span class="line"><span class="comment">// 1560090138234 Promise &#123;&lt;pending&gt;&#125;</span></span><br><span class="line"><span class="comment">// 1560090138235 Promise &#123;&lt;pending&gt;&#125;</span></span><br><span class="line"><span class="comment">// 100</span></span><br><span class="line"><span class="comment">// 2000</span></span><br><span class="line"><span class="comment">// 3000</span></span><br></pre></td></tr></table></figure>

<p>这里写了几个小任务，分别是 2000ms 、100ms、3000ms后任务结束。在上述遍历的过程中可以看到三个任务是同步启动的，然后输出上也不是按任务的执行顺序输出的，这显然不太符合我们的要求。</p>
<p>聪明的同学一定能想起来 await 的作用，它可以中断程序的执行直到这个 Promise 对象的状态发生改变，我们修改上面的代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Gen</span> (<span class="params">time</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      resolve(time)</span><br><span class="line">    &#125;, time)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> arr = [Gen(<span class="number">2000</span>), Gen(<span class="number">100</span>), Gen(<span class="number">3000</span>)]</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> arr) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">Date</span>.now(), <span class="keyword">await</span> item.then(<span class="built_in">console</span>.log))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test()</span><br><span class="line"><span class="comment">// 2000</span></span><br><span class="line"><span class="comment">// 1560091834772 undefined</span></span><br><span class="line"><span class="comment">// 100</span></span><br><span class="line"><span class="comment">// 1560091836774 undefined</span></span><br><span class="line"><span class="comment">// 3000</span></span><br><span class="line"><span class="comment">// 1560091836775 undefined</span></span><br></pre></td></tr></table></figure>

<p>从返回值看确实是按照任务的先后顺序进行的，其中原理也有说明是利用了 await 中断程序的功能。不过，在 ES9 中也可以用 for…await…of 的语法来操作：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Gen</span> (<span class="params">time</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      resolve(time)</span><br><span class="line">    &#125;, time)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> arr = [Gen(<span class="number">2000</span>), Gen(<span class="number">100</span>), Gen(<span class="number">3000</span>)]</span><br><span class="line">  <span class="keyword">for</span> <span class="keyword">await</span> (<span class="keyword">let</span> item <span class="keyword">of</span> arr) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">Date</span>.now(), item)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test()</span><br><span class="line"><span class="comment">// 1560092345730 2000</span></span><br><span class="line"><span class="comment">// 1560092345730 100</span></span><br><span class="line"><span class="comment">// 1560092346336 3000</span></span><br></pre></td></tr></table></figure>

<p>从这个结果来看和第二种写法效果差不多，但是工作原理确完全不同，重点观察下输出的时间（Chrome Console）, 第二种写法是代码块中有 await 导致等待 Promise 的状态而不再继续执行；第三种写法是整个代码块都不执行，等待 arr 当前的值（Promise状态）发生变化之后，才执行代码块的内容。</p>
<p>回想我们之前给数据结构自定义遍历器是同步的，如果想定义适合 for…await…of 的异步遍历器该怎么做呢？答案是 <code>Symbol.asyncIterator</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  count: <span class="number">0</span>,</span><br><span class="line">  Gen (time) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        resolve(&#123; <span class="attr">done</span>: <span class="literal">false</span>, <span class="attr">value</span>: time &#125;)</span><br><span class="line">      &#125;, time)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  [<span class="built_in">Symbol</span>.asyncIterator] () &#123;</span><br><span class="line">    <span class="keyword">let</span> self = <span class="built_in">this</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      next () &#123;</span><br><span class="line">        self.count++</span><br><span class="line">        <span class="keyword">if</span> (self.count &lt; <span class="number">4</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> self.Gen(<span class="built_in">Math</span>.random() * <span class="number">1000</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(&#123;</span><br><span class="line">            done: <span class="literal">true</span>,</span><br><span class="line">            value: <span class="string">&#x27;&#x27;</span></span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> <span class="keyword">await</span> (<span class="keyword">let</span> item <span class="keyword">of</span> obj) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">Date</span>.now(), item)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1560093560200 649.3946561938179</span></span><br><span class="line"><span class="comment">// 1560093560828 624.6310222512955</span></span><br><span class="line"><span class="comment">// 1560093561733 901.9497480464518</span></span><br></pre></td></tr></table></figure>

<h2 id="02、Promise-prototype-finally"><a href="#02、Promise-prototype-finally" class="headerlink" title="02、Promise.prototype.finally()"></a>02、Promise.prototype.finally()</h2><p><code>Promise.prototype.finally()</code>方法返回一个Promise，在promise执行结束时，无论结果是fulfilled或者是rejected，在执行then()和catch()后，都会执行finally指定的回调函数。这为指定执行完promise后，无论结果是fulfilled还是rejected都需要执行的代码提供了一种方式，避免同样的语句需要在then()和catch()中各写一次的情况。</p>
<p><strong>基本语法</strong></p>
<blockquote>
<p>p.finally(onFinally);</p>
</blockquote>
<blockquote>
<p>p.finally(function() {<br>// 返回状态为(resolved 或 rejected)<br>});参数</p>
</blockquote>
<p><strong>示例</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> connection;</span><br><span class="line">db.open()</span><br><span class="line">.then(<span class="function"><span class="params">conn</span> =&gt;</span> &#123;</span><br><span class="line">    connection = conn;</span><br><span class="line">    <span class="keyword">return</span> connection.select(&#123; <span class="attr">name</span>: <span class="string">&#x27;Jane&#x27;</span> &#125;);</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// Process result</span></span><br><span class="line">    <span class="comment">// Use `connection` to make more queries</span></span><br><span class="line">&#125;)</span><br><span class="line">···</span><br><span class="line">.catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// handle errors</span></span><br><span class="line">&#125;)</span><br><span class="line">.finally(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    connection.close();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="03、Object-Rest-amp-Spread"><a href="#03、Object-Rest-amp-Spread" class="headerlink" title="03、Object Rest&amp;Spread"></a>03、Object Rest&amp;Spread</h2><p>前面在讲 function 的 Rest &amp; Spread 方法，忘却的同学可以去复习下。在 ES9 新增 Object 的 Rest &amp; Spread 方法，直接看下示例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> input = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> output = &#123;</span><br><span class="line">  ...input,</span><br><span class="line">  c: <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(output) <span class="comment">// &#123;a: 1, b: 2, c: 3&#125;</span></span><br></pre></td></tr></table></figure>

<p>这块代码展示了 spread 语法，可以把 input 对象的数据都拓展到 output 对象，这个功能很实用。</p>
<p>我们再来看下 Object rest 的示例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> input = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: <span class="number">2</span>,</span><br><span class="line">  c: <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; a, ...rest &#125; = input</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a, rest) <span class="comment">// 1 &#123;b: 2, c: 3&#125;</span></span><br></pre></td></tr></table></figure>

<p>当对象 key-value 不确定的时候，把必选的 key 赋值给变量，用一个变量收敛其他可选的 key 数据，这在之前是做不到的。</p>
<h2 id="04、RegExp-Updates"><a href="#04、RegExp-Updates" class="headerlink" title="04、RegExp Updates"></a>04、RegExp Updates</h2><h3 id="1-s-dotAll-flag"><a href="#1-s-dotAll-flag" class="headerlink" title="1 s (dotAll) flag"></a>1 s (dotAll) flag</h3><p>正则表达式中，点（.）是一个特殊字符，代表任意的单个字符，但是有两个例外。一个是四个字节的 UTF-16 字符，这个可以用u修饰符解决；另一个是行终止符（line terminator character）。</p>
<ul>
<li>U+000A 换行符（\n）</li>
<li>U+000D 回车符（\r）</li>
<li>U+2028 行分隔符（line separator）</li>
<li>U+2029 段分隔符（paragraph separator）</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/foo.bar/</span>.test(<span class="string">&#x27;foo\nbar&#x27;</span>)) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/foo.bar/</span>s.test(<span class="string">&#x27;foo\nbar&#x27;</span>)) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>在 ES5 中我们都是这么解决的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/foo[^]bar/</span>.test(<span class="string">&#x27;foo\nbar&#x27;</span>)) <span class="comment">// true</span></span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/foo[\s\S]bar/</span>.test(<span class="string">&#x27;foo\nbar&#x27;</span>)) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>那如何判断当前正则是否使用了 dotAll 模式呢？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> re = <span class="regexp">/foo.bar/</span>s <span class="comment">// Or, `const re = new RegExp(&#x27;foo.bar&#x27;, &#x27;s&#x27;);`.</span></span><br><span class="line"><span class="built_in">console</span>.log(re.test(<span class="string">&#x27;foo\nbar&#x27;</span>)) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(re.dotAll) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(re.flags) <span class="comment">// &#x27;s&#x27;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>[!TIP]<br>记住一句话就可以理解 dotAll 模式：它让 . 名副其实。</p>
</blockquote>
<h3 id="2-named-capture-groups"><a href="#2-named-capture-groups" class="headerlink" title="2 named capture groups"></a>2 named capture groups</h3><p>我们在写正则表达式的时候，可以把一部分用()包裹起来，被包裹起来的这部分称作“分组捕获”。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;2019-06-07&#x27;</span>.match(<span class="regexp">/(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/</span>))</span><br><span class="line"><span class="comment">// [&quot;2019-06-07&quot;, &quot;2019&quot;, &quot;06&quot;, &quot;07&quot;, index: 0, input: &quot;2019-06-07&quot;, groups: undefined]</span></span><br></pre></td></tr></table></figure>

<p>这个正则匹配很简单，按照 match 的语法，没有使用 g 标识符，所以返回值第一个数值是正则表达式的完整匹配，接下来的第二个值到第四个值是分组匹配（2019,06,07）。</p>
<p>此外 match 返回值还有几个属性，分别是 index、input、groups。</p>
<blockquote>
<p>[!NOTE]</p>
<ol>
<li>index [匹配的结果的开始位置]</li>
<li>input [搜索的字符串]</li>
<li>groups [一个捕获组数组 或 undefined（如果没有定义命名捕获组）]</li>
</ol>
</blockquote>
<p>我们通过数组来获取这些捕获：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> t = <span class="string">&#x27;2019-06-07&#x27;</span>.match(<span class="regexp">/(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/</span>)</span><br><span class="line"><span class="built_in">console</span>.log(t[<span class="number">1</span>]) <span class="comment">// 2019</span></span><br><span class="line"><span class="built_in">console</span>.log(t[<span class="number">2</span>]) <span class="comment">// 06</span></span><br><span class="line"><span class="built_in">console</span>.log(t[<span class="number">3</span>]) <span class="comment">// 07</span></span><br></pre></td></tr></table></figure>

<p>上文中重点看下 groups 的解释，这里提到了命名捕获组的概念，如果没有定义 groups 就是 undefined。很明显，我们上述的返回值就是 undefined 间接说明没有定义命名捕获分组。那什么是命名捕获分组呢？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;2019-06-07&#x27;</span>.match(<span class="regexp">/(?&lt;year&gt;\d&#123;4&#125;)-(?&lt;month&gt;\d&#123;2&#125;)-(?&lt;day&gt;\d&#123;2&#125;)/</span>))</span><br><span class="line"><span class="comment">// [&quot;2019-06-07&quot;, &quot;2019&quot;, &quot;06&quot;, &quot;07&quot;, index: 0, input: &quot;2019-06-07&quot;, groups: &#123;…&#125;]</span></span><br></pre></td></tr></table></figure>

<p>这段代码的返回值 groups 已经是 Object 了，具体的值是：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groups: &#123;<span class="attr">year</span>: <span class="string">&quot;2019&quot;</span>, <span class="attr">month</span>: <span class="string">&quot;06&quot;</span>, <span class="attr">day</span>: <span class="string">&quot;07&quot;</span>&#125;</span><br></pre></td></tr></table></figure>

<p>这个 Object 的 key 就是正则表达式中定义的，也就是把捕获分组进行了命名。想获取这些捕获可以这样做：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> t = <span class="string">&#x27;2019-06-07&#x27;</span>.match(<span class="regexp">/(?&lt;year&gt;\d&#123;4&#125;)-(?&lt;month&gt;\d&#123;2&#125;)-(?&lt;day&gt;\d&#123;2&#125;)/</span>)</span><br><span class="line"><span class="comment">// [&quot;2019-06-07&quot;, &quot;2019&quot;, &quot;06&quot;, &quot;07&quot;, index: 0, input: &quot;2019-06-07&quot;, groups: &#123;…&#125;]</span></span><br><span class="line"><span class="built_in">console</span>.log(t.groups.year) <span class="comment">// 2019</span></span><br><span class="line"><span class="built_in">console</span>.log(t.groups.month) <span class="comment">// 06</span></span><br><span class="line"><span class="built_in">console</span>.log(t.groups.day) <span class="comment">// 07</span></span><br></pre></td></tr></table></figure>

<h3 id="3-Lookbehind-Assertions"><a href="#3-Lookbehind-Assertions" class="headerlink" title="3 Lookbehind Assertions"></a>3 Lookbehind Assertions</h3><p>在 ES9 之前 JavaScript 正则只支持先行断言，不支持后行断言。简单复习下先行断言的知识：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> test = <span class="string">&#x27;hello world&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(test.match(<span class="regexp">/hello(?=\sworld)/</span>))</span><br><span class="line"><span class="comment">// [&quot;hello&quot;, index: 0, input: &quot;hello world&quot;, groups: undefined]</span></span><br></pre></td></tr></table></figure>

<p>这段代码要匹配后面是 world 的 hello，但是反过来就不成：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> test = <span class="string">&#x27;world hello&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(test.match(<span class="regexp">/hello(?=\sworld)/</span>))</span><br><span class="line"><span class="comment">// null</span></span><br></pre></td></tr></table></figure>

<p>比如我们想判断前面是 world 的 hello，这个代码是实现不了的。在 ES9 就支持这个后行断言了：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> test = <span class="string">&#x27;world hello&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(test.match(<span class="regexp">/(?&lt;=world\s)hello/</span>))</span><br><span class="line"><span class="comment">// [&quot;hello&quot;, index: 6, input: &quot;world hello&quot;, groups: undefined]</span></span><br></pre></td></tr></table></figure>

<p><code>(?&lt;…)</code>是后行断言的符号，<code>(?..)</code>是先行断言的符号，然后结合 <code>=(等于)</code>、<code>!(不等)</code>、<code>\1(捕获匹配)</code>。</p>
<h3 id="4-Unicode-Property-Escapes"><a href="#4-Unicode-Property-Escapes" class="headerlink" title="4 Unicode Property Escapes"></a>4 Unicode Property Escapes</h3><p>了解这个新的知识点，需要对文本的编码非常熟悉，不然意识不到这个功能的意义。对于文本的编码需要了解两个概念：字符编码和文件编码。字符编码包括 ASCII 和 Unicode，文件编码包括 UTF-8、GBK等。字符编码和文件编码的关系可以用一句话来概括：文件编码和字符编码没有关系，也就是说即使指定了文件编码，字符变也可以灵活选择而不受任何限制。</p>
<p>现在主要讲述下 Unicode 的知识点，方便快速了解 ES9 这个新特性。根据 Unicode 规范，每一个 Unicode 字符除了有唯一的码点，还具有其它属性，它们是：Unicode Property、Unicode Block、Unicode Script。</p>
<ul>
<li><p><strong>Unicode Property</strong></p>
<p>它按照字符的功能对字符进行分类，一个字符只能属于一个 Unicode Property。也就是说 Property 并不关心字符所属的语言，只关心字符的功能。</p>
<p>可以将Unicode property 理解为了下字符组，将小写 p 改成大写，就是该字符组的排除型字符组。想想看 <code>\d</code> 匹配 0-9 这个字符组，而<code>\D</code> 匹配 0-9 以外的字符组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> input = <span class="string">&#x27;abcdAeCd中国&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(input.match(<span class="regexp">/\p&#123;L&#125;/ug</span>))</span><br><span class="line"><span class="comment">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;A&quot;, &quot;e&quot;, &quot;C&quot;, &quot;d&quot;, &quot;中&quot;, &quot;国&quot;]</span></span><br></pre></td></tr></table></figure>

<p>这段代码的含义是在输入中匹配所有的字符（不限语言），这里使用的是 Unicode Property：{L}，这个属性的含义是任何语言的任何字母。它有点等同于</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> input = <span class="string">&#x27;abcdAeCd中国&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(input.match(<span class="regexp">/./</span>sg))</span><br></pre></td></tr></table></figure>

<ul>
<li><p>{Ll} [任何具有大写字母的小写字母]</p>
</li>
<li><p>{N} [任何语言下的数字]</p>
<p>更多的 Unicode Property 请查阅 <strong><a target="_blank" rel="noopener" href="https://www.regular-expressions.info/unicode.html">官网：https://www.regular-expressions.info/unicode.html</a></strong></p>
</li>
</ul>
</li>
<li><p><strong>Unicode Script</strong></p>
<p>按照字符所属的书写系统来划分字符，它一般对应某种语言。比如 \p{Script=Greek} 表示希腊语，\p{Script=Han} 表示汉语。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> input = <span class="string">`I&#x27;m chinese!我是中国人`</span></span><br><span class="line"><span class="built_in">console</span>.log(input.match(<span class="regexp">/\p&#123;Script=Han&#125;+/u</span>))</span><br><span class="line"><span class="comment">// [&quot;我是中国人&quot;, index: 12, input: &quot;I&#x27;m chinese!我是中国人&quot;, groups: undefined]</span></span><br></pre></td></tr></table></figure>

<p>如果不适用这个新功能点，在 ES9 之前大概只能这样做：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> input = <span class="string">`I&#x27;m chinese!我是中国人`</span></span><br><span class="line"><span class="built_in">console</span>.log(input.match(<span class="regexp">/[\u4e00-\u9fa5]+/</span>))</span><br><span class="line"><span class="comment">// [&quot;我是中国人&quot;, index: 12, input: &quot;I&#x27;m chinese!我是中国人&quot;, groups: undefined]</span></span><br></pre></td></tr></table></figure>

<p>虽然不同的写法看上去结果一样，然而时光飞逝，Unicode 在2017年6月发布了10.0.0版本。在这20年间，Unicode 添加了许多汉字。比如 Unicode 8.0 添加的 109 号化学元素「鿏（⿰⻐麦）」，其码点是 9FCF，不在这个正则表达式范围中。而如果我们期望程序里的<code>/[\u4e00-\u9fa5]/</code>可以与时俱进匹配最新的 Unicode 标准，显然是不现实的事情。现在只需要在 <a target="_blank" rel="noopener" href="https://www.regular-expressions.info/unicode.html">Unicode Scripts</a> 找到对应的名称即可，而不需要自己去计算所有对应语言字符的的 Unicode 范围。</p>
</li>
<li><p><strong>Unicode Block</strong></p>
<p>将 Unicode 字符按照编码区间进行划分，所以每一个字符都只属于一个 Unicode Block，举例说明：</p>
<ul>
<li>\p{InBasic_Latin}: U+0000–U+007F</li>
<li>\p{InLatin-1_Supplement}: U+0080–U+00FF</li>
<li>\p{InLatin_Extended-A}: U+0100–U+017F</li>
<li>\p{InLatin_Extended-B}: U+0180–U+024F</li>
</ul>
<blockquote>
<p>[!WARNING]<br>目前 JavaScript RegExp 还不支持 Unicode Block</p>
</blockquote>
</li>
</ul>
<p><strong>思考</strong></p>
<ol>
<li>利用 Object spread 的语法实现一个对象拷贝的方法。</li>
<li>Object rest 在实际业务中有什么应用呢？</li>
<li>如果想后向引用分组捕获的内容该怎么做呢？</li>
<li>如果想后向引用命名分分组捕获内容又该怎么做呢？</li>
</ol>
<p><strong>练习</strong></p>
<ol>
<li>请把 ‘$foo %foo foo’ 字符串中前面是 $ 符号的 foo 替换成 bar。</li>
<li>请提取 ‘$1 is worth about ¥123’ 字符中的美元数是多少。</li>
</ol>
<h3 id="扩展阅读-15"><a href="#扩展阅读-15" class="headerlink" title="@ 扩展阅读"></a>@ 扩展阅读</h3><ol>
<li>Asynchronous iteration：<a target="_blank" rel="noopener" href="https://exploringjs.com/es2018-es2019/ch_asynchronous-iteration.html#for-await-of-and-rejections](https://exploringjs.com/es2018-es2019/ch_asynchronous-iteration.html#for-await-of-and-rejections)">https://exploringjs.com/es2018-es2019/ch_asynchronous-iteration.html#for-await-of-and-rejections](https://exploringjs.com/es2018-es2019/ch_asynchronous-iteration.html#for-await-of-and-rejections)</a></li>
<li>Promise.prototype.finally()：<a target="_blank" rel="noopener" href="http://2ality.com/2017/07/promise-prototype-finally.html">http://2ality.com/2017/07/promise-prototype-finally.html</a></li>
<li>JavaScript 正则表达式匹配汉字：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/33335629">https://zhuanlan.zhihu.com/p/33335629</a></li>
</ol>
<p><strong>reference</strong></p>
<ol>
<li>当 async/await 遇上 forEach：<a target="_blank" rel="noopener" href="http://objcer.com/2017/10/12/async-await-with-forEach/">http://objcer.com/2017/10/12/async-await-with-forEach/</a></li>
<li>asynchronous iteration：<a target="_blank" rel="noopener" href="http://2ality.com/2016/10/asynchronous-iteration.html">http://2ality.com/2016/10/asynchronous-iteration.html</a></li>
<li>JavaScript loops - how to handle async/await：<a target="_blank" rel="noopener" href="https://lavrton.com/javascript-loops-how-to-handle-async-await-6252dd3c795/">https://lavrton.com/javascript-loops-how-to-handle-async-await-6252dd3c795/</a></li>
<li>Asynchronous iteration标准：<a target="_blank" rel="noopener" href="https://exploringjs.com/es2018-es2019/ch_asynchronous-iteration.html#for-await-of-and-rejections">https://exploringjs.com/es2018-es2019/ch_asynchronous-iteration.html#for-await-of-and-rejections</a></li>
<li>Promise.prototype.finally()：<a target="_blank" rel="noopener" href="http://2ality.com/2017/07/promise-prototype-finally.html">http://2ality.com/2017/07/promise-prototype-finally.html</a></li>
<li>UnicodeMatchProperty：<a target="_blank" rel="noopener" href="https://tc39.es/proposal-regexp-unicode-property-escapes/#sec-runtime-semantics-unicodematchproperty-p">https://tc39.es/proposal-regexp-unicode-property-escapes/#sec-runtime-semantics-unicodematchproperty-p</a></li>
<li>即将到来的正则表达式新特性：<a target="_blank" rel="noopener" href="https://juejin.im/post/59683f98f265da6c4f34eec6">https://juejin.im/post/59683f98f265da6c4f34eec6</a></li>
</ol>
<h1 id="五、ES10-2019"><a href="#五、ES10-2019" class="headerlink" title="五、ES10(2019)"></a>五、ES10(2019)</h1><h2 id="01、JSON-stringify"><a href="#01、JSON-stringify" class="headerlink" title="01、JSON.stringify()"></a>01、JSON.stringify()</h2><p>JSON.stringify 在 ES10 修复了对于一些超出范围的 Unicode 展示错误的问题。因为 JSON 都是被编码成 UTF-8，所以遇到 0xD800–0xDFFF 之内的字符会因为无法编码成 UTF-8 进而导致显示错误。在 ES10 它会用转义字符的方式来处理这部分字符而非编码的方式，这样就会正常显示了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.stringify(<span class="string">&#x27;\u&#123;D800&#125;&#x27;</span>) === <span class="string">&#x27;&quot;\\ud800&quot;&#x27;</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h2 id="02、Array-prototype-flat"><a href="#02、Array-prototype-flat" class="headerlink" title="02、Array.prototype.flat()"></a>02、Array.prototype.flat()</h2><p>flat() 方法会按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回。</p>
<p><strong>语法</strong></p>
<blockquote>
<p>const newArray = arr.flat(depth)</p>
</blockquote>
<p><strong>解释</strong></p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">含义</th>
<th align="left">必选</th>
</tr>
</thead>
<tbody><tr>
<td align="left">depth</td>
<td align="left">指定要提取嵌套数组的结构深度，默认值为 1</td>
<td align="left">N</td>
</tr>
</tbody></table>
<p><strong>示例</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>, [<span class="number">5</span>, <span class="number">6</span>]]]</span><br><span class="line"><span class="built_in">console</span>.log(numbers.flat())</span><br><span class="line"><span class="comment">// [1, 2, 3, 4, [5, 6]]</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>[!TIP]<br>此时 flat 的参数没有设置，取默认值 1，也就是说只扁平化向下一级，遇到 [3, 4, [5, 6]] 这个数组会扁平会处理，不会再继续遍历内部的元素是否还有数组</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>, [<span class="number">5</span>, <span class="number">6</span>]]]</span><br><span class="line"><span class="built_in">console</span>.log(numbers.flat(<span class="number">2</span>))</span><br><span class="line"><span class="comment">// [1, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure>

<p>当 flat 的参数大于等于 2，返回值就是 [1, 2, 3, 4, 5, 6] 了。</p>
<h2 id="03、Array-prototype-flatMap"><a href="#03、Array-prototype-flatMap" class="headerlink" title="03、Array.prototype.flatMap()"></a>03、Array.prototype.flatMap()</h2><p>flatMap() 方法首先使用映射函数映射每个元素，然后将结果压缩成一个新数组。从方法的名字上也可以看出来它包含两部分功能一个是 map，一个是 flat（深度为1）。</p>
<p><strong>语法</strong></p>
<blockquote>
<p>const new_array = arr.flatMap(function callback(currentValue[, index[, array]]) {<br>// 返回新数组的元素<br>}[, thisArg])</p>
</blockquote>
<p><strong>解释</strong></p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">含义</th>
<th align="left">必选</th>
</tr>
</thead>
<tbody><tr>
<td align="left">callback</td>
<td align="left">可以生成一个新数组中的元素的函数，可以传入三个参数：currentValue、index、array</td>
<td align="left">Y</td>
</tr>
<tr>
<td align="left">thisArg</td>
<td align="left">遍历函数 this 的指向</td>
<td align="left">N</td>
</tr>
</tbody></table>
<p><strong>示例</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">numbers.map(<span class="function"><span class="params">x</span> =&gt;</span> [x * <span class="number">2</span>]) <span class="comment">// [[2], [4], [6]]</span></span><br><span class="line">numbers.flatMap(<span class="function"><span class="params">x</span> =&gt;</span> [x * <span class="number">2</span>]) <span class="comment">// [2, 4, 6]</span></span><br></pre></td></tr></table></figure>

<p>这个小示例可以简单对比下 map 和 flatMap 的区别。当然还可以看下 MDN 的示例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;今天天气不错&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;早上好&#x27;</span>]</span><br><span class="line">arr.map(<span class="function"><span class="params">s</span> =&gt;</span> s.split(<span class="string">&#x27;&#x27;</span>))</span><br><span class="line"><span class="comment">// [[&quot;今&quot;, &quot;天&quot;, &quot;天&quot;, &quot;气&quot;, &quot;不&quot;, &quot;错&quot;],[&quot;&quot;],[&quot;早&quot;, &quot;上&quot;, &quot;好&quot;]]</span></span><br><span class="line">arr.flatMap(<span class="function"><span class="params">s</span> =&gt;</span> s.split(<span class="string">&#x27;&#x27;</span>))</span><br><span class="line"><span class="comment">// [&quot;今&quot;, &quot;天&quot;, &quot;天&quot;, &quot;气&quot;, &quot;不&quot;, &quot;错&quot;, &quot;&quot;, &quot;早&quot;, &quot;上&quot;, &quot;好&quot;]</span></span><br></pre></td></tr></table></figure>

<h2 id="04、String-prototype-trimStart"><a href="#04、String-prototype-trimStart" class="headerlink" title="04、String.prototype.trimStart()"></a>04、String.prototype.trimStart()</h2><p>trimStart() 方法从字符串的开头删除空格，trimLeft()是此方法的别名。</p>
<p><strong>语法</strong></p>
<blockquote>
<p>str.trimStart()<br>或<br>str.trimLeft()</p>
</blockquote>
<blockquote>
<p>[!WARNING]<br>虽然 trimLeft 是 trimStart 的别名，但是你会发现 <a target="_blank" rel="noopener" href="http://string.prototype.trimleft.name/">String.prototype.trimLeft.name</a> === ‘trimStart’，一定要记住</p>
</blockquote>
<p><strong>示例</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;   foo  &#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(str.length) <span class="comment">// 8</span></span><br><span class="line">str = str.trimStart()</span><br><span class="line"><span class="built_in">console</span>.log(str.length) <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>

<h2 id="05、String-prototype-trimEnd"><a href="#05、String-prototype-trimEnd" class="headerlink" title="05、String.prototype.trimEnd()"></a>05、String.prototype.trimEnd()</h2><p>trimEnd() 方法从一个字符串的右端移除空白字符，trimRight 是 trimEnd 的别名。</p>
<p><strong>语法</strong></p>
<blockquote>
<p>str.trimEnd()<br>或<br>str.trimRight()</p>
</blockquote>
<blockquote>
<p>[!WARNING]<br>虽然 trimRight 是 trimEnd 的别名，但是你会发现 <a target="_blank" rel="noopener" href="http://string.prototype.trimright.name/">String.prototype.trimRight.name</a> === ‘trimEnd’，一定要记住</p>
</blockquote>
<p><strong>示例</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;   foo  &#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(str.length) <span class="comment">// 8</span></span><br><span class="line">str = str.trimEnd()</span><br><span class="line"><span class="built_in">console</span>.log(str.length) <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>

<h2 id="06、String-prototype-matchAll"><a href="#06、String-prototype-matchAll" class="headerlink" title="06、String.prototype.matchAll()"></a>06、String.prototype.matchAll()</h2><p>matchAll() 方法返回一个包含所有匹配正则表达式及分组捕获结果的迭代器</p>
<p><strong>语法</strong></p>
<blockquote>
<p>str.matchAll(regexp)</p>
</blockquote>
<p><strong>解释</strong></p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">含义</th>
<th align="left">必选</th>
</tr>
</thead>
<tbody><tr>
<td align="left">regexp</td>
<td align="left">正则表达式对象</td>
<td align="left">Y</td>
</tr>
</tbody></table>
<blockquote>
<p>[!WARNING]</p>
<ol>
<li>如果所传参数不是一个正则表达式对象，则会隐式地使用 new RegExp(obj) 将其转换为一个 RegExp</li>
<li>返回值一个迭代器，但是不可重用，结果耗尽需要再次调用方法，获取一个新的迭代器</li>
</ol>
</blockquote>
<p><strong>示例</strong></p>
<p>在了解 matchAll 之前，我们回顾下 ES10 之前一共有多少种正则全部遍历的方法。</p>
<p><strong>1. RegExp.prototype.exec() with /g</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">collectGroup1</span> (<span class="params">regExp, str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> matches = []</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> match = regExp.exec(str)</span><br><span class="line">    <span class="keyword">if</span> (match === <span class="literal">null</span>) <span class="keyword">break</span></span><br><span class="line">    <span class="comment">// Add capture of group 1 to `matches`</span></span><br><span class="line">    matches.push(match[<span class="number">1</span>])</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> matches</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">collectGroup1(<span class="regexp">/&quot;([^&quot;]*)&quot;/g</span>, <span class="string">`&quot;foo&quot; and &quot;bar&quot; and &quot;baz&quot;`</span>)</span><br><span class="line"><span class="comment">// [ &#x27;foo&#x27;, &#x27;bar&#x27;, &#x27;baz&#x27; ]</span></span><br></pre></td></tr></table></figure>

<p>注: 如果没有 flag /g, .exec() 只返回第一个匹配</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> re = <span class="regexp">/[abc]/</span></span><br><span class="line">re.exec(<span class="string">&#x27;abc&#x27;</span>)</span><br><span class="line"><span class="comment">// [&quot;a&quot;, index: 0, input: &quot;abc&quot;, groups: undefined]</span></span><br><span class="line">re.exec(<span class="string">&#x27;abc&#x27;</span>)</span><br><span class="line"><span class="comment">// [&quot;a&quot;, index: 0, input: &quot;abc&quot;, groups: undefined]</span></span><br></pre></td></tr></table></figure>

<p><strong>2. String.prototype.match() with /g</strong></p>
<p>如果用 .match 方法结合 /g 的正则模式，将会把所有的匹配打包成一个数组返回，换句话说所有的捕获被忽略。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;abeabd&#x27;</span>.match(<span class="regexp">/(a)b(?=e)/g</span>)</span><br><span class="line"><span class="comment">// [&quot;ab&quot;]</span></span><br></pre></td></tr></table></figure>

<p>不过如果没有使用 /g 的正则模式，.match 的效果和 RegExp.prototype.exec() 是一致的。</p>
<p><strong>3. String.prototype.replace()</strong></p>
<p>您可以使用一个技巧通过 .replace() 收集捕获，我们使用一个函数来计算替换值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">collectGroup1</span> (<span class="params">regExp, str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> matches = []</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">replacementFunc</span> (<span class="params">all, first</span>) </span>&#123;</span><br><span class="line">    matches.push(first)</span><br><span class="line">  &#125;</span><br><span class="line">  str.replace(regExp, replacementFunc)</span><br><span class="line">  <span class="keyword">return</span> matches</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">collectGroup1(<span class="regexp">/&quot;([^&quot;]*)&quot;/ug</span>, <span class="string">`&quot;foo&quot; and &quot;bar&quot; and &quot;baz&quot;`</span>)</span><br><span class="line"><span class="comment">// [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;]</span></span><br></pre></td></tr></table></figure>

<p>现在看下 .matchAll 方法，可以这样做：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">collectGroup1</span> (<span class="params">regExp, str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> results = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> match <span class="keyword">of</span> str.matchAll(regExp)) &#123;</span><br><span class="line">    results.push(match[<span class="number">1</span>])</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> results</span><br><span class="line">&#125;</span><br><span class="line">collectGroup1(<span class="regexp">/&quot;([^&quot;]*)&quot;/g</span>, <span class="string">`&quot;foo&quot; and &quot;bar&quot; and &quot;baz&quot;`</span>)</span><br><span class="line"><span class="comment">// [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;]</span></span><br></pre></td></tr></table></figure>

<h2 id="07、Object-fromEntries"><a href="#07、Object-fromEntries" class="headerlink" title="07、Object.fromEntries()"></a>07、Object.fromEntries()</h2><p>方法 Object.fromEntries() 把键值对列表转换为一个对象，这个方法是和 Object.entries() 相对的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.fromEntries([[<span class="string">&#x27;foo&#x27;</span>, <span class="number">1</span>], [<span class="string">&#x27;bar&#x27;</span>, <span class="number">2</span>]])</span><br><span class="line"><span class="comment">// &#123;foo: 1, bar: 2&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>示例</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">abc</span>: <span class="number">1</span>, <span class="attr">def</span>: <span class="number">2</span>, <span class="attr">ghij</span>: <span class="number">3</span> &#125;</span><br><span class="line"><span class="keyword">let</span> res = <span class="built_in">Object</span>.fromEntries(</span><br><span class="line">  <span class="built_in">Object</span>.entries(obj)</span><br><span class="line">    .filter(<span class="function">(<span class="params">[ key, val ]</span>) =&gt;</span> key.length === <span class="number">3</span>)</span><br><span class="line">    .map(<span class="function">(<span class="params">[ key, val ]</span>) =&gt;</span> [ key, val * <span class="number">2</span> ])</span><br><span class="line">)</span><br><span class="line"><span class="built_in">console</span>.log(res)</span><br><span class="line"><span class="comment">// res is &#123; &#x27;abc&#x27;: 2, &#x27;def&#x27;: 4 &#125;</span></span><br></pre></td></tr></table></figure>

<p>这个小示例主要用于对 Object 进行转换操作。</p>
<h2 id="08、Symbol-prototype-description"><a href="#08、Symbol-prototype-description" class="headerlink" title="08、Symbol.prototype.description"></a>08、Symbol.prototype.description</h2><p>我们知道，Symbol 的描述只被存储在内部的 [[Description]]，没有直接对外暴露，我们只有调用 Symbol 的 toString() 时才可以读取这个属性：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="built_in">Symbol</span>(<span class="string">&#x27;My name is axuebin&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(name.toString()) <span class="comment">// Symbol(My name is axuebin)</span></span><br><span class="line"><span class="built_in">console</span>.log(name) <span class="comment">// Symbol(My name is axuebin)</span></span><br><span class="line"><span class="built_in">console</span>.log(name === <span class="string">&#x27;Symbol(My name is axuebin)&#x27;</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(name.toString() === <span class="string">&#x27;Symbol(My name is axuebin)&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>现在可以通过 description 方法获取 Symbol 的描述:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="built_in">Symbol</span>(<span class="string">&#x27;My name is axuebin&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(name.description) <span class="comment">// My name is axuebin</span></span><br><span class="line"><span class="built_in">console</span>.log(name.description === <span class="string">&#x27;My name is axuebin&#x27;</span>) <span class="comment">// My name is axuebin</span></span><br></pre></td></tr></table></figure>

<h2 id="09、Function-prototype-toString"><a href="#09、Function-prototype-toString" class="headerlink" title="09、Function.prototype.toString()"></a>09、Function.prototype.toString()</h2><p>toString() 方法返回一个表示当前函数源代码的字符串</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hello</span> (<span class="params">msg</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(hello.toString())</span><br><span class="line"><span class="comment">// function hello (msg) &#123;</span></span><br><span class="line"><span class="comment">//   console.log(&#x27;hello&#x27;)</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="10、try…catch"><a href="#10、try…catch" class="headerlink" title="10、try…catch"></a>10、try…catch</h2><p>在 ES10 之前我们都是这样捕获异常的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// tryCode</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">  <span class="comment">// catchCode</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里 err 是必须的参数，在 ES10 可以省略这个参数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Foobar&#x27;</span>)</span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.error(<span class="string">&#x27;Bar&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="11、BigInt"><a href="#11、BigInt" class="headerlink" title="11、BigInt"></a>11、BigInt</h2><p>在 ES10 增加了一个数据类型：BigInt，用于处理超过 2^53 的数字。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> aBigInt = <span class="number">11n</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> aNumber = <span class="number">156</span>;</span><br><span class="line"><span class="keyword">const</span> aBigInt = <span class="built_in">BigInt</span>(aNumber);</span><br><span class="line">aBigInt === <span class="number">156n</span> <span class="comment">// true</span></span><br><span class="line"><span class="keyword">typeof</span> aBigInt === bigint <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>[!DANGER]<br>eslint还不支持 11n 这种写法，参考：<a target="_blank" rel="noopener" href="https://github.com/standard/standard/issues/1207">https://github.com/standard/standard/issues/1207</a></p>
</blockquote>
<p><strong>思考</strong></p>
<ol>
<li>自己如何给 Array 实现一个 Flat 函数？</li>
<li>利用 Object.fromEntries 把 url 的 search 部分返回一个 object？</li>
</ol>
<h2 id="扩展阅读-16"><a href="#扩展阅读-16" class="headerlink" title="@ 扩展阅读"></a>@ 扩展阅读</h2><ol>
<li>Well-formed JSON.stringify：<a target="_blank" rel="noopener" href="http://2ality.com/2019/01/well-formed-stringify.html">http://2ality.com/2019/01/well-formed-stringify.html</a></li>
<li>BigInt: arbitrary-precision integers in JavaScript：<a target="_blank" rel="noopener" href="https://v8.dev/features/bigint">https://v8.dev/features/bigint</a></li>
</ol>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol>
<li>What’s new in JavaScript ES2019：<a target="_blank" rel="noopener" href="https://www.freecodecamp.org/news/whats-new-in-javascript-es2019-8af4390d8494/">https://www.freecodecamp.org/news/whats-new-in-javascript-es2019-8af4390d8494/</a></li>
<li>proposal-object-from-entries：<a target="_blank" rel="noopener" href="https://github.com/tc39/proposal-object-from-entries">https://github.com/tc39/proposal-object-from-entries</a></li>
<li>entries-useful：<a target="_blank" rel="noopener" href="https://github.com/tc39/proposal-object-from-entries#when-is-this-useful">https://github.com/tc39/proposal-object-from-entries#when-is-this-useful</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/axuebin/articles/issues/29">https://github.com/axuebin/articles/issues/29</a></li>
</ol>
<h1 id="六、ES11-2020"><a href="#六、ES11-2020" class="headerlink" title="六、ES11(2020)"></a>六、ES11(2020)</h1><p>1 全局模式捕获：String.prototype.matchAll()</p>
<p>2 动态导入：Dynamic import()</p>
<p>3 新的原始数据类型：BigInt</p>
<p>4 Promise扩展：Promise.allSettled()</p>
<p>5 全局对象：globalThis</p>
<p>6 可选链：Optional chaining</p>
<p>7 空值合并运算符：Nullish coalescing Operator</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/es6/" rel="tag"># es6</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2019/04/25/java%E7%AC%94%E8%AE%B0_%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="prev" title="java笔记_多线程">
                  <i class="fa fa-chevron-left"></i> java笔记_多线程
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2019/07/25/Git%E5%85%A5%E9%97%A8/" rel="next" title="Git入门">
                  Git入门 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>





<script src="/js/comments.js"></script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">浙ICP备18041583号-1 </a>
      <img src="/images/beian.png">
  </div>

<div class="copyright">
  &copy; 2018 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Mr.wj</span>
</div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
