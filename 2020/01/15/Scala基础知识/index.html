<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css">

<script class="next-config" data-name="main" type="application/json">{&quot;hostname&quot;:&quot;www.wjqixige.cn&quot;,&quot;root&quot;:&quot;&#x2F;&quot;,&quot;images&quot;:&quot;&#x2F;images&quot;,&quot;scheme&quot;:&quot;Gemini&quot;,&quot;version&quot;:&quot;8.3.0&quot;,&quot;exturl&quot;:false,&quot;sidebar&quot;:{&quot;position&quot;:&quot;left&quot;,&quot;display&quot;:&quot;post&quot;,&quot;padding&quot;:18,&quot;offset&quot;:12},&quot;copycode&quot;:false,&quot;bookmark&quot;:{&quot;enable&quot;:false,&quot;color&quot;:&quot;#222&quot;,&quot;save&quot;:&quot;auto&quot;},&quot;fancybox&quot;:false,&quot;mediumzoom&quot;:false,&quot;lazyload&quot;:false,&quot;pangu&quot;:false,&quot;comments&quot;:{&quot;style&quot;:&quot;tabs&quot;,&quot;active&quot;:null,&quot;storage&quot;:true,&quot;lazyload&quot;:false,&quot;nav&quot;:null},&quot;motion&quot;:{&quot;enable&quot;:false,&quot;async&quot;:false,&quot;transition&quot;:{&quot;post_block&quot;:&quot;fadeIn&quot;,&quot;post_header&quot;:&quot;fadeInDown&quot;,&quot;post_body&quot;:&quot;fadeInDown&quot;,&quot;coll_header&quot;:&quot;fadeInLeft&quot;,&quot;sidebar&quot;:&quot;fadeInUp&quot;}},&quot;prism&quot;:false,&quot;i18n&quot;:{&quot;placeholder&quot;:&quot;搜索...&quot;,&quot;empty&quot;:&quot;没有找到任何搜索结果：${query}&quot;,&quot;hits_time&quot;:&quot;找到 ${hits} 个搜索结果（用时 ${time} 毫秒）&quot;,&quot;hits&quot;:&quot;找到 ${hits} 个搜索结果&quot;}}</script>
<meta name="description" content="scala是运行在JVM上的多范式编程语言，同时支持面向对象和面向函数编程。早期，scala刚出现的时候，并没有怎么引起重视，随着Spark和Kafka这样基于scala的大数据框架的兴起，scala逐步进入大数据开发者的眼帘。scala的主要优势是它的表达性。 Scala语言主要用于开发大数据应用程序，如：Spark程序、Flink程序；它具有表达能力强，一行代码抵得上多行java代码，开发速度">
<meta property="og:type" content="article">
<meta property="og:title" content="Scala基础知识">
<meta property="og:url" content="http://www.wjqixige.cn/2020/01/15/Scala%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/index.html">
<meta property="og:site_name" content="栖溪阁晓生">
<meta property="og:description" content="scala是运行在JVM上的多范式编程语言，同时支持面向对象和面向函数编程。早期，scala刚出现的时候，并没有怎么引起重视，随着Spark和Kafka这样基于scala的大数据框架的兴起，scala逐步进入大数据开发者的眼帘。scala的主要优势是它的表达性。 Scala语言主要用于开发大数据应用程序，如：Spark程序、Flink程序；它具有表达能力强，一行代码抵得上多行java代码，开发速度">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-01-15T14:40:19.000Z">
<meta property="article:modified_time" content="2021-05-26T14:34:13.920Z">
<meta property="article:author" content="Mr.wj">
<meta property="article:tag" content="scala">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://www.wjqixige.cn/2020/01/15/Scala%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">



<script class="next-config" data-name="page" type="application/json">{&quot;sidebar&quot;:&quot;&quot;,&quot;isHome&quot;:false,&quot;isPost&quot;:true,&quot;lang&quot;:&quot;zh-CN&quot;,&quot;comments&quot;:true,&quot;permalink&quot;:&quot;http:&#x2F;&#x2F;www.wjqixige.cn&#x2F;2020&#x2F;01&#x2F;15&#x2F;Scala%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86&#x2F;&quot;,&quot;path&quot;:&quot;2020&#x2F;01&#x2F;15&#x2F;Scala基础知识&#x2F;&quot;,&quot;title&quot;:&quot;Scala基础知识&quot;}</script>

<script class="next-config" data-name="calendar" type="application/json">&quot;&quot;</script>
<title>Scala基础知识 | 栖溪阁晓生</title><script src="/js/config.js"></script>
  

  <script src="/js/third-party/analytics/baidu-analytics.js"></script>
  <script async src="https://hm.baidu.com/hm.js?2b13eba9500566124ceca63059f454fe"></script>



  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">栖溪阁晓生</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">个人在线笔记本</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87"><span class="nav-text">一、环境准备</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%AE%89%E8%A3%85"><span class="nav-text">1 安装</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E8%A7%A3%E9%87%8A%E5%99%A8"><span class="nav-text">2 解释器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="nav-text">二、基本语法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%8F%98%E9%87%8F"><span class="nav-text">1 变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-text">2 字符串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-amp-%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-text">3 数据类型&amp;操作符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E7%B1%BB%E5%9E%8B%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="nav-text">4 类型层次结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E6%9D%A1%E4%BB%B6%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-text">5 条件表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E5%BE%AA%E7%8E%AF"><span class="nav-text">6 循环</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-1-for%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-text">6.1 for表达式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2-while%E5%BE%AA%E7%8E%AF"><span class="nav-text">6.2 while循环</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-break%E5%92%8Ccontinue"><span class="nav-text">7 break和continue</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-%E6%96%B9%E6%B3%95"><span class="nav-text">8 方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0"><span class="nav-text">1.1 方法参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-%E8%B0%83%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="nav-text">1.2 调用方式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-%E5%87%BD%E6%95%B0"><span class="nav-text">9 函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-%E6%95%B0%E7%BB%84"><span class="nav-text">10 数组</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-%E5%AE%9A%E9%95%BF%E6%95%B0%E7%BB%84"><span class="nav-text">1.1 定长数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-%E5%8F%98%E9%95%BF%E6%95%B0%E7%BB%84"><span class="nav-text">1.2 变长数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-%E9%81%8D%E5%8E%86%E6%95%B0%E7%BB%84"><span class="nav-text">1.3 遍历数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-4-%E6%95%B0%E7%BB%84%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C"><span class="nav-text">1.4 数组常用操作</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-%E5%85%83%E7%BB%84"><span class="nav-text">11 元组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-List"><span class="nav-text">12 List</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%88%97%E8%A1%A8"><span class="nav-text">1.1 不可变列表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-%E5%8F%AF%E5%8F%98%E5%88%97%E8%A1%A8"><span class="nav-text">1.2 可变列表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-%E5%88%97%E8%A1%A8%E7%9A%84%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C"><span class="nav-text">1.3 列表的常用操作</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-Set"><span class="nav-text">13 Set</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-%E4%B8%8D%E5%8F%AF%E5%8F%98%E9%9B%86"><span class="nav-text">1.1 不可变集</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-%E5%8F%AF%E5%8F%98%E9%9B%86"><span class="nav-text">1.2 可变集</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-Map"><span class="nav-text">14 Map</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-%E4%B8%8D%E5%8F%AF%E5%8F%98Map"><span class="nav-text">1.1 不可变Map</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-%E5%8F%AF%E5%8F%98Map"><span class="nav-text">1.2 可变Map</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-iterator"><span class="nav-text">15 iterator</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B"><span class="nav-text">16 函数式编程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-foreach"><span class="nav-text">1.1 foreach</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-Map"><span class="nav-text">1.2 Map</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-flatMap"><span class="nav-text">1.3 flatMap</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-4-filter"><span class="nav-text">1.4 filter</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-5-%E6%8E%92%E5%BA%8F"><span class="nav-text">1.5 排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-6-%E5%88%86%E7%BB%84"><span class="nav-text">1.6 分组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-7-%E8%81%9A%E5%90%88"><span class="nav-text">1.7 聚合</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="nav-text">三、面向对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1"><span class="nav-text">1 类和对象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-%E5%88%9B%E5%BB%BA%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1"><span class="nav-text">1.1 创建类和对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-%E5%AE%9A%E4%B9%89%E5%92%8C%E8%AE%BF%E9%97%AE%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="nav-text">1.2 定义和访问成员变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-%E4%BD%BF%E7%94%A8%E4%B8%8B%E5%88%92%E7%BA%BF%E5%88%9D%E5%A7%8B%E5%8C%96%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="nav-text">1.3 使用下划线初始化成员变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-4-%E5%AE%9A%E4%B9%89%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95"><span class="nav-text">1.4 定义成员方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-5-%E6%88%90%E5%91%98%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="nav-text">1.5 成员访问修饰符</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E6%9E%84%E9%80%A0%E5%99%A8"><span class="nav-text">2 构造器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-%E4%B8%BB%E6%9E%84%E9%80%A0%E5%99%A8"><span class="nav-text">1.1 主构造器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-%E8%BE%85%E5%8A%A9%E6%9E%84%E9%80%A0%E5%99%A8"><span class="nav-text">1.2 辅助构造器</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%8D%95%E4%BE%8B%E5%AF%B9%E8%B1%A1"><span class="nav-text">3 单例对象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-%E5%8D%95%E4%BE%8B%E5%AF%B9%E8%B1%A1"><span class="nav-text">1.1 单例对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-main%E6%96%B9%E6%B3%95"><span class="nav-text">1.2 main方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E4%BC%B4%E7%94%9F%E5%AF%B9%E8%B1%A1"><span class="nav-text">4 伴生对象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-%E5%AE%9A%E4%B9%89%E4%BC%B4%E7%94%9F%E5%AF%B9%E8%B1%A1"><span class="nav-text">1.1 定义伴生对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-private-this-%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90"><span class="nav-text">1.2 private[this]访问权限</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-apply%E6%96%B9%E6%B3%95"><span class="nav-text">1.3 apply方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E7%BB%A7%E6%89%BF"><span class="nav-text">5 继承</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-%E5%AE%9A%E4%B9%89%E8%AF%AD%E6%B3%95"><span class="nav-text">1.1 定义语法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-%E7%B1%BB%E7%BB%A7%E6%89%BF"><span class="nav-text">1.2 类继承</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-%E5%8D%95%E4%BE%8B%E5%AF%B9%E8%B1%A1%E7%BB%A7%E6%89%BF"><span class="nav-text">1.3 单例对象继承</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-override%E5%92%8Csuper"><span class="nav-text">6 override和super</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD"><span class="nav-text">7 类型判断</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-isInstanceof-asInstanceof"><span class="nav-text">1.1 isInstanceof&#x2F;asInstanceof</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-getClass%E5%92%8CclassOf"><span class="nav-text">1.2 getClass和classOf</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="nav-text">8 抽象类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB"><span class="nav-text">9 匿名内部类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-%E7%89%B9%E8%B4%A8trait"><span class="nav-text">10 特质trait</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-trait%E4%BD%9C%E4%B8%BA%E6%8E%A5%E5%8F%A3%E4%BD%BF%E7%94%A8"><span class="nav-text">1.1 trait作为接口使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-%E7%89%B9%E8%B4%A8%E4%B8%AD%E5%AE%9A%E4%B9%89%E5%85%B7%E4%BD%93%E6%96%B9%E6%B3%95"><span class="nav-text">1.2 特质中定义具体方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-%E7%89%B9%E8%B4%A8%E5%AE%9A%E4%B9%89%E5%85%B7%E4%BD%93%E7%9A%84%E5%AD%97%E6%AE%B5%E5%92%8C%E6%8A%BD%E8%B1%A1%E5%AD%97%E6%AE%B5"><span class="nav-text">1.3 特质定义具体的字段和抽象字段</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-4-%E5%AE%9E%E7%8E%B0%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F"><span class="nav-text">1.4 实现模板模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-5-%E5%AF%B9%E8%B1%A1%E6%B7%B7%E5%85%A5trait"><span class="nav-text">1.5 对象混入trait</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-6-%E8%B0%83%E7%94%A8%E9%93%BE"><span class="nav-text">1.6 调用链</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-7-trait%E6%9E%84%E9%80%A0%E6%9C%BA%E5%88%B6"><span class="nav-text">1.7 trait构造机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-8-%E7%BB%A7%E6%89%BFclass"><span class="nav-text">1.8 继承class</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9B%E3%80%81%E6%A0%B7%E4%BE%8B%E7%B1%BB"><span class="nav-text">四、样例类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E6%A0%B7%E4%BE%8B%E7%B1%BB%E6%96%B9%E6%B3%95"><span class="nav-text">1 样例类方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-apply"><span class="nav-text">1.1 apply</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-toString"><span class="nav-text">1.2 toString</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-equals"><span class="nav-text">1.3 equals</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-4-hashCode"><span class="nav-text">1.4 hashCode</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-5-copy"><span class="nav-text">1.5 copy</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E6%A0%B7%E4%BE%8B%E5%AF%B9%E8%B1%A1"><span class="nav-text">2 样例对象</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%94%E3%80%81%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D"><span class="nav-text">五、模式匹配</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E7%AE%80%E5%8D%95%E5%8C%B9%E9%85%8D"><span class="nav-text">1 简单匹配</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%8C%B9%E9%85%8D%E7%B1%BB%E5%9E%8B"><span class="nav-text">2 匹配类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%AE%88%E5%8D%AB"><span class="nav-text">3 守卫</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E5%8C%B9%E9%85%8D%E6%A0%B7%E4%BE%8B%E7%B1%BB"><span class="nav-text">4 匹配样例类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E5%8C%B9%E9%85%8D%E9%9B%86%E5%90%88"><span class="nav-text">5 匹配集合</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-%E5%8C%B9%E9%85%8D%E6%95%B0%E7%BB%84"><span class="nav-text">5.1 匹配数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-%E5%8C%B9%E9%85%8D%E5%88%97%E8%A1%A8"><span class="nav-text">5.2 匹配列表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-3-%E5%8C%B9%E9%85%8D%E5%85%83%E7%BB%84"><span class="nav-text">5.3 匹配元组</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E"><span class="nav-text">6 变量声明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-Option%E7%B1%BB%E5%9E%8B"><span class="nav-text">7 Option类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-%E5%81%8F%E5%87%BD%E6%95%B0"><span class="nav-text">8 偏函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-text">9 正则表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="nav-text">10 异常处理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E6%8D%95%E8%8E%B7%E5%BC%82%E5%B8%B8"><span class="nav-text">1 捕获异常</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8"><span class="nav-text">2 抛出异常</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-%E6%8F%90%E5%8F%96%E5%99%A8Extractor"><span class="nav-text">11 提取器Extractor</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%AE%9A%E4%B9%89%E6%8F%90%E5%8F%96%E5%99%A8"><span class="nav-text">1 定义提取器</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-%E6%B3%9B%E5%9E%8B"><span class="nav-text">12 泛型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E6%B3%9B%E5%9E%8B%E7%B1%BB"><span class="nav-text">1 泛型类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E4%B8%8A%E4%B8%8B%E7%95%8C"><span class="nav-text">2 上下界</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E5%8D%8F%E5%8F%98%E3%80%81%E9%80%86%E5%8F%98%E3%80%81%E9%9D%9E%E5%8F%98"><span class="nav-text">3 协变、逆变、非变</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%AD%E3%80%81Actor%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B"><span class="nav-text">六、Actor并发编程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-Actor%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="nav-text">1 Actor并发编程模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%88%9B%E5%BB%BAActor"><span class="nav-text">2 创建Actor</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%8F%91%E9%80%81%E3%80%81%E6%8E%A5%E6%94%B6%E6%B6%88%E6%81%AF"><span class="nav-text">3 发送、接收消息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E5%8F%91%E9%80%81%E3%80%81%E6%8E%A5%E6%94%B6%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B6%88%E6%81%AF"><span class="nav-text">4 发送、接收自定义消息</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%83%E3%80%81%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0"><span class="nav-text">七、高阶函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E4%BD%9C%E4%B8%BA%E5%80%BC%E7%9A%84%E5%87%BD%E6%95%B0"><span class="nav-text">1 作为值的函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0"><span class="nav-text">2 匿名函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E6%9F%AF%E9%87%8C%E5%8C%96"><span class="nav-text">3 柯里化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E9%97%AD%E5%8C%85"><span class="nav-text">4 闭包</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%AB%E3%80%81%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2%E4%B8%8E%E9%9A%90%E5%BC%8F%E5%8F%82%E6%95%B0"><span class="nav-text">八、隐式转换与隐式参数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E4%BD%BF%E7%94%A8%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2"><span class="nav-text">1 使用隐式转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E8%87%AA%E5%8A%A8%E5%AF%BC%E5%85%A5%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2"><span class="nav-text">2 自动导入隐式转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E9%9A%90%E5%BC%8F%E5%8F%82%E6%95%B0"><span class="nav-text">3 隐式参数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B9%9D%E3%80%81Akka%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A1%86%E6%9E%B6"><span class="nav-text">九、Akka并发编程框架</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E6%A1%88%E4%BE%8B%E5%85%A5%E9%97%A8"><span class="nav-text">1 案例入门</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-Akka%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1"><span class="nav-text">2 Akka定时任务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%AE%9E%E7%8E%B0%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1-Master%E5%AE%9E%E7%8E%B0"><span class="nav-text">3 实现进程间通信-Master实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-Worker%E5%AE%9E%E7%8E%B0"><span class="nav-text">3.1 Worker实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-Master%E5%AE%9E%E7%8E%B0"><span class="nav-text">3.2 Master实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E7%AE%80%E6%98%93Spark%E9%80%9A%E4%BF%A1%E6%A1%86%E6%9E%B6%E6%A1%88%E4%BE%8Bni"><span class="nav-text">4 简易Spark通信框架案例ni</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1%E5%B7%A5%E7%A8%8B%E6%90%AD%E5%BB%BA"><span class="nav-text">4.1工程搭建</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-%E6%9E%84%E5%BB%BAMaster%E5%92%8CWorker"><span class="nav-text">4.2 构建Master和Worker</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-Worker%E6%B3%A8%E5%86%8C%E9%98%B6%E6%AE%B5%E5%AE%9E%E7%8E%B0"><span class="nav-text">4.3 Worker注册阶段实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-4-Worker%E5%AE%9A%E6%97%B6%E5%8F%91%E9%80%81%E5%BF%83%E8%B7%B3%E9%98%B6%E6%AE%B5"><span class="nav-text">4.4 Worker定时发送心跳阶段</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-5-Master%E5%AE%9A%E6%97%B6%E5%BF%83%E8%B7%B3%E6%A3%80%E6%B5%8B%E9%98%B6%E6%AE%B5"><span class="nav-text">4.5 Master定时心跳检测阶段</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-6-%E5%A4%9A%E4%B8%AAWorker%E6%B5%8B%E8%AF%95%E9%98%B6%E6%AE%B5"><span class="nav-text">4.6 多个Worker测试阶段</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <a href="/"><img class="site-author-image" itemprop="image" alt="Mr.wj" src="/uploads/logo.jpg"></a>
  <p class="site-author-name" itemprop="name">Mr.wj</p>
  <div class="site-description" itemprop="description">欢迎来到栖息阁晓生博客</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">55</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">38</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/gadekuoen/wjqixige" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;gadekuoen&#x2F;wjqixige" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/wujiang569@126.com" title="E-Mail → wujiang569@126.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://me.csdn.net/weixin_39455881" title="CSDN → https:&#x2F;&#x2F;me.csdn.net&#x2F;weixin_39455881" rel="noopener" target="_blank"><i class="crosshairs fa-fw"></i>CSDN</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/2983932047/profile?rightmod=1&wvr=6&mod=personinfo&is_all=1" title="微博 → https:&#x2F;&#x2F;weibo.com&#x2F;2983932047&#x2F;profile?rightmod&#x3D;1&amp;wvr&#x3D;6&amp;mod&#x3D;personinfo&amp;is_all&#x3D;1" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>微博</a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.wjqixige.cn/2020/01/15/Scala%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/logo.jpg">
      <meta itemprop="name" content="Mr.wj">
      <meta itemprop="description" content="欢迎来到栖息阁晓生博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="栖溪阁晓生">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Scala基础知识
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-01-15 22:40:19" itemprop="dateCreated datePublished" datetime="2020-01-15T22:40:19+08:00">2020-01-15</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-05-26 22:34:13" itemprop="dateModified" datetime="2021-05-26T22:34:13+08:00">2021-05-26</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Scala/" itemprop="url" rel="index"><span itemprop="name">Scala</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>scala是运行在<code>JVM</code>上的多范式编程语言，同时支持面向对象和面向函数编程。早期，scala刚出现的时候，并没有怎么引起重视，随着Spark和Kafka这样基于scala的大数据框架的兴起，scala逐步进入大数据开发者的眼帘。scala的主要优势是它的<strong>表达性</strong>。</p>
<p>Scala语言主要用于开发大数据应用程序，如：Spark程序、Flink程序；它具有表达能力强，一行代码抵得上多行java代码，开发速度快；它也兼容Java，可以访问庞大的Java类库，例如：操作mysql、redis、freemarker、activemq等等。</p>
<span id="more"></span>

<h2 id="一、环境准备"><a href="#一、环境准备" class="headerlink" title="一、环境准备"></a>一、环境准备</h2><h3 id="1-安装"><a href="#1-安装" class="headerlink" title="1 安装"></a>1 安装</h3><p>编写scala代码之前，需要先安装scala编译器以及开发工具。Java程序编译执行流程：</p>


<p>Scala程序编译执行流程：</p>


<p>scala程序运行需要依赖于Java类库，必须要有Java运行环境，scala才能正确执行。根据上述流程图，要编译运行scala程序，需要：<code>jdk（jvm）</code>、<code>scala编译器（scala SDK）</code>。</p>
<p>接下来，需要依次安装以下内容：<code>安装JDK</code>、<code>安装scala SDK</code>、<code>安装IDEA插件</code></p>
<p><strong>安装JDK</strong></p>
<p>安装JDK 1.8 64位版本，并配置好环境变量</p>
<p><strong>安装scala SDK</strong></p>
<p>scala SDK是scala语言的编译器，要开发scala程序，必须要先安装SDK。本次安装的版本是: 2.11.12；操作步骤：</p>
<ol>
<li>下载安装包：链接：<a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1MLa6TBoMcOZMDVO7SLk1HQ">https://pan.baidu.com/s/1MLa6TBoMcOZMDVO7SLk1HQ</a>  提取码：moq7 </li>
<li>双击scala-2.11.12.msi，将scala安装在指定目录，例如：D:\scala\</li>
<li>打开控制台，输入<code>scala -version</code></li>
</ol>
<p><strong>安装IDEA scala插件</strong></p>
<p>IDEA默认是不支持scala程序开发，所以需要来安装scala插件来支持scala语言。安装步骤如下：</p>
<p>操作1：查看IDEA的版本号；</p>
<p>操作2：到IDEA官网下载对应版本的IDEA scala插件：<a target="_blank" rel="noopener" href="http://plugins.jetbrains.com/plugin/1347-scala">http://plugins.jetbrains.com/plugin/1347-scala</a>；</p>
<blockquote>
<p>注意：务必下载IDEA版本一致的scala插件</p>
</blockquote>
<p>操作3：选择配置 &gt; 选择插件；</p>
<p>操作4：点击小齿轮 &gt; 选择从本地安装插件；</p>
<p>操作5：找到下载的插件位置，点击OK；</p>
<p>操作6：重新启动IDEA；</p>
<p>操作7：查看scala插件；</p>
<h3 id="2-解释器"><a href="#2-解释器" class="headerlink" title="2 解释器"></a>2 解释器</h3><p>使用scala解释器来学习scala基本语法，scala解释器像Linux命令一样，执行一条代码，马上就可以让我们看到执行结果，用来测试比较方便。</p>
<p><strong>启动scala解释器</strong></p>
<p>要启动scala解释器，只需要以下几步：</p>
<ul>
<li>按住<code>windows键 + r</code></li>
<li>输入<code>scala</code>即可</li>
</ul>
<p><strong>执行scala代码</strong></p>
<p>在scala的命令提示窗口中输入<code>println(&quot;hello, world&quot;)</code>，回车执行</p>
<p><strong>退出解释器</strong></p>
<p>在scala命令提示窗口中执行<code>:quit</code>，即可退出解释器。</p>
<h2 id="二、基本语法"><a href="#二、基本语法" class="headerlink" title="二、基本语法"></a>二、基本语法</h2><h3 id="1-变量"><a href="#1-变量" class="headerlink" title="1 变量"></a>1 变量</h3><p>在scala中，可以使用<code>val</code>或者<code>var</code>来定义变量，语法格式如下:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** val定义：不可重新赋值的变量；var定义：可重新赋值的变量 */</span></span><br><span class="line"><span class="keyword">val</span>/<span class="keyword">var</span> 变量标识:变量类型 = 初始值</span><br></pre></td></tr></table></figure>

<blockquote>
<p>[!NOTE]：变量类型写在变量名后面，不需要添加分号，优先使用<code>val</code>定义变量，如果变量需要被重新赋值，才使用<code>var</code></p>
</blockquote>
<p><strong>使用类型推断来定义变量</strong></p>
<p>scala可以自动根据变量的值来自动推断变量的类型。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> name = <span class="string">&quot;tom&quot;</span></span><br><span class="line">name: <span class="type">String</span> = tom</span><br></pre></td></tr></table></figure>

<p><strong>惰性赋值</strong></p>
<p>在大数据开发中，有时会编写非常复杂的SQL语句，如果直接加载到JVM中，会有很大的内存开销。如何解决？当有一些变量保存的数据较大时，但是不需要马上加载到JVM内存。可以使用<strong>惰性赋值</strong>来提高效率。语法格式：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lazy</span> <span class="keyword">val</span>/<span class="keyword">var</span> 变量名 = 表达式</span><br></pre></td></tr></table></figure>

<h3 id="2-字符串"><a href="#2-字符串" class="headerlink" title="2 字符串"></a>2 字符串</h3><p>scala提供多种定义字符串的方式，将来我们可以根据需要来选择最方便的定义方式。</p>
<p><strong>使用双引号</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span>/<span class="keyword">var</span> 变量名 = “字符串”</span><br></pre></td></tr></table></figure>

<p><strong>使用插值表达式</strong></p>
<p>scala中，可以使用插值表达式来定义字符串，有效避免大量字符串的拼接。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span>/<span class="keyword">var</span> 变量名 = <span class="string">s&quot;<span class="subst">$&#123;变量/表达式&#125;</span>字符串&quot;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：定义字符串之前添加<code>s</code>；在字符串中，可以使用<code>$&#123;&#125;</code>来引用变量或者编写表达式</p>
</blockquote>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> name = <span class="string">&quot;zhangsan&quot;</span></span><br><span class="line">scala&gt; <span class="keyword">val</span> age = <span class="number">30</span></span><br><span class="line">scala&gt; <span class="keyword">val</span> sex = <span class="string">&quot;male&quot;</span></span><br><span class="line">scala&gt; <span class="keyword">val</span> info = <span class="string">s&quot;name=<span class="subst">$&#123;name&#125;</span>, age=<span class="subst">$&#123;age&#125;</span>, sex=<span class="subst">$&#123;sex&#125;</span>&quot;</span></span><br><span class="line">info: <span class="type">String</span> = name=zhangsan, age=<span class="number">30</span>, sex=male</span><br></pre></td></tr></table></figure>

<p><strong>使用三引号</strong></p>
<p>如果有大段的文本需要保存，就可以使用三引号来定义字符串。例如：保存一大段的SQL语句。三个引号中间的所有字符串都将作为字符串的值。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span>/<span class="keyword">var</span> 变量名 = <span class="string">&quot;&quot;&quot;字符串1</span></span><br><span class="line"><span class="string">字符串2&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="3-数据类型-amp-操作符"><a href="#3-数据类型-amp-操作符" class="headerlink" title="3 数据类型&amp;操作符"></a>3 数据类型&amp;操作符</h3><p>scala中的类型以及操作符绝大多数和Java一样，以下总结与java不一样的用法： </p>
<p><strong>数据类型</strong></p>
<table>
<thead>
<tr>
<th>基础类型</th>
<th>类型说明</th>
</tr>
</thead>
<tbody><tr>
<td>Byte</td>
<td>8位带符号整数</td>
</tr>
<tr>
<td>Short</td>
<td>16位带符号整数</td>
</tr>
<tr>
<td><strong>Int</strong></td>
<td>32位带符号整数</td>
</tr>
<tr>
<td>Long</td>
<td>64位带符号整数</td>
</tr>
<tr>
<td>Char</td>
<td>16位无符号Unicode字符</td>
</tr>
<tr>
<td>String</td>
<td>Char类型的序列（字符串）</td>
</tr>
<tr>
<td>Float</td>
<td>32位单精度浮点数</td>
</tr>
<tr>
<td>Double</td>
<td>64位双精度浮点数</td>
</tr>
<tr>
<td>Boolean</td>
<td>true或false</td>
</tr>
</tbody></table>
<p>scala类型与Java的区别：</p>
<ol>
<li>scala中所有的类型都使用<strong>大写字母</strong>；</li>
<li>开头整形使用<code>Int</code>而不是Integer；</li>
<li>scala中定义变量可以不写类型，让scala编译器自动推断；</li>
</ol>
<p><strong>运算符</strong></p>
<table>
<thead>
<tr>
<th>类别</th>
<th>操作符</th>
</tr>
</thead>
<tbody><tr>
<td>算术运算符</td>
<td>+、-、*、/</td>
</tr>
<tr>
<td>关系运算符</td>
<td>&gt;、&lt;、==、!=、&gt;=、&lt;=</td>
</tr>
<tr>
<td>逻辑运算符</td>
<td>&amp;&amp;、&#124;&#124;、!</td>
</tr>
<tr>
<td>位运算符</td>
<td>&amp;、&#124;&#124;、^、&lt;&lt;、&gt;&gt;</td>
</tr>
</tbody></table>
<ul>
<li><p>scala中没有，++、–运算符</p>
</li>
<li><p>与Java不一样，在scala中，可以直接使用<code>==</code>、<code>!=</code>进行比较，它们与<code>equals</code>方法表示一致。而比较两个对象的引用值，使用<code>eq</code></p>
</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> str1 = <span class="string">&quot;abc&quot;</span></span><br><span class="line"><span class="keyword">val</span> str2 = str1 + <span class="string">&quot;&quot;</span></span><br><span class="line">str1 == str2</span><br><span class="line">str1.eq(str2)</span><br></pre></td></tr></table></figure>

<h3 id="4-类型层次结构"><a href="#4-类型层次结构" class="headerlink" title="4 类型层次结构"></a>4 类型层次结构</h3>

<table>
<thead>
<tr>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Any</td>
<td><strong>所有类型</strong> 的父类，,它有两个子类AnyRef与AnyVal</td>
</tr>
<tr>
<td>AnyVal</td>
<td><strong>所有数值类型</strong> 的父类</td>
</tr>
<tr>
<td>AnyRef</td>
<td><strong>所有对象类型（引用类型）</strong> 的父类</td>
</tr>
<tr>
<td>Unit</td>
<td>表示空，Unit是AnyVal的子类，它只有一个的实例<code>()</code><br/>它类似于Java中的void，但scala要比Java更加面向对象</td>
</tr>
<tr>
<td>Null</td>
<td>Null是AnyRef的子类，也就是说它是所有引用类型的子类。它的实例是<code>null</code><br/>可以将null赋值给任何对象类型</td>
</tr>
<tr>
<td>Nothing</td>
<td>所有类型的<strong>子类</strong><br/>不能直接创建该类型实例，某个方法抛出异常时，返回的就是Nothing类型，因为Nothing是所有类的子类，那么它可以赋值为任何类型</td>
</tr>
</tbody></table>
<p><strong>nothing</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> c = m3(<span class="number">1</span>,<span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">m3</span></span>(x:<span class="type">Int</span>, y:<span class="type">Int</span>):<span class="type">Int</span> = &#123;</span><br><span class="line">    <span class="keyword">if</span>(y == <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">Exception</span>(<span class="string">&quot;这是一个异常&quot;</span>)</span><br><span class="line">    x / y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>问题</strong>：以下代码是否有问题？</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> b:<span class="type">Int</span> = <span class="literal">null</span></span><br></pre></td></tr></table></figure>

<p>scala会解释报错：Null类型并不能转换为Int类型，说明<strong>Null类型并不是Int类型的子类</strong>。</p>
<h3 id="5-条件表达式"><a href="#5-条件表达式" class="headerlink" title="5 条件表达式"></a>5 条件表达式</h3><p>条件表达式就是if表达式，if表达式可以根据给定的条件是否满足，根据条件的结果（真或假）决定执行对应的操作。scala条件表达式的语法和Java一样。</p>
<p><strong>有返回值的if</strong></p>
<p>与Java不一样的是：1、条件表达式也是有返回值的；2、没有三元表达式，可以使用if表达式替代三元表达式</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> sex = <span class="string">&quot;male&quot;</span></span><br><span class="line">sex: <span class="type">String</span> = male</span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> result = <span class="keyword">if</span>(sex == <span class="string">&quot;male&quot;</span>) <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">result: <span class="type">Int</span> = <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><strong>块表达式</strong></p>
<p>scala中，使用<code>&#123;&#125;</code>表示一个块表达式，和if表达式一样，块表达式也是有值的，值就是最后一个表达式的值。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> a = &#123;</span><br><span class="line">    | println(<span class="string">&quot;1 + 1&quot;</span>)</span><br><span class="line">    | <span class="number">1</span> + <span class="number">1</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-循环"><a href="#6-循环" class="headerlink" title="6 循环"></a>6 循环</h3><p>在scala中，可以使用for和while，但一般推荐使用for表达式，因为for表达式语法更简洁</p>
<h4 id="6-1-for表达式"><a href="#6-1-for表达式" class="headerlink" title="6.1 for表达式"></a>6.1 for表达式</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i &lt;- 表达式/数组/集合) &#123;</span><br><span class="line">    <span class="comment">// 表达式</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> nums = <span class="number">1.</span>to(<span class="number">10</span>)                                                              </span><br><span class="line">nums: scala.collection.immutable.<span class="type">Range</span>.<span class="type">Inclusive</span> = <span class="type">Range</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>) </span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">for</span>(i &lt;- nums) println(i)</span><br><span class="line"><span class="comment">//简写方式：</span></span><br><span class="line">scala&gt; <span class="keyword">for</span>(i &lt;- <span class="number">1</span> to <span class="number">10</span>) println(i)</span><br></pre></td></tr></table></figure>

<p><strong>嵌套循环</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i &lt;- <span class="number">1</span> to <span class="number">3</span>; j &lt;- <span class="number">1</span> to <span class="number">5</span>) &#123;print(<span class="string">&quot;*&quot;</span>);<span class="keyword">if</span>(j == <span class="number">5</span>) println(<span class="string">&quot;&quot;</span>)&#125;</span><br></pre></td></tr></table></figure>

<p><strong>守卫</strong></p>
<p>for表达式中，可以添加if判断语句，这个if判断就称之为守卫。我们可以使用守卫让for表达式更简洁。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i &lt;- 表达式/数组/集合 <span class="keyword">if</span> 表达式) &#123;</span><br><span class="line">    <span class="comment">// 表达式</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例：使用for表达式打印1-10之间能够整除3的数字</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加守卫，打印能够整除3的数字</span></span><br><span class="line"><span class="keyword">for</span>(i &lt;- <span class="number">1</span> to <span class="number">10</span> <span class="keyword">if</span> i % <span class="number">3</span> == <span class="number">0</span>) println(i)</span><br></pre></td></tr></table></figure>

<p><strong>for推导式</strong></p>
<p>将来可以使用for推导式生成一个新的集合（一组数据），在for循环体中，可以使用<code>yield</code>表达式构建出一个集合，把使用yield的for表达式称之为推导式.</p>
<p>示例：生成一个10、20、30…100的集合</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// for推导式：for表达式中以yield开始，该for表达式会构建出一个集合</span></span><br><span class="line"><span class="keyword">val</span> v = <span class="keyword">for</span>(i &lt;- <span class="number">1</span> to <span class="number">10</span>) <span class="keyword">yield</span> i * <span class="number">10</span></span><br></pre></td></tr></table></figure>

<h4 id="6-2-while循环"><a href="#6-2-while循环" class="headerlink" title="6.2 while循环"></a>6.2 while循环</h4><p>scala中while循环和Java中是一致的</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">var</span> i = <span class="number">1</span></span><br><span class="line">scala&gt; <span class="keyword">while</span>(i &lt;= <span class="number">10</span>) &#123;</span><br><span class="line">     | println(i)</span><br><span class="line">     | i = i+<span class="number">1</span></span><br><span class="line">     | &#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-break和continue"><a href="#7-break和continue" class="headerlink" title="7 break和continue"></a>7 break和continue</h3><p>在scala中，类似Java和C++的break/continue关键字被移除了；如果一定要使用break/continue，就需要使用<code>scala.util.control</code>包的Break类的<code>breable</code>和<code>break</code>方法。</p>
<p><strong>break用法</strong></p>
<p>导入Breaks包<code>import scala.util.control.Breaks._</code>；使用breakable将for表达式包起来；for表达式中需要退出循环的地方，添加<code>break()</code>方法调用。示例如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入scala.util.control包下的Break</span></span><br><span class="line"><span class="keyword">import</span> scala.util.control.<span class="type">Breaks</span>._</span><br><span class="line"></span><br><span class="line">breakable&#123;</span><br><span class="line">    <span class="keyword">for</span>(i &lt;- <span class="number">1</span> to <span class="number">100</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= <span class="number">50</span>) <span class="keyword">break</span>()</span><br><span class="line">        <span class="keyword">else</span> println(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>continue用法</strong></p>
<p>continue的实现与break类似，但有一点不同：<code>实现break是用breakable&#123;&#125;将整个for表达式包起来，而实现continue是用breakable&#123;&#125;将for表达式的循环体包含起来就可以了</code>。示例如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入scala.util.control包下的Break    </span></span><br><span class="line"><span class="keyword">import</span> scala.util.control.<span class="type">Breaks</span>._</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i &lt;- <span class="number">1</span> to <span class="number">100</span> ) &#123;</span><br><span class="line">    breakable&#123;</span><br><span class="line">        <span class="keyword">if</span>(i % <span class="number">10</span> == <span class="number">0</span>) <span class="keyword">break</span>()</span><br><span class="line">        <span class="keyword">else</span> println(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-方法"><a href="#8-方法" class="headerlink" title="8 方法"></a>8 方法</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">methodName</span> </span>(参数名:参数类型, 参数名:参数类型) : [<span class="keyword">return</span> <span class="class"><span class="keyword">type</span>] </span>= &#123;</span><br><span class="line">    <span class="comment">// 方法体：一系列的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：参数列表的参数类型不能省略；返回值类型可以省略，由scala编译器自动推断；返回值可以不写return，默认就是<code>&#123;&#125;</code>块表达式的值。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="function"><span class="keyword">def</span> <span class="title">add</span></span>(a:<span class="type">Int</span>, b:<span class="type">Int</span>) = a + b</span><br><span class="line">m1: (x: <span class="type">Int</span>, y: <span class="type">Int</span>)<span class="type">Int</span></span><br><span class="line"></span><br><span class="line">scala&gt; add(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">res10: <span class="type">Int</span> = <span class="number">3</span></span><br></pre></td></tr></table></figure>

<p><strong>返回值类型推断</strong></p>
<p>scala定义方法可以省略返回值，由scala自动推断返回值类型。这样方法定义后更加简洁。但是要注意：定义递归方法，不能省略返回值类型。示例如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="function"><span class="keyword">def</span> <span class="title">m2</span></span>(x:<span class="type">Int</span>) = &#123;</span><br><span class="line">     | <span class="keyword">if</span>(x&lt;=<span class="number">1</span>) <span class="number">1</span></span><br><span class="line">     | <span class="keyword">else</span> m2(x<span class="number">-1</span>) * x</span><br><span class="line">     | &#125;</span><br><span class="line">&lt;console&gt;:<span class="number">13</span>: error: recursive method m2 needs result <span class="class"><span class="keyword">type</span></span></span><br><span class="line"><span class="class">       <span class="title">else</span> <span class="title">m2</span>(<span class="params">x-1</span>) <span class="title">*</span> <span class="title">x</span></span></span><br></pre></td></tr></table></figure>

<h4 id="1-1-方法参数"><a href="#1-1-方法参数" class="headerlink" title="1.1 方法参数"></a>1.1 方法参数</h4><p>scala中的方法参数，使用比较灵活。它支持以下几种类型的参数：</p>
<p><strong>默认参数</strong>：在定义方法时可以给参数定义一个默认值。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// x，y带有默认值为0 </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span></span>(x:<span class="type">Int</span> = <span class="number">0</span>, y:<span class="type">Int</span> = <span class="number">0</span>) = x + y</span><br><span class="line">add()</span><br></pre></td></tr></table></figure>

<p><strong>带名参数</strong>：在调用方法时，可以指定参数的名称来进行调用。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span></span>(x:<span class="type">Int</span> = <span class="number">0</span>, y:<span class="type">Int</span> = <span class="number">0</span>) = x + y</span><br><span class="line">add(x=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p><strong>变长参数</strong>：如果方法的参数是不固定的，在参数类型后面加一个<code>*</code>号，表示参数可以是0个或者多个。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">方法名</span></span>(参数名:参数类型*):返回值类型 = &#123;</span><br><span class="line">    方法体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="function"><span class="keyword">def</span> <span class="title">add</span></span>(num:<span class="type">Int</span>*) = num.sum</span><br><span class="line">add: (num: <span class="type">Int</span>*)<span class="type">Int</span></span><br><span class="line"></span><br><span class="line">scala&gt; add(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line">res1: <span class="type">Int</span> = <span class="number">15</span></span><br></pre></td></tr></table></figure>

<h4 id="1-2-调用方式"><a href="#1-2-调用方式" class="headerlink" title="1.2 调用方式"></a>1.2 调用方式</h4><p>在scala中，有以下几种方法调用方式：</p>
<p><strong>后缀调用法</strong>：与Java没有区别。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对象名.方法名(参数)</span><br></pre></td></tr></table></figure>

<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="type">Math</span>.abs(<span class="number">-1</span>)</span><br><span class="line">res3: <span class="type">Int</span> = <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><strong>中缀调用法</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对象名 方法名 参数</span><br></pre></td></tr></table></figure>

<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="type">Math</span> abs <span class="number">-1</span></span><br><span class="line">res4: <span class="type">Int</span> = <span class="number">1</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>操作符即方法</strong>：在scala中，+ - * / %等这些操作符和Java一样，但在scala中：所有的操作符都是方法，操作符是一个方法名字是符号的方法</p>
</blockquote>
<p><strong>花括号调用法</strong>：方法只有一个参数，才能使用花括号调用法</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Math</span>.abs&#123; </span><br><span class="line">    <span class="comment">// 表达式1</span></span><br><span class="line">    <span class="comment">// 表达式2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="type">Math</span>.abs&#123;<span class="number">-10</span>&#125;</span><br><span class="line">res13: <span class="type">Int</span> = <span class="number">10</span></span><br></pre></td></tr></table></figure>

<p><strong>无括号调用法</strong>：如果方法没有参数，可以省略方法名后面的括号</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">m3</span></span>()=println(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">m3</span><br></pre></td></tr></table></figure>

<h3 id="9-函数"><a href="#9-函数" class="headerlink" title="9 函数"></a>9 函数</h3><p>scala支持函数式编程，函数定义不需要使用，无需指定返回值类型；<code>def</code>定义语法如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> 函数变量名 = (参数名:参数类型, 参数名:参数类型....) =&gt; 函数体</span><br></pre></td></tr></table></figure>

<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> add = (x:<span class="type">Int</span>, y:<span class="type">Int</span>) =&gt; x + y</span><br><span class="line">add: (<span class="type">Int</span>, <span class="type">Int</span>) =&gt; <span class="type">Int</span> = &lt;function2&gt;</span><br><span class="line"></span><br><span class="line">scala&gt; add(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">res3: <span class="type">Int</span> = <span class="number">3</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>方法和函数的区别：</p>
<ol>
<li>方法是隶属于类或者对象的，在运行时，它是加载到JVM的方法区中</li>
<li>可以将函数对象赋值给一个变量，在运行时，它是加载到JVM的堆内存中</li>
<li>函数是一个对象，继承自FunctionN，函数对象有apply，curried，toString，tupled这些方法。方法则没有</li>
</ol>
</blockquote>
<p>示例：方法无法赋值给变量</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="function"><span class="keyword">def</span> <span class="title">add</span></span>(x:<span class="type">Int</span>,y:<span class="type">Int</span>)=x+y</span><br><span class="line">add: (x: <span class="type">Int</span>, y: <span class="type">Int</span>)<span class="type">Int</span></span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> a = add</span><br><span class="line">&lt;console&gt;:<span class="number">12</span>: error: missing argument list <span class="keyword">for</span> method add</span><br><span class="line"><span class="type">Unapplied</span> methods are only converted to functions when a function <span class="class"><span class="keyword">type</span> <span class="title">is</span> <span class="title">expected</span>.</span></span><br><span class="line"><span class="class"><span class="title">You</span> <span class="title">can</span> <span class="title">make</span> <span class="title">this</span> <span class="title">conversion</span> <span class="title">explicit</span> <span class="title">by</span> <span class="title">writing</span> `<span class="title">add</span> <span class="title">_</span>` <span class="title">or</span> `<span class="title">add</span>(<span class="params">_,_</span>)` <span class="title">instead</span> <span class="title">of</span> `<span class="title">add</span>`.</span></span><br><span class="line"><span class="class">       <span class="title">val</span> <span class="title">a</span> </span>= add</span><br></pre></td></tr></table></figure>

<p><strong>方法转换为函数</strong></p>
<p>有时候需要将方法转换为函数，作为变量传递，就需要将方法转换为函数；使用<code>_</code>即可将方法转换为函数。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="function"><span class="keyword">def</span> <span class="title">add</span></span>(x:<span class="type">Int</span>,y:<span class="type">Int</span>)=x+y</span><br><span class="line">add: (x: <span class="type">Int</span>, y: <span class="type">Int</span>)<span class="type">Int</span></span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> a = add _</span><br><span class="line">a: (<span class="type">Int</span>, <span class="type">Int</span>) =&gt; <span class="type">Int</span> = &lt;function2&gt;</span><br></pre></td></tr></table></figure>

<h3 id="10-数组"><a href="#10-数组" class="headerlink" title="10 数组"></a>10 数组</h3><p>scala中数组的概念是和Java类似，可以用数组来存放一组数据。scala中，有两种数组，一种是<strong>定长数组</strong>，另一种是<strong>变长数组</strong>。</p>
<h4 id="1-1-定长数组"><a href="#1-1-定长数组" class="headerlink" title="1.1 定长数组"></a>1.1 定长数组</h4><p>定长数组指的是数组的<strong>长度</strong>是<strong>不允许改变</strong>的，数组的<strong>元素</strong>是<strong>可以改变</strong>的。语法如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过指定长度定义数组</span></span><br><span class="line"><span class="keyword">val</span>/<span class="keyword">var</span> 变量名 = <span class="keyword">new</span> <span class="type">Array</span>[元素类型](数组长度)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用元素直接初始化数组</span></span><br><span class="line"><span class="keyword">val</span>/<span class="keyword">var</span> 变量名 = <span class="type">Array</span>(元素<span class="number">1</span>, 元素<span class="number">2</span>, 元素<span class="number">3.</span>..)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：在scala中，数组的泛型使用<code>[]</code>来指定，使用<code>()</code>来获取元素</p>
</blockquote>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> a = <span class="keyword">new</span> <span class="type">Array</span>[<span class="type">Int</span>](<span class="number">100</span>)</span><br><span class="line">a: <span class="type">Array</span>[<span class="type">Int</span>] = <span class="type">Array</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,...)</span><br><span class="line"></span><br><span class="line">scala&gt; a(<span class="number">0</span>) = <span class="number">110</span></span><br><span class="line"></span><br><span class="line">scala&gt; a(<span class="number">0</span>)</span><br><span class="line"><span class="number">110</span></span><br></pre></td></tr></table></figure>

<h4 id="1-2-变长数组"><a href="#1-2-变长数组" class="headerlink" title="1.2 变长数组"></a>1.2 变长数组</h4><p>变长数组指的是数组的长度是可变的，可以往数组中添加、删除元素。</p>
<p><strong>定义变长数组</strong></p>
<p>创建变长数组，需要提前导入ArrayBuffer类<code>import scala.collection.mutable.ArrayBuffer</code>，语法：</p>
<ul>
<li><p>创建空的ArrayBuffer变长数组：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span>/<span class="keyword">var</span> a = <span class="type">ArrayBuffer</span>[元素类型]()</span><br></pre></td></tr></table></figure>

<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> a = <span class="type">ArrayBuffer</span>[<span class="type">Int</span>]()</span><br></pre></td></tr></table></figure></li>
<li><p>创建带有初始元素的ArrayBuffer</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span>/<span class="keyword">var</span> a = <span class="type">ArrayBuffer</span>(元素<span class="number">1</span>，元素<span class="number">2</span>，元素<span class="number">3.</span>...)</span><br></pre></td></tr></table></figure>

<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> a = <span class="type">ArrayBuffer</span>(<span class="string">&quot;hadoop&quot;</span>, <span class="string">&quot;storm&quot;</span>, <span class="string">&quot;spark&quot;</span>)</span><br><span class="line">a: scala.collection.mutable.<span class="type">ArrayBuffer</span>[<span class="type">String</span>] = <span class="type">ArrayBuffer</span>(hadoop, storm, spark)</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>添加/修改/删除元素</strong></p>
<ul>
<li>使用<code>+=</code>添加元素</li>
<li>使用<code>-=</code>删除元素</li>
<li>使用<code>++=</code>追加一个数组到变长数组</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义变长数组</span></span><br><span class="line">scala&gt; <span class="keyword">val</span> a = <span class="type">ArrayBuffer</span>(<span class="string">&quot;hadoop&quot;</span>, <span class="string">&quot;spark&quot;</span>, <span class="string">&quot;flink&quot;</span>)</span><br><span class="line">a: scala.collection.mutable.<span class="type">ArrayBuffer</span>[<span class="type">String</span>] = <span class="type">ArrayBuffer</span>(hadoop, spark, flink)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 追加一个元素</span></span><br><span class="line">scala&gt; a += <span class="string">&quot;flume&quot;</span></span><br><span class="line">res10: a.<span class="keyword">type</span> = <span class="type">ArrayBuffer</span>(hadoop, spark, flink, flume)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除一个元素</span></span><br><span class="line">scala&gt; a -= <span class="string">&quot;hadoop&quot;</span></span><br><span class="line">res11: a.<span class="keyword">type</span> = <span class="type">ArrayBuffer</span>(spark, flink, flume)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 追加一个数组</span></span><br><span class="line">scala&gt; a ++= <span class="type">Array</span>(<span class="string">&quot;hive&quot;</span>, <span class="string">&quot;sqoop&quot;</span>)</span><br><span class="line">res12: a.<span class="keyword">type</span> = <span class="type">ArrayBuffer</span>(spark, flink, flume, hive, sqoop)</span><br></pre></td></tr></table></figure>

<h4 id="1-3-遍历数组"><a href="#1-3-遍历数组" class="headerlink" title="1.3 遍历数组"></a>1.3 遍历数组</h4><p>可以使用以下两种方式来遍历数组：</p>
<ul>
<li><p>使用<code>for表达式</code>直接遍历数组中的元素</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> a = <span class="type">Array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line">scala&gt; <span class="keyword">for</span>(i&lt;-a) println(i)</span><br></pre></td></tr></table></figure></li>
<li><p>使用<code>索引</code>遍历数组中的元素</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> a = <span class="type">Array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line">scala&gt; <span class="keyword">for</span>(i &lt;- <span class="number">0</span> to a.length - <span class="number">1</span>) println(a(i))</span><br><span class="line">scala&gt; <span class="keyword">for</span>(i &lt;- <span class="number">0</span> until a.length) println(a(i))</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>0 until n——生成一系列的数字，包含0，不包含n</p>
<p>0 to n ——包含0，也包含n</p>
</blockquote>
<h4 id="1-4-数组常用操作"><a href="#1-4-数组常用操作" class="headerlink" title="1.4 数组常用操作"></a>1.4 数组常用操作</h4><p>scala中的数组封装了一些常用的计算操作，在对数据处理的时候不需要再重新实现；以下为常用的几个算法：</p>
<p><strong>求和</strong>：数组中的<code>sum</code>方法可以将所有的元素进行累加，然后得到结果</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> a = <span class="type">Array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">scala&gt; a.sum</span><br></pre></td></tr></table></figure>

<p><strong>最大值</strong>：数组中的<code>max</code>方法，可以获取到数组中的最大的那个元素值</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> a = <span class="type">Array</span>(<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">10</span>)</span><br><span class="line">scala&gt; a.max</span><br></pre></td></tr></table></figure>

<p><strong>最小值</strong>：数组的<code>min</code>方法，可以获取到数组中最小的那个元素值</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> a = <span class="type">Array</span>(<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">10</span>)</span><br><span class="line">scala&gt; a.min</span><br></pre></td></tr></table></figure>

<p><strong>排序</strong>：<code>sorted</code>方法，将数组进行升序排序；<code>reverse</code>方法，将数组进行反转，实现降序排序</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> a = <span class="type">Array</span>(<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">10</span>)</span><br><span class="line">scala&gt; a.sorted</span><br><span class="line">scala&gt; a.sorted.reverse</span><br></pre></td></tr></table></figure>

<h3 id="11-元组"><a href="#11-元组" class="headerlink" title="11 元组"></a>11 元组</h3><p>元组可以用来包含一组不同类型的值。例如：姓名，年龄，性别，出生年月。元组的元素是不可变的。语法定义：</p>
<ol>
<li><p>使用括号来定义元组</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span>/<span class="keyword">var</span> 元组 = (元素<span class="number">1</span>, 元素<span class="number">2</span>, 元素<span class="number">3.</span>...)</span><br></pre></td></tr></table></figure></li>
<li><p>使用箭头来定义元组（元组只有两个元素）</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span>/<span class="keyword">var</span> 元组 = 元素<span class="number">1</span>-&gt;元素<span class="number">2</span></span><br></pre></td></tr></table></figure></li>
</ol>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> a = (<span class="string">&quot;zhangsan&quot;</span>, <span class="number">20</span>)</span><br><span class="line">scala&gt; <span class="keyword">val</span> a = <span class="string">&quot;zhangsan&quot;</span> -&gt; <span class="number">20</span></span><br></pre></td></tr></table></figure>

<p><strong>访问元组</strong></p>
<p>使用_1、_2、_3….来访问元组中的元素，_1表示访问第一个元素，依次类推.</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> a = <span class="string">&quot;zhangsan&quot;</span> -&gt; <span class="string">&quot;male&quot;</span></span><br><span class="line">scala&gt; a._1</span><br><span class="line">scala&gt; a._2</span><br></pre></td></tr></table></figure>

<h3 id="12-List"><a href="#12-List" class="headerlink" title="12 List"></a>12 List</h3><p>列表是scala中最重要的、也是最常用的数据结构。List具备以下性质：可以保存重复的值，有先后顺序。在scala中，也有两种列表，一种是不可变列表、另一种是可变列表。</p>
<h4 id="1-1-不可变列表"><a href="#1-1-不可变列表" class="headerlink" title="1.1 不可变列表"></a>1.1 不可变列表</h4><p>不可变列表就是列表的元素、长度都是不可变的。使用<code>List(元素1, 元素2, 元素3, ...)</code>来创建一个不可变列表，语法格式：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span>/<span class="keyword">var</span> 变量名 = <span class="type">List</span>(元素<span class="number">1</span>, 元素<span class="number">2</span>, 元素<span class="number">3.</span>..)</span><br></pre></td></tr></table></figure>

<p>使用<code>Nil</code>创建一个不可变的空列表</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span>/<span class="keyword">var</span> 变量名 = <span class="type">Nil</span></span><br></pre></td></tr></table></figure>

<p>使用<code>::</code>方法创建一个不可变列表</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span>/<span class="keyword">var</span> 变量名 = 元素<span class="number">1</span> :: 元素<span class="number">2</span> :: <span class="type">Nil</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：使用<code>::</code>拼接方式来创建列表，必须在最后添加一个<code>Nil</code></p>
</blockquote>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 示例一：创建一个不可变列表，存放以下几个元素（1,2,3,4）*/</span></span><br><span class="line">scala&gt; <span class="keyword">val</span> a = <span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"><span class="comment">/* 示例二：使用Nil创建一个不可变的空列表 */</span></span><br><span class="line">scala&gt; <span class="keyword">val</span> a = <span class="type">Nil</span></span><br><span class="line"><span class="comment">/* 示例三：使用::方法创建列表，包含-2、-1两个元素 */</span></span><br><span class="line">scala&gt; <span class="keyword">val</span> a = <span class="number">-2</span> :: <span class="number">-1</span> :: <span class="type">Nil</span></span><br></pre></td></tr></table></figure>

<h4 id="1-2-可变列表"><a href="#1-2-可变列表" class="headerlink" title="1.2 可变列表"></a>1.2 可变列表</h4><p>可变列表就是列表的元素、长度都是可变的。</p>
<p>要使用可变列表，先要导入<code>import scala.collection.mutable.ListBuffer</code>。</p>
<blockquote>
<p>注意：可变集合都在<code>mutable</code>包中，不可变集合都在<code>immutable</code>包中（默认导入）</p>
</blockquote>
<p>使用<code>ListBuffer[元素类型]()</code>创建空的可变列表，语法结构：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span>/<span class="keyword">var</span> 变量名 = <span class="type">ListBuffer</span>[<span class="type">Int</span>]()</span><br></pre></td></tr></table></figure>

<p>使用<code>ListBuffer(元素1, 元素2, 元素3...)</code>创建可变列表，语法结构：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span>/<span class="keyword">var</span> 变量名 = <span class="type">ListBuffer</span>(元素<span class="number">1</span>，元素<span class="number">2</span>，元素<span class="number">3.</span>..)</span><br></pre></td></tr></table></figure>

<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 示例一：创建空的整形可变列表 */</span></span><br><span class="line">scala&gt; <span class="keyword">val</span> a = <span class="type">ListBuffer</span>[<span class="type">Int</span>]()</span><br><span class="line"><span class="comment">/* 示例二：创建一个可变列表，包含以下元素：1,2,3,4 */</span></span><br><span class="line">scala&gt; <span class="keyword">val</span> a = <span class="type">ListBuffer</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br></pre></td></tr></table></figure>

<p><strong>可变列表操作</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入可变列表</span></span><br><span class="line">scala&gt; <span class="keyword">import</span> scala.collection.mutable.<span class="type">ListBuffer</span></span><br><span class="line"><span class="comment">// 创建可变列表</span></span><br><span class="line">scala&gt; <span class="keyword">val</span> a = <span class="type">ListBuffer</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"><span class="comment">// 获取第一个元素</span></span><br><span class="line">scala&gt; a(<span class="number">0</span>)</span><br><span class="line"><span class="comment">// 追加一个元素</span></span><br><span class="line">scala&gt; a += <span class="number">4</span></span><br><span class="line"><span class="comment">// 追加一个列表</span></span><br><span class="line">scala&gt; a ++= <span class="type">List</span>(<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>)</span><br><span class="line"><span class="comment">// 删除元素</span></span><br><span class="line">scala&gt; a -= <span class="number">7</span></span><br><span class="line"><span class="comment">// 转换为不可变列表</span></span><br><span class="line">scala&gt; a.toList</span><br><span class="line"><span class="comment">// 转换为数组</span></span><br><span class="line">scala&gt; a.toArray</span><br></pre></td></tr></table></figure>

<h4 id="1-3-列表的常用操作"><a href="#1-3-列表的常用操作" class="headerlink" title="1.3 列表的常用操作"></a>1.3 列表的常用操作</h4><p><strong>判断列表是否为空</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> a = <span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">scala&gt; a.isEmpty</span><br></pre></td></tr></table></figure>

<p><strong>拼接两个列表</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> a = <span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">scala&gt; <span class="keyword">val</span> b = <span class="type">List</span>(<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)</span><br><span class="line">scala&gt; a ++ b</span><br></pre></td></tr></table></figure>

<p><strong>获取列表的首个元素和剩余部分</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> a = <span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">scala&gt; a.head</span><br><span class="line">scala&gt; a.tail</span><br></pre></td></tr></table></figure>

<p><strong>反转列表</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> a = <span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">scala&gt; a.reverse</span><br></pre></td></tr></table></figure>

<p><strong>获取列表前缀和后缀</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> a = <span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line">scala&gt; a.take(<span class="number">3</span>)</span><br><span class="line">scala&gt; a.drop(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<p><strong>扁平化(压平)</strong></p>
<p>扁平化表示将列表中的列表中的所有元素放到一个列表中。</p>


<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> a = <span class="type">List</span>(<span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>), <span class="type">List</span>(<span class="number">3</span>), <span class="type">List</span>(<span class="number">4</span>,<span class="number">5</span>))</span><br><span class="line">scala&gt; a.flatten</span><br></pre></td></tr></table></figure>

<p><strong>拉链与拉开</strong></p>
<ul>
<li>拉链zip：使用zip将两个列表，组合成一个元素为元组的列表</li>
<li>拉开unzip：将一个包含元组的列表，解开成包含两个列表的元组</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> a = <span class="type">List</span>(<span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;lisi&quot;</span>, <span class="string">&quot;wangwu&quot;</span>)</span><br><span class="line">scala&gt; <span class="keyword">val</span> b = <span class="type">List</span>(<span class="number">19</span>, <span class="number">20</span>, <span class="number">21</span>)</span><br><span class="line">scala&gt; a.zip(b)</span><br></pre></td></tr></table></figure>

<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; res1.unzip</span><br></pre></td></tr></table></figure>

<p><strong>转换字符串</strong></p>
<p>toString方法可以返回List中的所有元素</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> a = <span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">scala&gt; println(a.toString)</span><br></pre></td></tr></table></figure>

<p><strong>生成字符串</strong></p>
<p>mkString方法，可以将元素以分隔符拼接起来。默认没有分隔符</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> a = <span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">scala&gt; a.mkString</span><br><span class="line">scala&gt; a.mkString(<span class="string">&quot;:&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>并集</strong></p>
<p>union表示对两个列表取并集，不去重</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> a1 = <span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">scala&gt; <span class="keyword">val</span> a2 = <span class="type">List</span>(<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)</span><br><span class="line"><span class="comment">// 并集操作</span></span><br><span class="line">scala&gt; a1.union(a2)</span><br><span class="line"><span class="comment">// 可以调用distinct去重</span></span><br><span class="line">scala&gt; a1.union(a2).distinct</span><br></pre></td></tr></table></figure>

<p><strong>交集</strong></p>
<p>intersect表示对两个列表取交集</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> a1 = <span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">scala&gt; <span class="keyword">val</span> a2 = <span class="type">List</span>(<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)</span><br><span class="line">scala&gt; a1.intersect(a2)</span><br></pre></td></tr></table></figure>

<p><strong>差集</strong></p>
<p>diff表示对两个列表取差集，例如： a1.diff(a2)，表示获取a1在a2中不存在的元素</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> a1 = <span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">scala&gt; <span class="keyword">val</span> a2 = <span class="type">List</span>(<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)</span><br><span class="line">scala&gt; a1.diff(a2)</span><br></pre></td></tr></table></figure>

<h3 id="13-Set"><a href="#13-Set" class="headerlink" title="13 Set"></a>13 Set</h3><p>Set(集)是代表没有重复元素的集合。Set具备两个性质：1. 元素不重复；2. 不保证插入顺序。scala中的集也分为两种，一种是不可变集，另一种是可变集。</p>
<h4 id="1-1-不可变集"><a href="#1-1-不可变集" class="headerlink" title="1.1 不可变集"></a>1.1 不可变集</h4><p>创建一个空的不可变集，语法格式：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span>/<span class="keyword">var</span> 变量名 = <span class="type">Set</span>[类型]()</span><br></pre></td></tr></table></figure>

<p>给定元素来创建一个不可变集，语法格式：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span>/<span class="keyword">var</span> 变量名 = <span class="type">Set</span>(元素<span class="number">1</span>, 元素<span class="number">2</span>, 元素<span class="number">3.</span>..)</span><br></pre></td></tr></table></figure>

<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 示例一：定义一个空的不可变集 */</span></span><br><span class="line">scala&gt; <span class="keyword">val</span> a = <span class="type">Set</span>[<span class="type">Int</span>]()</span><br><span class="line"><span class="comment">/* 示例二：定义一个不可变集，保存以下元素：1,1,3,2,4,8 */</span></span><br><span class="line">scala&gt; <span class="keyword">val</span> a = <span class="type">Set</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">8</span>)</span><br></pre></td></tr></table></figure>

<p><strong>基本操作</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建集</span></span><br><span class="line">scala&gt; <span class="keyword">val</span> a = <span class="type">Set</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line"><span class="comment">// 获取集的大小</span></span><br><span class="line">scala&gt; a.size</span><br><span class="line"><span class="comment">// 遍历集</span></span><br><span class="line">scala&gt; <span class="keyword">for</span>(i &lt;- a) println(i)</span><br><span class="line"><span class="comment">// 删除一个元素</span></span><br><span class="line">scala&gt; a - <span class="number">1</span></span><br><span class="line"><span class="comment">// 拼接两个集</span></span><br><span class="line">scala&gt; a ++ <span class="type">Set</span>(<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>)</span><br><span class="line"><span class="comment">// 拼接集和列表</span></span><br><span class="line">scala&gt; a ++ <span class="type">List</span>(<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>)</span><br></pre></td></tr></table></figure>

<h4 id="1-2-可变集"><a href="#1-2-可变集" class="headerlink" title="1.2 可变集"></a>1.2 可变集</h4><p>可变集合和不可变集的创建方式一致，只不过需要提前导入一个可变集类。</p>
<p>手动导入：<code>import scala.collection.mutable.Set</code></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> a = <span class="type">Set</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"><span class="comment">// 添加元素</span></span><br><span class="line">scala&gt; a += <span class="number">5</span></span><br><span class="line"><span class="comment">// 删除元素</span></span><br><span class="line">scala&gt; a -= <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h3 id="14-Map"><a href="#14-Map" class="headerlink" title="14 Map"></a>14 Map</h3><p>Map可以称之为映射。它是由键值对组成的集合。在scala中，Map也分为不可变Map和可变Map。</p>
<h4 id="1-1-不可变Map"><a href="#1-1-不可变Map" class="headerlink" title="1.1 不可变Map"></a>1.1 不可变Map</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span>/<span class="keyword">var</span> map = <span class="type">Map</span>(键-&gt;值, 键-&gt;值, 键-&gt;值...)	<span class="comment">// 推荐，可读性更好</span></span><br><span class="line"><span class="keyword">val</span>/<span class="keyword">var</span> map = <span class="type">Map</span>((键, 值), (键, 值), (键, 值), (键, 值)...)</span><br></pre></td></tr></table></figure>

<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> map = <span class="type">Map</span>(<span class="string">&quot;zhangsan&quot;</span>-&gt;<span class="number">30</span>, <span class="string">&quot;lisi&quot;</span>-&gt;<span class="number">40</span>)</span><br><span class="line">scala&gt; <span class="keyword">val</span> map = <span class="type">Map</span>((<span class="string">&quot;zhangsan&quot;</span>, <span class="number">30</span>), (<span class="string">&quot;lisi&quot;</span>, <span class="number">30</span>))</span><br><span class="line"><span class="comment">/* 根据key获取value */</span></span><br><span class="line">scala&gt; map(<span class="string">&quot;zhangsan&quot;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="1-2-可变Map"><a href="#1-2-可变Map" class="headerlink" title="1.2 可变Map"></a>1.2 可变Map</h4><p>定义语法与不可变Map一致。但定义可变Map需要手动导入<code>import scala.collection.mutable.Map</code></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> map = <span class="type">Map</span>(<span class="string">&quot;zhangsan&quot;</span>-&gt;<span class="number">30</span>, <span class="string">&quot;lisi&quot;</span>-&gt;<span class="number">40</span>)</span><br><span class="line"><span class="comment">/* 修改value */</span></span><br><span class="line">scala&gt; map(<span class="string">&quot;zhangsan&quot;</span>) = <span class="number">20</span></span><br></pre></td></tr></table></figure>

<h3 id="15-iterator"><a href="#15-iterator" class="headerlink" title="15 iterator"></a>15 iterator</h3><p>scala针对每一类集合都提供了一个迭代器（iterator）用来迭代访问集合。</p>
<p><strong>使用迭代器遍历集合</strong></p>
<p>使用<code>iterator</code>方法可以从集合获取一个迭代器，迭代器的两个基本操作：</p>
<ul>
<li><code>hasNext</code>——查询容器中是否有下一个元素</li>
<li><code>next</code>——返回迭代器的下一个元素，如果没有，抛出NoSuchElementException</li>
</ul>
<p>每一个迭代器都是有状态的；迭代完后保留在最后一个元素的位置，再次使用则抛出NoSuchElementException；可以使用while或者for来逐个返回元素。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> a = <span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line">scala&gt; <span class="keyword">val</span> ite = a.iterator</span><br><span class="line">scala&gt; <span class="keyword">while</span>(ite.hasNext) &#123;</span><br><span class="line">     | println(ite.next)</span><br><span class="line">     | &#125;</span><br><span class="line">scala&gt; <span class="keyword">for</span>(i &lt;- a) println(i)</span><br></pre></td></tr></table></figure>

<h3 id="16-函数式编程"><a href="#16-函数式编程" class="headerlink" title="16 函数式编程"></a>16 函数式编程</h3><h4 id="1-1-foreach"><a href="#1-1-foreach" class="headerlink" title="1.1 foreach"></a>1.1 foreach</h4><p>使用<code>foreach</code>方法来进行遍历、迭代，它可以让代码更加简洁。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foreach(f: (<span class="type">A</span>) ⇒ <span class="type">Unit</span>): <span class="type">Unit</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>foreach</th>
<th>API</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>参数</td>
<td>f: (A) ⇒ Unit</td>
<td>接收一个函数对象<br />函数的输入参数为集合的元素，返回值为空</td>
</tr>
<tr>
<td>返回值</td>
<td>Unit</td>
<td>空</td>
</tr>
</tbody></table>
<p>示例：有一个列表，包含以下元素1,2,3,4，使用foreach方法遍历打印每个元素</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> a = <span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">scala&gt; a.foreach((x:<span class="type">Int</span>)=&gt;println(x))</span><br></pre></td></tr></table></figure>

<p>上述案例函数定义有点啰嗦，因为使用foreach去迭代列表，而列表中的每个元素类型是确定的：scala可以自动来推断出来集合中每个元素参数的类型，创建函数时，可以省略其参数列表的类型。如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; a.foreach(x=&gt;println(x))</span><br></pre></td></tr></table></figure>

<p>当函数参数，只在函数体中出现一次，而且函数体没有嵌套调用时，可以使用下划线来简化函数定义</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; a.foreach(println(_))</span><br></pre></td></tr></table></figure>

<p>如果方法参数是函数，如果出现了下划线，scala编译器会自动将代码封装到一个函数中，参数列表也是由scala编译器自动处理。</p>
<h4 id="1-2-Map"><a href="#1-2-Map" class="headerlink" title="1.2 Map"></a>1.2 Map</h4><p>map方法接收一个函数，将这个函数应用到每一个元素，返回一个新的列表</p>


<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">map</span></span>[<span class="type">B</span>](f: (<span class="type">A</span>) ⇒ <span class="type">B</span>): <span class="type">TraversableOnce</span>[<span class="type">B</span>]</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>map方法</th>
<th>API</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>泛型</td>
<td>[B]</td>
<td>指定map方法最终返回的集合泛型</td>
</tr>
<tr>
<td>参数</td>
<td>f: (A) ⇒ B</td>
<td>传入一个函数对象<br/>该函数接收一个类型A（要转换的列表元素），返回值为类型B</td>
</tr>
<tr>
<td>返回值</td>
<td>TraversableOnce[B]</td>
<td>B类型的集合</td>
</tr>
</tbody></table>
<p><strong>map方法解析</strong></p>


<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> a = <span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">scala&gt; a.map(x=&gt;x+<span class="number">1</span>)</span><br><span class="line"><span class="comment">/* 或者 */</span></span><br><span class="line">scala&gt; a.map(_ + <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<h4 id="1-3-flatMap"><a href="#1-3-flatMap" class="headerlink" title="1.3 flatMap"></a>1.3 flatMap</h4><p>扁平化映射可以把flatMap，理解为先map，然后再flatten。</p>


<ul>
<li>map是将列表中的<strong>元素转换为一个List</strong></li>
<li>flatten再将整个列表进行扁平化</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">flatMap</span></span>[<span class="type">B</span>](f: (<span class="type">A</span>) ⇒ <span class="type">GenTraversableOnce</span>[<span class="type">B</span>]): <span class="type">TraversableOnce</span>[<span class="type">B</span>]</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>flatmap方法</th>
<th>API</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>泛型</td>
<td>[B]</td>
<td>最终要转换的集合元素类型</td>
</tr>
<tr>
<td>参数</td>
<td>f: (A) ⇒ GenTraversableOnce[B]</td>
<td>传入一个函数对象<br />函数的参数是集合的元素<br />函数的返回值是一个集合</td>
</tr>
<tr>
<td>返回值</td>
<td>TraversableOnce[B]</td>
<td>B类型的集合</td>
</tr>
</tbody></table>
<p><strong>示例</strong></p>
<ol>
<li>有一个包含了若干个文本行的列表：”hadoop hive spark flink flume”, “kudu hbase sqoop storm”</li>
<li>获取到文本行中的每一个单词，并将每一个单词都放到列表中</li>
</ol>


<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> a = <span class="type">List</span>(<span class="string">&quot;hadoop hive spark flink flume&quot;</span>, <span class="string">&quot;kudu hbase sqoop storm&quot;</span>)</span><br><span class="line">scala&gt; a.map(x=&gt;x.split(<span class="string">&quot; &quot;</span>))</span><br><span class="line">scala&gt; a.map(x=&gt;x.split(<span class="string">&quot; &quot;</span>)).flatten</span><br><span class="line"><span class="comment">/* 简化操作 */</span></span><br><span class="line">scala&gt; a.flatMap(_.split(<span class="string">&quot; &quot;</span>))</span><br></pre></td></tr></table></figure>

<h4 id="1-4-filter"><a href="#1-4-filter" class="headerlink" title="1.4 filter"></a>1.4 filter</h4><p>过滤符合一定条件的元素</p>


<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>).filter(_ % <span class="number">2</span> == <span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<h4 id="1-5-排序"><a href="#1-5-排序" class="headerlink" title="1.5 排序"></a>1.5 排序</h4><p>在scala集合中，可以使用以下几种方式来进行排序</p>
<p><strong>默认排序 | sorted</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="type">List</span>(<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">9</span>,<span class="number">7</span>).sorted</span><br></pre></td></tr></table></figure>

<p><strong>指定字段排序 | sortBy</strong>：根据传入的函数转换后，再进行排序</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sortBy</span></span>[<span class="type">B</span>](f: (<span class="type">A</span>) ⇒ <span class="type">B</span>): <span class="type">List</span>[<span class="type">A</span>]</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>sortBy方法</th>
<th>API</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>泛型</td>
<td>[B]</td>
<td>按照什么类型来进行排序</td>
</tr>
<tr>
<td>参数</td>
<td>f: (A) ⇒ B</td>
<td>传入函数对象<br />接收一个集合类型的元素参数<br />返回B类型的元素进行排序</td>
</tr>
<tr>
<td>返回值</td>
<td>List[A]</td>
<td>返回排序后的列表</td>
</tr>
</tbody></table>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> a = <span class="type">List</span>(<span class="string">&quot;01 hadoop&quot;</span>, <span class="string">&quot;02 flume&quot;</span>, <span class="string">&quot;03 hive&quot;</span>, <span class="string">&quot;04 spark&quot;</span>)</span><br><span class="line">scala&gt; a.sortBy(_.split(<span class="string">&quot; &quot;</span>)(<span class="number">1</span>))</span><br></pre></td></tr></table></figure>

<p><strong>自定义排序 | sortWith</strong>：自定义排序，根据一个函数来进行自定义排序</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sortWith</span></span>(lt: (<span class="type">A</span>, <span class="type">A</span>) ⇒ <span class="type">Boolean</span>): <span class="type">List</span>[<span class="type">A</span>]</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>sortWith方法</th>
<th>API</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>参数</td>
<td>lt: (A, A) ⇒ Boolean</td>
<td>传入一个比较大小的函数对象<br />接收两个集合类型的元素参数<br />返回两个元素大小，小于返回true，大于返回false</td>
</tr>
<tr>
<td>返回值</td>
<td>List[A]</td>
<td>返回排序后的列表</td>
</tr>
</tbody></table>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> a = <span class="type">List</span>(<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line">scala&gt; a.sortWith((x,y) =&gt; <span class="keyword">if</span>(x&lt;y)<span class="literal">true</span> <span class="keyword">else</span> <span class="literal">false</span>)</span><br><span class="line">res21: <span class="type">List</span>[<span class="type">Int</span>] = <span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">scala&gt; res21.reverse</span><br><span class="line"><span class="comment">/* 简写 */</span></span><br><span class="line">scala&gt; a.sortWith(_ &lt; _).reverse</span><br></pre></td></tr></table></figure>

<h4 id="1-6-分组"><a href="#1-6-分组" class="headerlink" title="1.6 分组"></a>1.6 分组</h4><p>如果要将数据按照分组来进行统计分析，就需要使用到分组方法。groupBy表示按照函数将列表分成不同的组。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">groupBy</span></span>[<span class="type">K</span>](f: (<span class="type">A</span>) ⇒ <span class="type">K</span>): <span class="type">Map</span>[<span class="type">K</span>, <span class="type">List</span>[<span class="type">A</span>]]</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>groupBy方法</th>
<th>API</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>泛型</td>
<td>[K]</td>
<td>分组字段的类型</td>
</tr>
<tr>
<td>参数</td>
<td>f: (A) ⇒ K</td>
<td>传入一个函数对象<br />接收集合元素类型的参数<br />返回一个K类型的key，这个key会用来进行分组，相同的key放在一组中</td>
</tr>
<tr>
<td>返回值</td>
<td>Map[K, List[A]]</td>
<td>返回一个映射，K为分组字段，List为这个分组字段对应的一组数据</td>
</tr>
</tbody></table>
<p><strong>groupBy执行过程</strong></p>


<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> a = <span class="type">List</span>(<span class="string">&quot;张三&quot;</span>-&gt;<span class="string">&quot;男&quot;</span>, <span class="string">&quot;李四&quot;</span>-&gt;<span class="string">&quot;女&quot;</span>, <span class="string">&quot;王五&quot;</span>-&gt;<span class="string">&quot;男&quot;</span>)</span><br><span class="line"><span class="comment">// 按照性别分组</span></span><br><span class="line">scala&gt; a.groupBy(_._2)</span><br><span class="line"><span class="comment">// 将分组后的映射转换为性别/人数元组列表</span></span><br><span class="line">scala&gt; res0.map(x =&gt; x._1 -&gt; x._2.size)</span><br><span class="line">res3: scala.collection.immutable.<span class="type">Map</span>[<span class="type">String</span>,<span class="type">Int</span>] = <span class="type">Map</span>(男 -&gt; <span class="number">2</span>, 女 -&gt; <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<h4 id="1-7-聚合"><a href="#1-7-聚合" class="headerlink" title="1.7 聚合"></a>1.7 聚合</h4><p>聚合操作，可以将一个列表中的数据合并为一个。</p>
<p><strong>reduce</strong> ：reduce表示将列表，传入一个函数进行聚合计算</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reduce</span></span>[<span class="type">A1</span> &gt;: <span class="type">A</span>](op: (<span class="type">A1</span>, <span class="type">A1</span>) ⇒ <span class="type">A1</span>): <span class="type">A1</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>reduce方法</th>
<th>API</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>泛型</td>
<td>[A1 &gt;: A]</td>
<td>（下界）A1必须是集合元素类型的子类</td>
</tr>
<tr>
<td>参数</td>
<td>op: (A1, A1) ⇒ A1</td>
<td>传入函数对象，用来不断进行聚合操作<br />第一个A1类型参数为：当前聚合后的变量<br />第二个A1类型参数为：当前要进行聚合的元素</td>
</tr>
<tr>
<td>返回值</td>
<td>A1</td>
<td>列表最终聚合为一个元素</td>
</tr>
</tbody></table>
<p>reduce执行流程</p>


<blockquote>
<p>注意：reduce和reduceLeft效果一致，表示从左到右计算，reduceRight表示从右到左计算</p>
</blockquote>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> a = <span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>)</span><br><span class="line"><span class="comment">// 计算所有元素的和</span></span><br><span class="line">scala&gt; a.reduce((x,y) =&gt; x + y)</span><br><span class="line"><span class="comment">// 第一个下划线表示第一个参数，就是历史的聚合数据结果</span></span><br><span class="line"><span class="comment">// 第二个下划线表示第二个参数，就是当前要聚合的数据元素</span></span><br><span class="line">scala&gt; a.reduce(_ + _)</span><br><span class="line"><span class="comment">// 与reduce一样，从左往右计算</span></span><br><span class="line">scala&gt; a.reduceLeft(_ + _)</span><br><span class="line"><span class="comment">// 从右往左聚合计算</span></span><br><span class="line">scala&gt; a.reduceRight(_ + _)</span><br></pre></td></tr></table></figure>

<p><strong>fold</strong> ：fold与reduce很像，但是多了一个指定初始值参数</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fold</span></span>[<span class="type">A1</span> &gt;: <span class="type">A</span>](z: <span class="type">A1</span>)(op: (<span class="type">A1</span>, <span class="type">A1</span>) ⇒ <span class="type">A1</span>): <span class="type">A1</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>reduce方法</th>
<th>API</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>泛型</td>
<td>[A1 &gt;: A]</td>
<td>（下界）A1必须是集合元素类型的子类</td>
</tr>
<tr>
<td>参数1</td>
<td>z: A1</td>
<td>初始值</td>
</tr>
<tr>
<td>参数2</td>
<td>op: (A1, A1) ⇒ A1</td>
<td>传入函数对象，用来不断进行折叠操作<br />第一个A1类型参数为：当前折叠后的变量<br />第二个A1类型参数为：当前要进行折叠的元素</td>
</tr>
<tr>
<td>返回值</td>
<td>A1</td>
<td>列表最终折叠为一个元素</td>
</tr>
</tbody></table>
<blockquote>
<p>注意：fold和foldLet效果一致，表示从左往右计算，foldRight表示从右往左计算</p>
</blockquote>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> a = <span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>)</span><br><span class="line">scala&gt; a.fold(<span class="number">0</span>)(_ + _)</span><br></pre></td></tr></table></figure>

<h2 id="三、面向对象"><a href="#三、面向对象" class="headerlink" title="三、面向对象"></a>三、面向对象</h2><p>scala是支持面向对象的，也有类和对象的概念；依然可以基于scala语言来开发面向对象的应用程序。</p>
<h3 id="1-类和对象"><a href="#1-类和对象" class="headerlink" title="1 类和对象"></a>1 类和对象</h3><h4 id="1-1-创建类和对象"><a href="#1-1-创建类和对象" class="headerlink" title="1.1 创建类和对象"></a>1.1 创建类和对象</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ClassDemo</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 创建类</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">// 创建对象</span></span><br><span class="line">    <span class="keyword">val</span> p = <span class="keyword">new</span> <span class="type">Person</span>()</span><br><span class="line">    println(p)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>简写方式</strong></p>
<ul>
<li><p>如果类是空的，没有任何成员，可以省略<code>&#123;&#125;</code></p>
</li>
<li><p>如果构造器的参数为空，可以省略<code>()</code></p>
</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ClassDemo</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 创建类，省略花括号</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">  <span class="title">def</span> <span class="title">main</span>(<span class="params">args: <span class="type">Array</span>[<span class="type">String</span>]</span>)</span>: <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">// 创建对象，省略括号</span></span><br><span class="line">    <span class="keyword">val</span> person = <span class="keyword">new</span> <span class="type">Person</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-2-定义和访问成员变量"><a href="#1-2-定义和访问成员变量" class="headerlink" title="1.2 定义和访问成员变量"></a>1.2 定义和访问成员变量</h4><p>一个类会有自己的属性，例如：人这样一个类，有自己的姓名和年龄。具体用法如下：</p>
<ul>
<li>在类中使用<code>var/val</code>来定义成员变量</li>
<li>对象直接使用成员变量名称来访问成员变量</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ClassDemo</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义成员变量</span></span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">var</span> age = <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">// 创建Person对象</span></span><br><span class="line">    <span class="keyword">val</span> person = <span class="keyword">new</span> <span class="type">Person</span></span><br><span class="line">    person.name = <span class="string">&quot;zhangsan&quot;</span></span><br><span class="line">    person.age = <span class="number">20</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取变量值</span></span><br><span class="line">    println(person.name)</span><br><span class="line">    println(person.age)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-3-使用下划线初始化成员变量"><a href="#1-3-使用下划线初始化成员变量" class="headerlink" title="1.3 使用下划线初始化成员变量"></a>1.3 使用下划线初始化成员变量</h4><p>scala中有一个更简洁的初始化成员变量的方式，可以让代码看起来更加简洁，用法如下：</p>
<ul>
<li>在定义<code>var</code>类型的成员变量时，可以使用<code>_</code>来初始化成员变量；</li>
<li><code>val</code>类型的成员变量，必须要自己手动初始化；</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ClassDemo</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="comment">// 使用下划线进行初始化</span></span><br><span class="line">    <span class="keyword">var</span> name:<span class="type">String</span> = _</span><br><span class="line">    <span class="keyword">var</span> age:<span class="type">Int</span> = _</span><br><span class="line">    <span class="keyword">val</span> sign:<span class="type">Boolean</span> = <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> person = <span class="keyword">new</span> <span class="type">Person</span></span><br><span class="line">    </span><br><span class="line">    println(person.name)</span><br><span class="line">    println(person.age)</span><br><span class="line">    println(person.sign)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-4-定义成员方法"><a href="#1-4-定义成员方法" class="headerlink" title="1.4 定义成员方法"></a>1.4 定义成员方法</h4><p>类可以有自己的行为，scala中也可以通过定义成员方法来定义类的行为。在scala的类中，也是使用<code>def</code>来定义成员方法。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ClassDemo</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name:<span class="type">String</span> = _</span><br><span class="line">    <span class="keyword">var</span> sex:<span class="type">String</span> = _</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义成员方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sayHi</span></span>(msg:<span class="type">String</span>) = &#123;</span><br><span class="line">      println(msg)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> customer = <span class="keyword">new</span> <span class="type">Customer</span></span><br><span class="line">    customer.name = <span class="string">&quot;张三&quot;</span></span><br><span class="line">    customer.sex = <span class="string">&quot;男&quot;</span></span><br><span class="line">    customer.sayHi(<span class="string">&quot;你好&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-5-成员访问修饰符"><a href="#1-5-成员访问修饰符" class="headerlink" title="1.5 成员访问修饰符"></a>1.5 成员访问修饰符</h4><p>和Java一样，scala也可以通过访问修饰符，来控制成员变量和成员方法是否可以被访问。Java中的访问控制，同样适用于scala，可以在成员前面添加<code>private/protected</code>关键字来控制成员的可见性。但在scala中<strong>没有public关键字</strong>，任何没有被标为private或protected的成员都是公共的。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">AccessDemo</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义私有成员变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> name:<span class="type">String</span> = _</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> age:<span class="type">Int</span> = _</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getName</span></span>() = name</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setName</span></span>(name:<span class="type">String</span>) = <span class="keyword">this</span>.name = name</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getAge</span></span>() = age</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setAge</span></span>(age:<span class="type">Int</span>) = <span class="keyword">this</span>.age = age</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义私有成员方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">getNameAndAge</span> </span>= &#123;</span><br><span class="line">      name -&gt; age</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> person = <span class="keyword">new</span> <span class="type">Person</span></span><br><span class="line">    person.setName(<span class="string">&quot;张三&quot;</span>)</span><br><span class="line">    person.setAge(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    println(person.getName())</span><br><span class="line">    println(person.getAge())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-构造器"><a href="#2-构造器" class="headerlink" title="2 构造器"></a>2 构造器</h3><p>当创建类对象的时候，会自动调用类的构造器。</p>
<h4 id="1-1-主构造器"><a href="#1-1-主构造器" class="headerlink" title="1.1 主构造器"></a>1.1 主构造器</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">类名</span>(<span class="params">var/val 参数名:类型 = 默认值, var/val 参数名:类型 = 默认值</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 构造代码块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主构造器的参数列表是直接定义在类名后面，添加了val/var表示直接通过主构造器定义成员变量；构造器参数列表可以指定默认值；创建实例，调用构造器可以指定字段进行初始化；整个class中除了字段定义和方法定义的代码都是构造代码。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ConstructorDemo</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params">var name:<span class="type">String</span> = &quot;&quot;, var age:<span class="type">Int</span> = 0</span>) </span>&#123;</span><br><span class="line">    println(<span class="string">&quot;调用主构造器&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> zhangsan = <span class="keyword">new</span> <span class="type">Person</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">20</span>)</span><br><span class="line">    println(zhangsan.name)</span><br><span class="line">    println(zhangsan.age)</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;---&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不传入任何参数</span></span><br><span class="line">    <span class="keyword">val</span> empty = <span class="keyword">new</span> <span class="type">Person</span></span><br><span class="line">    println(empty.name)</span><br><span class="line">    println(empty.age)</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;---&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指定字段进行初始化</span></span><br><span class="line">    <span class="keyword">val</span> man40 = <span class="keyword">new</span> <span class="type">Person</span>(age = <span class="number">40</span>)</span><br><span class="line">    println(man40.name)</span><br><span class="line">    println(man40.age)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-2-辅助构造器"><a href="#1-2-辅助构造器" class="headerlink" title="1.2 辅助构造器"></a>1.2 辅助构造器</h4><p>在scala中，除了定义主构造器外，还可以根据需要来定义辅助构造器。例如：允许通过多种方式，来创建对象，这时候就可以定义其他更多的构造器，把除了主构造器之外的构造器称为<strong>辅助构造器</strong>。具体语法如下：</p>
<ul>
<li>定义辅助构造器与定义方法一样，也使用<code>def</code>关键字来定义</li>
<li>这个方法的名字为<code>this</code></li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">this</span></span>(参数名:类型, 参数名:类型) &#123;</span><br><span class="line">    <span class="comment">// 第一行需要调用主构造器或者其他构造器</span></span><br><span class="line">    <span class="comment">// 构造器代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：辅助构造器的第一行代码，必须要<strong>调用主构造器或者其他辅助构造器</strong></p>
</blockquote>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ConstructorDemo</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Customer</span>(<span class="params">var name:<span class="type">String</span> = &quot;&quot;, var address:<span class="type">String</span> = &quot;&quot;</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 定义辅助构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">this</span></span>(arr:<span class="type">Array</span>[<span class="type">String</span>]) = &#123;</span><br><span class="line">      <span class="comment">// 辅助构造器必须要调用主构造器或者其他辅助构造器</span></span><br><span class="line">      <span class="keyword">this</span>(arr(<span class="number">0</span>), arr(<span class="number">1</span>))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> zhangsan = <span class="keyword">new</span> <span class="type">Customer</span>(<span class="type">Array</span>(<span class="string">&quot;张三&quot;</span>, <span class="string">&quot;北京&quot;</span>))</span><br><span class="line"></span><br><span class="line">    println(zhangsan.name)</span><br><span class="line">    println(zhangsan.address)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-单例对象"><a href="#3-单例对象" class="headerlink" title="3 单例对象"></a>3 单例对象</h3><p>scala中没有Java中的静态成员，想要定义类似于Java的static变量、static方法，就要使用到scala中的单例对象——object。</p>
<h4 id="1-1-单例对象"><a href="#1-1-单例对象" class="headerlink" title="1.1 单例对象"></a>1.1 单例对象</h4><p>单例对象表示全局仅有一个对象(类似于Java static概念）；定义单例对象和定义类很像就是把class换成object；在object中定义的成员变量类似于Java的静态变量；可以使用object直接引用成员变量。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ObjectDemo</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 定义一个单例对象</span></span><br><span class="line">  <span class="class"><span class="keyword">object</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义腿的数量</span></span><br><span class="line">    <span class="keyword">val</span> <span class="type">LEG_NUM</span> = <span class="number">4</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    println(<span class="type">Dog</span>.<span class="type">LEG_NUM</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在object中定义的成员方法类似于Java的静态方法。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">_09ObjectDemo</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">  <span class="class"><span class="keyword">object</span> <span class="title">PrintUtil</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printSpliter</span></span>() = &#123;</span><br><span class="line">      <span class="comment">// 字符串乘法，表示返回多少个字符串</span></span><br><span class="line">      println(<span class="string">&quot;-&quot;</span> * <span class="number">10</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="type">PrintUtil</span>.printSpliter()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-2-main方法"><a href="#1-2-main方法" class="headerlink" title="1.2 main方法"></a>1.2 main方法</h4><p>scala和Java一样，如果要运行一个程序，必须有一个main方法；而在Java中main方法是静态的，而在scala中没有静态方法；在scala中，这个main方法必须放在一个单例对象中。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args:<span class="type">Array</span>[<span class="type">String</span>]):<span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">// 方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MainDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args:<span class="type">Array</span>[<span class="type">String</span>]) = &#123;</span><br><span class="line">    println(<span class="string">&quot;hello, scala&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>实现App Trait来定义入口</strong></p>
<p>创建一个object，继承自App Trait（特质），然后将需要编写在main方法中的代码，写在object的构造方法体内。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">单例对象名</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Main5</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">  println(<span class="string">&quot;hello, scala&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-伴生对象"><a href="#4-伴生对象" class="headerlink" title="4 伴生对象"></a>4 伴生对象</h3><p>在Java中，经常会有一些类，同时有实例成员又有静态成员。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomerService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String SERVICE_NAME = <span class="string">&quot;CustomerService&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 保存客户</span></span><br><span class="line">        System.out.println(SERVICE_NAME + <span class="string">&quot;:保存客户&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> CustomerService().save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在scala中，要实现类似的效果，可以使用伴生对象来实现；还可以使用伴生对象来实现快速创建对象，例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无需使用new就可以快速来创建对象</span></span><br><span class="line"><span class="keyword">val</span> a = <span class="type">Array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"><span class="keyword">val</span> b = <span class="type">Set</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<h4 id="1-1-定义伴生对象"><a href="#1-1-定义伴生对象" class="headerlink" title="1.1 定义伴生对象"></a>1.1 定义伴生对象</h4><p>一个class和object具有同样的名字。这个object称为<strong>伴生对象</strong>，这个class称为<strong>伴生类</strong></p>
<ul>
<li>伴生对象必须要和伴生类一样的名字</li>
<li>伴生对象和伴生类在同一个scala源文件中</li>
<li>伴生对象和伴生类可以互相访问private属性</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ObjectDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">CustomerService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">save</span></span>() = &#123;</span><br><span class="line">      println(<span class="string">s&quot;<span class="subst">$&#123;CustomerService.SERVICE_NAME&#125;</span>:保存客户&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// CustomerService的伴生对象</span></span><br><span class="line">  <span class="class"><span class="keyword">object</span> <span class="title">CustomerService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> <span class="type">SERVICE_NAME</span> = <span class="string">&quot;CustomerService&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> customerService = <span class="keyword">new</span> <span class="type">CustomerService</span>()</span><br><span class="line">    customerService.save()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-2-private-this-访问权限"><a href="#1-2-private-this-访问权限" class="headerlink" title="1.2 private[this]访问权限"></a>1.2 private[this]访问权限</h4><p>如果某个成员的权限设置为<code>private[this]</code>，表示只能在当前类中访问；伴生对象也不可以访问。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ObjectDemo</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params">private[this] var name:<span class="type">String</span></span>)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">    <span class="title">object</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">printPerson</span></span>(person:<span class="type">Person</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">            println(person.name) <span class="comment">//symbol name is inaccessible from this place</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">val</span> person = <span class="keyword">new</span> <span class="type">Person</span>(<span class="string">&quot;张三&quot;</span>)</span><br><span class="line">        <span class="type">Person</span>.printPerson(person)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码，会编译报错。但移除掉[this]就可以访问了。</p>
<h4 id="1-3-apply方法"><a href="#1-3-apply方法" class="headerlink" title="1.3 apply方法"></a>1.3 apply方法</h4><p>我们之前使用过这种方式来创建一个Array对象：<code>val a = Array(1,2,3,4)</code>；这种写法非常简便，不需要再写一个new，然后敲一个空格，再写类名。我们可以通过伴生对象的apply方法来实现。</p>
<p><strong>定义apply方法</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">伴生对象名</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(参数名:参数类型, 参数名:参数类型...) = <span class="keyword">new</span> 类(...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>创建对象</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">伴生对象名(参数<span class="number">1</span>, 参数<span class="number">2.</span>..)</span><br></pre></td></tr></table></figure>

<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ApplyDemo</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params">var name:<span class="type">String</span> = &quot;&quot;, var age:<span class="type">Int</span> = 0</span>)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">  <span class="title">object</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义apply方法，接收两个参数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(name:<span class="type">String</span>, age:<span class="type">Int</span>) = <span class="keyword">new</span> <span class="type">Person</span>(name, age)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">// 使用伴生对象名称来创建对象</span></span><br><span class="line">    <span class="keyword">val</span> zhangsan = <span class="type">Person</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">20</span>)</span><br><span class="line">    println(zhangsan.name)</span><br><span class="line">    println(zhangsan.age)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-继承"><a href="#5-继承" class="headerlink" title="5 继承"></a>5 继承</h3><p>scala语言是支持面向对象编程的，我们也可以使用scala来实现继承，通过继承来减少重复代码。</p>
<h4 id="1-1-定义语法"><a href="#1-1-定义语法" class="headerlink" title="1.1 定义语法"></a>1.1 定义语法</h4><p>scala和Java一样，使用<strong>extends</strong>关键字来实现继承；可以在子类中定义父类中没有的字段和方法，或者重写父类的方法；类和单例对象都可以从某个父类继承。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span><span class="title">/object</span> <span class="title">子类</span> <span class="keyword">extends</span> <span class="title">父类</span> </span>&#123;</span><br><span class="line">    ..</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-2-类继承"><a href="#1-2-类继承" class="headerlink" title="1.2 类继承"></a>1.2 类继承</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name:<span class="type">String</span> = _</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">getName</span> </span>= <span class="keyword">this</span>.name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">object</span> <span class="title">MainDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> p1 = <span class="keyword">new</span> <span class="type">Person</span>()</span><br><span class="line">    </span><br><span class="line">    p1.name = <span class="string">&quot;张三&quot;</span></span><br><span class="line">    println(p1.getName)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-3-单例对象继承"><a href="#1-3-单例对象继承" class="headerlink" title="1.3 单例对象继承"></a>1.3 单例对象继承</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name:<span class="type">String</span> = _</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">getName</span> </span>= <span class="keyword">this</span>.name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">object</span> <span class="title">MainDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="type">Student</span>.name = <span class="string">&quot;张三&quot;</span></span><br><span class="line">    println(<span class="type">Student</span>.getName)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-override和super"><a href="#6-override和super" class="headerlink" title="6 override和super"></a>6 override和super</h3><p>类似于Java语言，在子类中使用override来重写父类的成员，可以使用super来引用父类。</p>
<ul>
<li>子类要覆盖父类中的一个方法，必须要使用override关键字</li>
<li>使用override来重写一个val字段</li>
<li>使用super关键字来访问父类的成员方法</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> name = <span class="string">&quot;super&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">getName</span> </span>= name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 重写val字段</span></span><br><span class="line">  <span class="keyword">override</span> <span class="keyword">val</span> name: <span class="type">String</span> = <span class="string">&quot;child&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 重写getName方法</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">getName</span></span>: <span class="type">String</span> = <span class="string">&quot;hello, &quot;</span> + <span class="keyword">super</span>.getName</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MainDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    println(<span class="keyword">new</span> <span class="type">Student</span>().getName)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-类型判断"><a href="#7-类型判断" class="headerlink" title="7 类型判断"></a>7 类型判断</h3><p>有时候设计的程序要根据变量的类型来执行对应的逻辑。</p>


<p>在scala中，如何来进行类型判断呢？有两种方式：<code>isInstanceOf</code>、<code>getClass/classOf</code>。</p>
<h4 id="1-1-isInstanceof-asInstanceof"><a href="#1-1-isInstanceof-asInstanceof" class="headerlink" title="1.1 isInstanceof/asInstanceof"></a>1.1 isInstanceof/asInstanceof</h4><p>在Java中，我们可以使用instanceof关键字来判断类型、以及(类型)object来进行类型转换，在scala中如何实现呢？scala中对象提供<code>isInstanceOf</code>和<code>asInstanceOf</code>方法。</p>
<ul>
<li><code>isInstanceOf</code>判断对象是否为指定类的对象</li>
<li><code>asInstanceOf</code>将对象转换为指定类型</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断对象是否为指定类型</span></span><br><span class="line"><span class="keyword">val</span> trueOrFalse:<span class="type">Boolean</span> = 对象.isInstanceOf[类型]</span><br><span class="line"><span class="comment">// 将对象转换为指定类型</span></span><br><span class="line"><span class="keyword">val</span> 变量 = 对象.asInstanceOf[类型]</span><br></pre></td></tr></table></figure>

<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person3</span></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Student3</span> <span class="keyword">extends</span> <span class="title">Person3</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">object</span> <span class="title">MainDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> s1:<span class="type">Person3</span> = <span class="keyword">new</span> <span class="type">Student3</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断s1是否为Student3类型</span></span><br><span class="line">    <span class="keyword">if</span>(s1.isInstanceOf[<span class="type">Student3</span>]) &#123;</span><br><span class="line">      <span class="comment">// 将s1转换为Student3类型</span></span><br><span class="line">      <span class="keyword">val</span> s2 =  s1.asInstanceOf[<span class="type">Student3</span>]</span><br><span class="line">      println(s2)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-2-getClass和classOf"><a href="#1-2-getClass和classOf" class="headerlink" title="1.2 getClass和classOf"></a>1.2 getClass和classOf</h4><p>isInstanceOf 只能判断对象是否为<strong>指定类以及其子类</strong>的对象，而不能精确的判断出，对象就是指定类的对象。如果要求精确地判断出对象就是指定类的对象，那么就只能使用 <code>getClass</code> 和 <code>classOf </code>。</p>
<ul>
<li><code>p.getClass</code>可以精确获取对象的类型</li>
<li><code>classOf[x]</code>可以精确获取类型</li>
<li>使用<code>==</code>操作符可以直接比较类型</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person4</span></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Student4</span> <span class="keyword">extends</span> <span class="title">Person4</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">object</span> <span class="title">Student4</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) &#123;</span><br><span class="line">    <span class="keyword">val</span> p:<span class="type">Person4</span>=<span class="keyword">new</span> <span class="type">Student4</span></span><br><span class="line">    <span class="comment">//判断p是否为Person4类的实例</span></span><br><span class="line">    println(p.isInstanceOf[<span class="type">Person4</span>])<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断p的类型是否为Person4类</span></span><br><span class="line">    println(p.getClass == classOf[<span class="type">Person4</span>])<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断p的类型是否为Student4类</span></span><br><span class="line">    println(p.getClass == classOf[<span class="type">Student4</span>])<span class="comment">//true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-抽象类"><a href="#8-抽象类" class="headerlink" title="8 抽象类"></a>8 抽象类</h3><p>和Java语言一样，scala中也可以定义抽象类；如果类的某个成员在当前类中的定义是不包含完整的，它就是一个<strong>抽象类</strong>。不完整定义有两种情况：</p>
<ol>
<li>方法没有方法体（<strong>抽象方法</strong>）</li>
<li>变量没有初始化（<strong>抽象字段</strong>）</li>
</ol>
<p>定义抽象类和Java一样，在类前面加上<strong>abstract</strong>关键字</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义抽象类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">抽象类名</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 定义抽象字段</span></span><br><span class="line">  <span class="keyword">val</span> 抽象字段名:类型</span><br><span class="line">  <span class="comment">// 定义抽象方法</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">方法名</span></span>(参数:参数类型,参数:参数类型...):返回类型</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>抽象方法</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建形状抽象类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">area</span></span>:<span class="type">Double</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建正方形类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span>(<span class="params">var edge:<span class="type">Double</span> /*边长*/</span>) <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 实现父类计算面积的方法</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">area</span></span>: <span class="type">Double</span> = edge * edge</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建长方形类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span>(<span class="params">var length:<span class="type">Double</span> /*长*/, var width:<span class="type">Double</span> /*宽*/</span>) <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">area</span></span>: <span class="type">Double</span> = length * width</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建圆形类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cirle</span>(<span class="params">var radius:<span class="type">Double</span> /*半径*/</span>) <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">area</span></span>: <span class="type">Double</span> = <span class="type">Math</span>.<span class="type">PI</span> * radius * radius</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MainDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> s1:<span class="type">Shape</span> = <span class="keyword">new</span> <span class="type">Square</span>(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">val</span> s2:<span class="type">Shape</span> = <span class="keyword">new</span> <span class="type">Rectangle</span>(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">val</span> s3:<span class="type">Shape</span> = <span class="keyword">new</span> <span class="type">Cirle</span>(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    println(s1.area)</span><br><span class="line">    println(s2.area)</span><br><span class="line">    println(s3.area)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-匿名内部类"><a href="#9-匿名内部类" class="headerlink" title="9 匿名内部类"></a>9 匿名内部类</h3><p>匿名内部类是没有名称的子类，直接用来创建实例对象；scala中的匿名内部类使用与Java一致。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span>/<span class="keyword">var</span> 变量名 = <span class="keyword">new</span> 类/抽象类 &#123;</span><br><span class="line">    <span class="comment">// 重写方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Person7</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">sayHello</span></span>:<span class="type">Unit</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Main7</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">// 直接用new来创建一个匿名内部类对象</span></span><br><span class="line">    <span class="keyword">val</span> p1 = <span class="keyword">new</span> <span class="type">Person7</span> &#123;</span><br><span class="line">      <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">sayHello</span></span>: <span class="type">Unit</span> = println(<span class="string">&quot;我是一个匿名内部类&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    p1.sayHello</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="10-特质trait"><a href="#10-特质trait" class="headerlink" title="10 特质trait"></a>10 特质trait</h3><p>scala中没有Java中的接口（interface），替代的概念是——特质。特质是scala中代码复用的基础单元，它可以将方法和字段定义封装起来，然后添加到类中，与类继承不一样的是，类继承要求每个类都只能继承一个超类，而一个类可以添加任意数量的特质。特质的定义和抽象类的定义很像，但它是使用<code>trait</code>关键字。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">名称</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 抽象字段</span></span><br><span class="line">    <span class="comment">// 抽象方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继承特质</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">类</span> <span class="keyword">extends</span> <span class="title">特质1</span> <span class="keyword">with</span> <span class="title">特质2</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 字段实现</span></span><br><span class="line">    <span class="comment">// 方法实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>使用<code>extends</code>来继承trait（scala不论是类还是特质，都是使用extends关键字）</p>
</li>
<li><p>如果要继承多个trait，则使用<code>with</code>关键字</p>
</li>
</ul>
<h4 id="1-1-trait作为接口使用"><a href="#1-1-trait作为接口使用" class="headerlink" title="1.1 trait作为接口使用"></a>1.1 trait作为接口使用</h4><p>trait作为接口使用，与java的接口使用方法一样。</p>
<p><strong>继承单个trait</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 抽象方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">log</span></span>(message:<span class="type">String</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConsoleLogger</span> <span class="keyword">extends</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">log</span></span>(message: <span class="type">String</span>): <span class="type">Unit</span> = println(<span class="string">&quot;控制台日志:&quot;</span> + message)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> logger = <span class="keyword">new</span> <span class="type">ConsoleLogger</span></span><br><span class="line">    logger.log(<span class="string">&quot;这是一条日志&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>继承多个trait</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">MessageSender</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">send</span></span>(msg:<span class="type">String</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">MessageReceive</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">receive</span></span>():<span class="type">String</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MessageWorker</span> <span class="keyword">extends</span> <span class="title">MessageSender</span> <span class="keyword">with</span> <span class="title">MessageReceive</span> </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">send</span></span>(msg: <span class="type">String</span>): <span class="type">Unit</span> = println(<span class="string">s&quot;发送消息:<span class="subst">$&#123;msg&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">receive</span></span>(): <span class="type">String</span> = <span class="string">&quot;你好！我叫一个好人！&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> worker = <span class="keyword">new</span> <span class="type">MessageWorker</span></span><br><span class="line">    worker.send(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">    println(worker.receive())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>object继承trait</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">log</span></span>(message:<span class="type">String</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ConsoleLogger</span> <span class="keyword">extends</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">log</span></span>(message: <span class="type">String</span>): <span class="type">Unit</span> = println(<span class="string">&quot;控制台消息:&quot;</span> + message)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="type">ConsoleLogger</span>.log(<span class="string">&quot;程序退出!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-2-特质中定义具体方法"><a href="#1-2-特质中定义具体方法" class="headerlink" title="1.2 特质中定义具体方法"></a>1.2 特质中定义具体方法</h4><p>和类一样，trait中还可以定义具体的方法</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">LoggerDetail</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 在trait中定义具体方法</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">log</span></span>(msg:<span class="type">String</span>) = println(msg)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserService</span> <span class="keyword">extends</span> <span class="title">LoggerDetail</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">add</span></span>() = log(<span class="string">&quot;添加用户&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MethodInTrait</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> userService = <span class="keyword">new</span> <span class="type">UserService</span></span><br><span class="line">    userService.add()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-3-特质定义具体的字段和抽象字段"><a href="#1-3-特质定义具体的字段和抽象字段" class="headerlink" title="1.3 特质定义具体的字段和抽象字段"></a>1.3 特质定义具体的字段和抽象字段</h4><p>在trait中可以定义具体字段和抽象字段，继承trait的子类自动拥有trait中定义的字段，字段直接被添加到子类中。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">    <span class="keyword">val</span> sdf = <span class="keyword">new</span> <span class="type">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm&quot;</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">log</span></span>(msg:<span class="type">String</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConsoleLogger</span> <span class="keyword">extends</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">log</span></span>(msg: <span class="type">String</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">val</span> info = <span class="string">s&quot;<span class="subst">$&#123;sdf.format(new Date())&#125;</span>:控制台消息:<span class="subst">$&#123;msg&#125;</span>&quot;</span></span><br><span class="line">        println(info)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> logger = <span class="keyword">new</span> <span class="type">ConsoleLogger</span>()</span><br><span class="line">    logger.log(<span class="string">&quot;NullPointerException&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-4-实现模板模式"><a href="#1-4-实现模板模式" class="headerlink" title="1.4 实现模板模式"></a>1.4 实现模板模式</h4><p>要实现一个输出日志的功能，目前要求输出到控制台，将来可能会输出到文件、输出到Redis、或者更多的需求。</p>
<p>如何实现将来不修改之前的代码，来扩展现有功能呢？</p>


<blockquote>
<p><strong>定义</strong>：在一个特质中，具体方法依赖于抽象方法，而抽象方法可以放到继承trait的子类中实现，这种设计方式也称为<strong>模板模式</strong>。</p>
</blockquote>


<p>在scala中，trait是可以定义抽象方法，也可以定义具体方法的。trait中定义了一个抽象方法，那么trait中定义了其他的几个具体方法就会调用该抽象方法，其他实现类可以来实现抽象方法，真正调用trait中具体方法的时候，其实会调用实现类的抽象方法实现</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">log</span></span>(msg:<span class="type">String</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">info</span></span>(msg:<span class="type">String</span>) = log(<span class="string">&quot;INFO:&quot;</span> + msg)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">warn</span></span>(msg:<span class="type">String</span>) = log(<span class="string">&quot;WARN:&quot;</span> + msg)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">error</span></span>(msg:<span class="type">String</span>) = log(<span class="string">&quot;ERROR:&quot;</span> + msg)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConsoleLogger</span> <span class="keyword">extends</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">log</span></span>(msg: <span class="type">String</span>): <span class="type">Unit</span> = println(msg)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> logger = <span class="keyword">new</span> <span class="type">ConsoleLogger</span></span><br><span class="line">    logger.info(<span class="string">&quot;信息日志&quot;</span>)</span><br><span class="line">    logger.warn(<span class="string">&quot;警告日志&quot;</span>)</span><br><span class="line">    logger.error(<span class="string">&quot;错误日志&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-5-对象混入trait"><a href="#1-5-对象混入trait" class="headerlink" title="1.5 对象混入trait"></a>1.5 对象混入trait</h4><p>scala中可以将trait混入到对象中，就是将trait中定义的方法、字段添加到一个对象中。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span>/<span class="keyword">var</span> 对象名 = <span class="keyword">new</span> 类 <span class="keyword">with</span> 特质</span><br></pre></td></tr></table></figure>

<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">log</span></span>(msg:<span class="type">String</span>) = println(msg)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserService</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">def</span> <span class="title">main</span>(<span class="params">args: <span class="type">Array</span>[<span class="type">String</span>]</span>)</span>: <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> service = <span class="keyword">new</span> <span class="type">UserService</span> <span class="keyword">with</span> <span class="type">Logger</span></span><br><span class="line">    service.log(<span class="string">&quot;混入的方法&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-6-调用链"><a href="#1-6-调用链" class="headerlink" title="1.6 调用链"></a>1.6 调用链</h4><p>如果要开发一个支付功能，往往需要执行一系列的验证才能完成支付。例如：</p>
<ol>
<li>进行支付签名校验</li>
<li>数据合法性校验</li>
<li>…</li>
</ol>
<p>如果将来因为第三方接口支付的调整，需要增加更多的校验规则，此时如何不修改之前的校验代码，来实现扩展呢？</p>
<p><strong>责任链模式</strong></p>


<p><strong>trait调用链</strong></p>


<p>类继承了多个trait后，可以依次调用多个trait中的同一个方法，只要让多个trait中的同一个方法在最后都依次执行super关键字即可。类中调用多个tait中都有这个方法时，首先会从最右边的trait方法开始执行，然后依次往左执行，形成一个调用链条。</p>
<p><strong>示例</strong>：实现一个模拟支付过程的调用链</p>


<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">HandlerTrait</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle</span></span>(data:<span class="type">String</span>) = println(<span class="string">&quot;处理数据...&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">DataValidHanlderTrait</span> <span class="keyword">extends</span> <span class="title">HandlerTrait</span> </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">handle</span></span>(data:<span class="type">String</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">        println(<span class="string">&quot;数据验证...&quot;</span>)</span><br><span class="line">        <span class="keyword">super</span>.handle(data)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">SignatureValidHandlerTrait</span> <span class="keyword">extends</span> <span class="title">HandlerTrait</span> </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">handle</span></span>(data: <span class="type">String</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">        println(<span class="string">&quot;签名校验...&quot;</span>)</span><br><span class="line">        <span class="keyword">super</span>.handle(data)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PayService</span> <span class="keyword">extends</span> <span class="title">DataValidHanlderTrait</span> <span class="keyword">with</span> <span class="title">SignatureValidHandlerTrait</span> </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">handle</span></span>(data: <span class="type">String</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">        println(<span class="string">&quot;准备支付...&quot;</span>)</span><br><span class="line">        <span class="keyword">super</span>.handle(data)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> service = <span class="keyword">new</span> <span class="type">PayService</span></span><br><span class="line">    service.handle(<span class="string">&quot;支付参数&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 程序运行输出如下：</span></span><br><span class="line"><span class="comment">// 准备支付...</span></span><br><span class="line"><span class="comment">// 签名校验...</span></span><br><span class="line"><span class="comment">// 数据验证...</span></span><br><span class="line"><span class="comment">// 处理数据...</span></span><br></pre></td></tr></table></figure>

<h4 id="1-7-trait构造机制"><a href="#1-7-trait构造机制" class="headerlink" title="1.7 trait构造机制"></a>1.7 trait构造机制</h4><p>如果一个类实现了多个trait，那这些trait是如何构造的呢？</p>
<p><strong>定义</strong></p>
<ul>
<li>trait也有构造代码，但和类不一样，特质不能有构造器参数</li>
<li>每个特质只有**<code>一个无参数</code>**的构造器。</li>
<li>一个类继承另一个类、以及多个trait，当创建该类的实例时，它的构造顺序如下：<ol>
<li>执行父类的构造器</li>
<li><code>从左到右</code>依次执行trait的构造器</li>
<li>如果trait有父trait，先构造父trait，如果多个trait有同样的父trait，则只初始化一次</li>
<li>执行子类构造器</li>
</ol>
</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">    println(<span class="string">&quot;执行Logger构造器&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">MyLogger</span> <span class="keyword">extends</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">    println(<span class="string">&quot;执行MyLogger构造器&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">TimeLogger</span> <span class="keyword">extends</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">    println(<span class="string">&quot;执行TimeLogger构造器&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    println(<span class="string">&quot;执行Person构造器&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> <span class="keyword">with</span> <span class="title">TimeLogger</span> <span class="keyword">with</span> <span class="title">MyLogger</span> </span>&#123;</span><br><span class="line">    println(<span class="string">&quot;执行Student构造器&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="type">Student</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 程序运行输出如下：</span></span><br><span class="line"><span class="comment">// 执行Person构造器</span></span><br><span class="line"><span class="comment">// 执行Logger构造器</span></span><br><span class="line"><span class="comment">// 执行TimeLogger构造器</span></span><br><span class="line"><span class="comment">// 执行MyLogger构造器</span></span><br><span class="line"><span class="comment">// 执行Student构造器</span></span><br></pre></td></tr></table></figure>

<h4 id="1-8-继承class"><a href="#1-8-继承class" class="headerlink" title="1.8 继承class"></a>1.8 继承class</h4><p>trait也可以继承class的。特质会将class中的成员都继承下来。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyUtil</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printMsg</span></span>(msg:<span class="type">String</span>) = println(msg)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Logger</span> <span class="keyword">extends</span> <span class="title">MyUtil</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">log</span></span>(msg:<span class="type">String</span>) = printMsg(<span class="string">&quot;Logger:&quot;</span> + msg)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">extends</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sayHello</span></span>() = log(<span class="string">&quot;你好&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> person = <span class="keyword">new</span> <span class="type">Person</span></span><br><span class="line">    person.sayHello()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="四、样例类"><a href="#四、样例类" class="headerlink" title="四、样例类"></a>四、样例类</h2><p>样例类是一种特殊类，它可以用来快速定义一个用于<strong>保存数据</strong>的类(类似于Java POJO类)。语法格式：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">样例类名</span>(<span class="params">[var/val] 成员变量名1:类型1, 成员变量名2:类型2, 成员变量名3:类型3</span>)</span></span><br></pre></td></tr></table></figure>

<p>如果要实现某个成员变量可以被修改，可以添加var；默认为val，可以省略。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">CaseClassDemo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params">name:<span class="type">String</span>, age:<span class="type">Int</span></span>)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">  <span class="title">def</span> <span class="title">main</span>(<span class="params">args: <span class="type">Array</span>[<span class="type">String</span>]</span>)</span>: <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> zhangsan = <span class="type">Person</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">    println(zhangsan)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-样例类方法"><a href="#1-样例类方法" class="headerlink" title="1 样例类方法"></a>1 样例类方法</h3><p>当我们定义一个样例类，编译器自动帮助我们实现了以下几个有用的方法：</p>
<h4 id="1-1-apply"><a href="#1-1-apply" class="headerlink" title="1.1 apply"></a>1.1 apply</h4><p>apply方法可以让我们快速地使用类名来创建对象（省略了new关键字）。参考以下代码：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">CasePerson</span>(<span class="params">name:<span class="type">String</span>, age:<span class="type">Int</span></span>)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">object</span> <span class="title">CaseClassDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> lisi = <span class="type">CasePerson</span>(<span class="string">&quot;李四&quot;</span>, <span class="number">21</span>)</span><br><span class="line">    println(lisi.toString)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-2-toString"><a href="#1-2-toString" class="headerlink" title="1.2 toString"></a>1.2 toString</h4><p>toString返回样例类名称(成员变量1, 成员变量2, 成员变量3….)，我们可以更方面查看样例类的成员。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">CasePerson</span>(<span class="params">name:<span class="type">String</span>, age:<span class="type">Int</span></span>)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">object</span> <span class="title">CaseClassDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> lisi = <span class="type">CasePerson</span>(<span class="string">&quot;李四&quot;</span>, <span class="number">21</span>)</span><br><span class="line">    println(lisi.toString)</span><br><span class="line">    <span class="comment">// 输出：CasePerson(李四,21)</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-3-equals"><a href="#1-3-equals" class="headerlink" title="1.3 equals"></a>1.3 equals</h4><p>样例类自动实现了equals方法，可以直接使用<code>==</code>比较两个样例类是否相等，即所有的成员变量是否相等</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> lisi1 = <span class="type">CasePerson</span>(<span class="string">&quot;李四&quot;</span>, <span class="number">21</span>)</span><br><span class="line"><span class="keyword">val</span> lisi2 = <span class="type">CasePerson</span>(<span class="string">&quot;李四&quot;</span>, <span class="number">21</span>)</span><br><span class="line">println(lisi1.eq(lisi2)) <span class="comment">//false</span></span><br><span class="line">println(lisi1 == lisi2) <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<h4 id="1-4-hashCode"><a href="#1-4-hashCode" class="headerlink" title="1.4 hashCode"></a>1.4 hashCode</h4><p>样例类自动实现了hashCode方法，如果所有成员变量的值相同，则hash值相同，只要有一个不一样，则hash值不一样。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> lisi1 = <span class="type">CasePerson</span>(<span class="string">&quot;李四&quot;</span>, <span class="number">21</span>)</span><br><span class="line"><span class="keyword">val</span> lisi2 = <span class="type">CasePerson</span>(<span class="string">&quot;李四&quot;</span>, <span class="number">22</span>)</span><br><span class="line"></span><br><span class="line">println(lisi1.hashCode())</span><br><span class="line">println(lisi2.hashCode())</span><br></pre></td></tr></table></figure>

<h4 id="1-5-copy"><a href="#1-5-copy" class="headerlink" title="1.5 copy"></a>1.5 copy</h4><p>样例类实现了copy方法，可以快速创建一个相同的实例对象，可以使用带名参数指定给成员进行重新赋值</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> lisi1 = <span class="type">CasePerson</span>(<span class="string">&quot;李四&quot;</span>, <span class="number">21</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> wangwu = lisi1.copy(name=<span class="string">&quot;王五&quot;</span>)</span><br><span class="line">println(wangwu)</span><br></pre></td></tr></table></figure>

<h3 id="2-样例对象"><a href="#2-样例对象" class="headerlink" title="2 样例对象"></a>2 样例对象</h3><p>主要用在两个地方：<code>定义枚举</code>；<code>作为没有任何参数的消息传递</code>。使用<code>case object</code>可以创建样例对象。样例对象是单例的，而且它<strong>没有主构造器</strong>。语法格式：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">样例对象名</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Sex</span> <span class="comment">/*定义一个性别特质*/</span></span></span><br><span class="line"><span class="class"><span class="title">case</span> <span class="title">object</span> <span class="title">Male</span> <span class="keyword">extends</span> <span class="title">Sex</span>		<span class="comment">// 定义一个样例对象并实现了Sex特质</span></span></span><br><span class="line"><span class="class"><span class="title">case</span> <span class="title">object</span> <span class="title">Female</span> <span class="keyword">extends</span> <span class="title">Sex</span>		</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">case</span> <span class="title">class</span> <span class="title">Person</span>(<span class="params">name:<span class="type">String</span>, sex:<span class="type">Sex</span></span>)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">object</span> <span class="title">CaseClassDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> zhangsan = <span class="type">Person</span>(<span class="string">&quot;张三&quot;</span>, <span class="type">Male</span>)</span><br><span class="line"></span><br><span class="line">    println(zhangsan)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="五、模式匹配"><a href="#五、模式匹配" class="headerlink" title="五、模式匹配"></a>五、模式匹配</h2><p>scala中有一个非常强大的模式匹配机制，可以应用在很多场景：switch语句，类型查询，使用模式匹配快速获取数据。</p>
<h3 id="1-简单匹配"><a href="#1-简单匹配" class="headerlink" title="1 简单匹配"></a>1 简单匹配</h3><p>在Java中，有switch关键字，可以简化if条件判断语句。在scala中，可以使用match表达式替代。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">变量 <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;常量1&quot;</span> =&gt; 表达式<span class="number">1</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;常量2&quot;</span> =&gt; 表达式<span class="number">2</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;常量3&quot;</span> =&gt; 表达式<span class="number">3</span></span><br><span class="line">    <span class="keyword">case</span> _ =&gt; 表达式<span class="number">4</span>		<span class="comment">// 默认匹配</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">println(<span class="string">&quot;请输出一个词：&quot;</span>)</span><br><span class="line"><span class="comment">// StdIn.readLine表示从控制台读取一行文本</span></span><br><span class="line"><span class="keyword">val</span> name = <span class="type">StdIn</span>.readLine()</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> result = name <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;hadoop&quot;</span> =&gt; <span class="string">&quot;大数据分布式存储和计算框架&quot;</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;zookeeper&quot;</span> =&gt; <span class="string">&quot;大数据分布式协调服务框架&quot;</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;spark&quot;</span> =&gt; <span class="string">&quot;大数据分布式内存计算框架&quot;</span></span><br><span class="line">    <span class="keyword">case</span> _ =&gt; <span class="string">&quot;未匹配&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">println(result)</span><br></pre></td></tr></table></figure>

<h3 id="2-匹配类型"><a href="#2-匹配类型" class="headerlink" title="2 匹配类型"></a>2 匹配类型</h3><p>除了像Java中的switch匹配数据之外，match表达式还可以进行类型匹配。如果要根据不同的数据类型，来执行不同的逻辑，也可以使用match表达式来实现。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">变量 <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> 类型<span class="number">1</span>变量名: 类型<span class="number">1</span> =&gt; 表达式<span class="number">1</span></span><br><span class="line">    <span class="keyword">case</span> 类型<span class="number">2</span>变量名: 类型<span class="number">2</span> =&gt; 表达式<span class="number">2</span></span><br><span class="line">    <span class="keyword">case</span> 类型<span class="number">3</span>变量名: 类型<span class="number">3</span> =&gt; 表达式<span class="number">3</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">case</span> _ =&gt; 表达式<span class="number">4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> a:<span class="type">Any</span> = <span class="string">&quot;hadoop&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> result = a <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> _:<span class="type">String</span> =&gt; <span class="string">&quot;String&quot;</span></span><br><span class="line">    <span class="keyword">case</span> _:<span class="type">Int</span> =&gt; <span class="string">&quot;Int&quot;</span></span><br><span class="line">    <span class="keyword">case</span> _:<span class="type">Double</span> =&gt; <span class="string">&quot;Double&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">println(result)</span><br></pre></td></tr></table></figure>

<p>如果case表达式中无需使用到匹配到的变量，可以使用下划线代代替。</p>
<h3 id="3-守卫"><a href="#3-守卫" class="headerlink" title="3 守卫"></a>3 守卫</h3><p>在Java中，只能简单地添加多个case标签，例如：要匹配0-7，就需要写出来8个case语句。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">switch</span>(a) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>: a += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>: a += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>: a += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>: a += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>: a += <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>: a += <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>: a += <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">7</span>: a += <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">default</span>: a = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在scala中，可以使用守卫来简化上述代码——也就是在<strong>case语句中添加if条件判断</strong>。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> a = <span class="type">StdIn</span>.readInt()</span><br><span class="line"></span><br><span class="line">a <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> _ <span class="keyword">if</span> a &gt;= <span class="number">0</span> &amp;&amp; a &lt;= <span class="number">3</span> =&gt; println(<span class="string">&quot;[0-3]&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> _ <span class="keyword">if</span> a &gt;= <span class="number">4</span> &amp;&amp; a &lt;= <span class="number">8</span> =&gt; println(<span class="string">&quot;[3-8]&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> _ =&gt; println(<span class="string">&quot;未匹配&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-匹配样例类"><a href="#4-匹配样例类" class="headerlink" title="4 匹配样例类"></a>4 匹配样例类</h3><p>scala可以使用模式匹配来匹配样例类，从而可以快速获取样例类中的成员数据。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 创建两个样例类</span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params">name:<span class="type">String</span>, age:<span class="type">Int</span></span>)</span></span><br><span class="line"><span class="class"><span class="title">case</span> <span class="title">class</span> <span class="title">Order</span>(<span class="params">id:<span class="type">String</span></span>)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">def</span> <span class="title">main</span>(<span class="params">args: <span class="type">Array</span>[<span class="type">String</span>]</span>)</span>: <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">// 2. 创建样例类对象，并赋值为Any类型</span></span><br><span class="line">    <span class="keyword">val</span> zhangsan:<span class="type">Any</span> = <span class="type">Person</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">20</span>)</span><br><span class="line">    <span class="keyword">val</span> order1:<span class="type">Any</span> = <span class="type">Order</span>(<span class="string">&quot;001&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 使用match...case表达式来进行模式匹配</span></span><br><span class="line">    <span class="comment">// 获取样例类中成员变量</span></span><br><span class="line">    order1 <span class="keyword">match</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="type">Person</span>(name, age) =&gt; println(<span class="string">s&quot;姓名：<span class="subst">$&#123;name&#125;</span> 年龄：<span class="subst">$&#123;age&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">case</span> <span class="type">Order</span>(id1) =&gt; println(<span class="string">s&quot;ID为：<span class="subst">$&#123;id1&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">case</span> _ =&gt; println(<span class="string">&quot;未匹配&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-匹配集合"><a href="#5-匹配集合" class="headerlink" title="5 匹配集合"></a>5 匹配集合</h3><p>scala中的模式匹配，还能用来匹配集合。</p>
<h4 id="5-1-匹配数组"><a href="#5-1-匹配数组" class="headerlink" title="5.1 匹配数组"></a>5.1 匹配数组</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以1开头，后续的两个元素不固定val arr = Array(1, 3, 5)</span></span><br><span class="line">arr <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Array</span>(<span class="number">1</span>, x, y) =&gt; println(x + <span class="string">&quot; &quot;</span> + y) <span class="comment">// 以1开头，后续的两个元素不固定</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Array</span>(<span class="number">0</span>) =&gt; println(<span class="string">&quot;only 0&quot;</span>)   		<span class="comment">// 只匹配一个0元素的元素</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Array</span>(<span class="number">0</span>, _*) =&gt; println(<span class="string">&quot;0 ...&quot;</span>)		<span class="comment">// 可以任意数量，但是以0开头</span></span><br><span class="line">    <span class="keyword">case</span> _ =&gt; println(<span class="string">&quot;something else&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-2-匹配列表"><a href="#5-2-匹配列表" class="headerlink" title="5.2 匹配列表"></a>5.2 匹配列表</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = <span class="type">List</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">list <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span> :: <span class="type">Nil</span> =&gt; println(<span class="string">&quot;只有0的列表&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span> :: tail =&gt; println(<span class="string">&quot;0开头的列表&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> x :: y :: <span class="type">Nil</span> =&gt; println(<span class="string">s&quot;只有另两个元素<span class="subst">$&#123;x&#125;</span>, <span class="subst">$&#123;y&#125;</span>的列表&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> _ =&gt; println(<span class="string">&quot;未匹配&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-3-匹配元组"><a href="#5-3-匹配元组" class="headerlink" title="5.3 匹配元组"></a>5.3 匹配元组</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> tuple = (<span class="number">2</span>, <span class="number">2</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">tuple <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> (<span class="number">1</span>, x, y) =&gt; println(<span class="string">s&quot;三个元素，1开头的元组：1, <span class="subst">$&#123;x&#125;</span>, <span class="subst">$&#123;y&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> (x, y, <span class="number">5</span>) =&gt; println(<span class="string">s&quot;三个元素，5结尾的元组：<span class="subst">$&#123;x&#125;</span>, <span class="subst">$&#123;y&#125;</span>, 5&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> _ =&gt; println(<span class="string">&quot;未匹配&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-变量声明"><a href="#6-变量声明" class="headerlink" title="6 变量声明"></a>6 变量声明</h3><p>在定义变量的时候，可以使用模式匹配快速获取数据</p>
<p><strong>示例 | 获取数组中的元素</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> array = (<span class="number">1</span> to <span class="number">10</span>).toArray</span><br><span class="line"><span class="keyword">val</span> <span class="type">Array</span>(_, x, y, z, _*) = array</span><br><span class="line"></span><br><span class="line">println(x, y, z)</span><br></pre></td></tr></table></figure>

<p><strong>示例 | 获取List中的数据</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = (<span class="number">1</span> to <span class="number">10</span>).toList</span><br><span class="line"><span class="keyword">val</span> x :: y :: tail = list</span><br><span class="line"></span><br><span class="line">println(x, y)</span><br></pre></td></tr></table></figure>

<h3 id="7-Option类型"><a href="#7-Option类型" class="headerlink" title="7 Option类型"></a>7 Option类型</h3><p>使用Option类型，可以用来有效避免空引用(null)异常。也就是说，将来我们返回某些数据时，可以返回一个Option类型来替代。scala中，Option类型来表示可选值。这种类型的数据有两种形式：</p>
<ul>
<li><p>Some(x)：表示实际的值</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Some</span>[+<span class="type">A</span>](<span class="params">x: <span class="type">A</span></span>) <span class="keyword">extends</span> <span class="title">Option</span>[<span class="type">A</span>]</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isEmpty</span></span>:<span class="type">Boolean</span> = <span class="literal">false</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span></span>:<span class="type">A</span> = x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>None：表示没有值</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">None</span> <span class="keyword">extends</span> <span class="title">Option</span>[<span class="type">Nothing</span>]</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isEmpty</span></span>:<span class="type">Boolean</span> = <span class="literal">true</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span></span>:<span class="type">Nothing</span> = <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">NoSuchElementException</span>(<span class="string">&quot;None.get&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li>使用getOrElse方法，当值为None是可以指定一个默认值</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dvi</span></span>(a:<span class="type">Double</span>, b:<span class="type">Double</span>):<span class="type">Option</span>[<span class="type">Double</span>] = &#123;</span><br><span class="line">    <span class="keyword">if</span>(b != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">Some</span>(a / b)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">None</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> result1 = dvi(<span class="number">1.0</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    result1 <span class="keyword">match</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="type">Some</span>(x) =&gt; println(x)</span><br><span class="line">        <span class="keyword">case</span> <span class="type">None</span> =&gt; println(<span class="string">&quot;除零异常&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;-----------------------&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> result = dvi(<span class="number">1</span>, <span class="number">0</span>).getOrElse(<span class="number">0</span>)</span><br><span class="line">    println(result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-偏函数"><a href="#8-偏函数" class="headerlink" title="8 偏函数"></a>8 偏函数</h3><p>偏函数可以提供了简洁的语法，可以简化函数的定义。配合集合的函数式编程，可以让代码更加优雅。偏函数被包在花括号内没有match的一组case语句是一个偏函数；偏函数是PartialFunction[A, B]的一个实例：</p>
<ul>
<li>A代表输入参数类型</li>
<li>B代表返回结果类型</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// func1是一个输入参数为Int类型，返回值为String类型的偏函数</span></span><br><span class="line"><span class="keyword">val</span> func1: <span class="type">PartialFunction</span>[<span class="type">Int</span>, <span class="type">String</span>] = &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span> =&gt; <span class="string">&quot;一&quot;</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span> =&gt; <span class="string">&quot;二&quot;</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span> =&gt; <span class="string">&quot;三&quot;</span></span><br><span class="line">    <span class="keyword">case</span> _ =&gt; <span class="string">&quot;其他&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">println(func1(<span class="number">2</span>))</span><br></pre></td></tr></table></figure>

<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = (<span class="number">1</span> to <span class="number">10</span>).toList</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> list2 = list.map&#123;</span><br><span class="line">    <span class="keyword">case</span> x <span class="keyword">if</span> x &gt;= <span class="number">1</span> &amp;&amp; x &lt;= <span class="number">3</span> =&gt; <span class="string">&quot;[1-3]&quot;</span></span><br><span class="line">    <span class="keyword">case</span> x <span class="keyword">if</span> x &gt;= <span class="number">4</span> &amp;&amp; x &lt;= <span class="number">8</span> =&gt; <span class="string">&quot;[4-8]&quot;</span></span><br><span class="line">    <span class="keyword">case</span> x <span class="keyword">if</span> x &gt; <span class="number">8</span> =&gt; <span class="string">&quot;(8-*]&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">println(list2)</span><br></pre></td></tr></table></figure>

<h3 id="9-正则表达式"><a href="#9-正则表达式" class="headerlink" title="9 正则表达式"></a>9 正则表达式</h3><p>在scala中，可以很方便地使用正则表达式来匹配数据。</p>
<p><strong>Regex类</strong></p>
<ul>
<li><p>scala中提供了Regex类来定义正则表达式</p>
</li>
<li><p>要构造一个RegEx对象，直接使用String类的r方法即可</p>
</li>
<li><p>建议使用三个双引号来表示正则表达式，不然就得对正则中的反斜杠来进行转义</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> regEx = <span class="string">&quot;&quot;&quot;正则表达式&quot;&quot;&quot;</span>.r</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>findAllMatchIn方法</strong></p>
<ul>
<li>使用findAllMatchIn方法可以获取到所有正则匹配到的字符串</li>
</ul>
<p>示例一：来匹配邮箱是否合法</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> r = <span class="string">&quot;&quot;&quot;.+@.+\..+&quot;&quot;&quot;</span>.r</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> eml1 = <span class="string">&quot;qq12344@163.com&quot;</span></span><br><span class="line"><span class="keyword">val</span> eml2 = <span class="string">&quot;qq12344@.com&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(r.findAllMatchIn(eml1).size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    println(eml1 + <span class="string">&quot;邮箱合法&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    println(eml1 + <span class="string">&quot;邮箱不合法&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(r.findAllMatchIn(eml2).size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    println(eml2 + <span class="string">&quot;邮箱合法&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    println(eml2 + <span class="string">&quot;邮箱不合法&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="10-异常处理"><a href="#10-异常处理" class="headerlink" title="10 异常处理"></a>10 异常处理</h3><h4 id="1-捕获异常"><a href="#1-捕获异常" class="headerlink" title="1 捕获异常"></a>1 捕获异常</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 代码</span></span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> ex:异常类型<span class="number">1</span> =&gt; <span class="comment">// 代码</span></span><br><span class="line">    <span class="keyword">case</span> ex:异常类型<span class="number">2</span> =&gt; <span class="comment">// 代码</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>try中的代码是我们编写的业务处理代码，在catch中表示当出现某个异常时，需要执行的代码，在finally中，是不管是否出现异常都会执行的代码</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> i = <span class="number">10</span> / <span class="number">0</span></span><br><span class="line">    println(<span class="string">&quot;你好！&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> ex: <span class="type">Exception</span> =&gt; println(ex.getMessage)</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h4 id="2-抛出异常"><a href="#2-抛出异常" class="headerlink" title="2 抛出异常"></a>2 抛出异常</h4><p>我们也可以在一个方法中，抛出异常。语法格式和Java类似，使用<code>throw new Exception...</code></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">Exception</span>(<span class="string">&quot;这是一个异常&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Exception</span> in thread <span class="string">&quot;main&quot;</span> java.lang.<span class="type">Exception</span>: 这是一个异常</span><br><span class="line">at <span class="type">ForDemo</span>$.main(<span class="type">ForDemo</span>.scala:<span class="number">3</span>)</span><br><span class="line">at <span class="type">ForDemo</span>.main(<span class="type">ForDemo</span>.scala)</span><br></pre></td></tr></table></figure>

<p>scala不需要在方法上声明要抛出的异常，它已经解决了再Java中被认为是设计失败的检查型异常。</p>
<h3 id="11-提取器Extractor"><a href="#11-提取器Extractor" class="headerlink" title="11 提取器Extractor"></a>11 提取器Extractor</h3><p>我们之前已经使用过scala中非常强大的模式匹配功能了，通过模式匹配，我们可以快速匹配样例类中的成员变量。例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 创建两个样例类</span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params">name:<span class="type">String</span>, age:<span class="type">Int</span></span>)</span></span><br><span class="line"><span class="class"><span class="title">case</span> <span class="title">class</span> <span class="title">Order</span>(<span class="params">id:<span class="type">String</span></span>)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">def</span> <span class="title">main</span>(<span class="params">args: <span class="type">Array</span>[<span class="type">String</span>]</span>)</span>: <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">// 2. 创建样例类对象，并赋值为Any类型</span></span><br><span class="line">    <span class="keyword">val</span> zhangsan:<span class="type">Any</span> = <span class="type">Person</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">20</span>)</span><br><span class="line">    <span class="keyword">val</span> order1:<span class="type">Any</span> = <span class="type">Order</span>(<span class="string">&quot;001&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 使用match...case表达式来进行模式匹配</span></span><br><span class="line">    <span class="comment">// 获取样例类中成员变量</span></span><br><span class="line">    order1 <span class="keyword">match</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="type">Person</span>(name, age) =&gt; println(<span class="string">s&quot;姓名：<span class="subst">$&#123;name&#125;</span> 年龄：<span class="subst">$&#123;age&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">case</span> <span class="type">Order</span>(id1) =&gt; println(<span class="string">s&quot;ID为：<span class="subst">$&#123;id1&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">case</span> _ =&gt; println(<span class="string">&quot;未匹配&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那是不是所有的类都可以进行这样的模式匹配呢？答案是：<code>不可以</code>的。要支持模式匹配，必须要实现一个<strong>提取器</strong>。</p>
<h4 id="1-定义提取器"><a href="#1-定义提取器" class="headerlink" title="1 定义提取器"></a>1 定义提取器</h4><p>实现一个类的伴生对象中的apply方法，可以用类名来快速构建一个对象。伴生对象中，还有一个unapply方法。与apply相反，unapply是将该类的对象，拆解为一个个的元素。</p>




<p>要实现一个类的提取器，只需要在该类的伴生对象中实现一个unapply方法即可。语法格式：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">unapply</span></span>(stu:<span class="type">Student</span>):<span class="type">Option</span>[(类型<span class="number">1</span>, 类型<span class="number">2</span>, 类型<span class="number">3.</span>..)] = &#123;</span><br><span class="line">    <span class="keyword">if</span>(stu != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">Some</span>((变量<span class="number">1</span>, 变量<span class="number">2</span>, 变量<span class="number">3.</span>..))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">None</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>(<span class="params">var name:<span class="type">String</span>, var age:<span class="type">Int</span></span>)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">object</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(name:<span class="type">String</span>, age:<span class="type">Int</span>) = &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="type">Student</span>(name, age)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">unapply</span></span>(student:<span class="type">Student</span>) = &#123;</span><br><span class="line">        <span class="keyword">val</span> tuple = (student.name, student.age)</span><br><span class="line">        <span class="type">Some</span>(tuple)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> zhangsan = <span class="type">Student</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">    zhangsan <span class="keyword">match</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="type">Student</span>(name, age) =&gt; println(<span class="string">s&quot;<span class="subst">$&#123;name&#125;</span> =&gt; <span class="subst">$&#123;age&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="12-泛型"><a href="#12-泛型" class="headerlink" title="12 泛型"></a>12 泛型</h3><p>scala和Java一样，类和特质、方法都可以支持泛型。在scala中，使用方括号来定义类型参数。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">方法名</span></span>[泛型名称](..) = &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不考虑泛型的实现</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getMiddle</span></span>(arr:<span class="type">Array</span>[<span class="type">Int</span>]) = arr(arr.length / <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">  <span class="keyword">val</span> arr1 = <span class="type">Array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">  println(getMiddle(arr1))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>加入泛型支持</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getMiddleElement</span></span>[<span class="type">T</span>](array:<span class="type">Array</span>[<span class="type">T</span>]) =</span><br><span class="line">array(array.length / <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    println(getMiddleElement(<span class="type">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)))</span><br><span class="line">    println(getMiddleElement(<span class="type">Array</span>(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>, <span class="string">&quot;e&quot;</span>)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-泛型类"><a href="#1-泛型类" class="headerlink" title="1 泛型类"></a>1 泛型类</h4><p>scala的类也可以定义泛型。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">类</span>[<span class="type">T</span>](<span class="params">val 变量名: <span class="type">T</span></span>)</span></span><br></pre></td></tr></table></figure>

<p>定义一个泛型类，直接在类名后面加上方括号，指定要使用的泛型参数，指定类对应的泛型参数后，就使用这些类型参数来定义变量了。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>[<span class="type">T</span>](<span class="params">var a:<span class="type">T</span>, var b:<span class="type">T</span></span>)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">def</span> <span class="title">main</span>(<span class="params">args: <span class="type">Array</span>[<span class="type">String</span>]</span>)</span>: <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> pairList = <span class="type">List</span>(</span><br><span class="line">        <span class="type">Pair</span>(<span class="string">&quot;Hadoop&quot;</span>, <span class="string">&quot;Storm&quot;</span>),</span><br><span class="line">        <span class="type">Pair</span>(<span class="string">&quot;Hadoop&quot;</span>, <span class="number">2008</span>),</span><br><span class="line">        <span class="type">Pair</span>(<span class="number">1.0</span>, <span class="number">2.0</span>),</span><br><span class="line">        <span class="type">Pair</span>(<span class="string">&quot;Hadoop&quot;</span>, <span class="type">Some</span>(<span class="number">1.9</span>))</span><br><span class="line">    )</span><br><span class="line">    println(pairList)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-上下界"><a href="#2-上下界" class="headerlink" title="2 上下界"></a>2 上下界</h4><p>在定义方法/类的泛型时，限定必须从哪个类继承、或者必须是哪个类的父类。此时，就需要使用到上下界。</p>
<p><strong>上界</strong></p>
<p>使用<code>&lt;: 类型名</code>表示给类型添加一个上界，表示泛型参数必须要从该类（或本身）继承</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="type">T</span> &lt;: 类型]</span><br></pre></td></tr></table></figure>

<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">def</span> <span class="title">demo</span>[<span class="type">T</span> &lt;: <span class="type">Person</span>](<span class="params">a:<span class="type">Array</span>[<span class="type">T</span>]</span>) </span>= println(a)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    demo(<span class="type">Array</span>(<span class="keyword">new</span> <span class="type">Person</span>))</span><br><span class="line">    demo(<span class="type">Array</span>(<span class="keyword">new</span> <span class="type">Student</span>))</span><br><span class="line">    <span class="comment">// 编译出错，必须是Person的子类</span></span><br><span class="line">    <span class="comment">// demo(Array(&quot;hadoop&quot;))</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>下界</strong></p>
<p>上界是要求必须是某个类的子类，或者必须从某个类继承，而下界是必须是某个类的父类（或本身）</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="type">T</span> &gt;: 类型]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：如果类既有上界、又有下界。下界写在前面，上界写在后面</p>
</blockquote>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Policeman</span> <span class="keyword">extends</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Superman</span> <span class="keyword">extends</span> <span class="title">Policeman</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">def</span> <span class="title">demo</span>[<span class="type">T</span> &gt;: <span class="type">Policeman</span>](<span class="params">array:<span class="type">Array</span>[<span class="type">T</span>]</span>) </span>= println(array)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    demo(<span class="type">Array</span>(<span class="keyword">new</span> <span class="type">Person</span>))</span><br><span class="line">    demo(<span class="type">Array</span>(<span class="keyword">new</span> <span class="type">Policeman</span>))</span><br><span class="line">    <span class="comment">// 编译出错：Superman是Policeman的子类</span></span><br><span class="line">    <span class="comment">// demo(Array(new Superman))</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-协变、逆变、非变"><a href="#3-协变、逆变、非变" class="headerlink" title="3 协变、逆变、非变"></a>3 协变、逆变、非变</h4><p>spark的源代码中大量使用到了协变、逆变、非变。来看一个类型转换的问题：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span>[<span class="type">T</span>]</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">object</span> <span class="title">Pair</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> p1 = <span class="type">Pair</span>(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">    <span class="comment">// 编译报错，无法将p1转换为p2</span></span><br><span class="line">    <span class="keyword">val</span> p2:<span class="type">Pair</span>[<span class="type">AnyRef</span>] = p1</span><br><span class="line"></span><br><span class="line">    println(p2)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如何让带有泛型的类支持类型转换呢？</p>
<p><strong>非变</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span>[<span class="type">T</span>]</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>默认泛型类是非变的，类型B是A的子类型，Pair[A]和Pair[B]没有任何从属关系</p>


<p><strong>协变</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span>[+<span class="type">T</span>]</span></span><br></pre></td></tr></table></figure>

<p>类型B是A的子类型，Pair[B]可以认为是Pair[A]的子类型，参数化类型的方向和类型的方向是一致的。</p>
<p><strong>逆变</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span>[-<span class="type">T</span>]</span></span><br></pre></td></tr></table></figure>

<p>类型B是A的子类型，Pair[A]反过来可以认为是Pair[B]的子类型，参数化类型的方向和类型的方向是相反的。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Super</span></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Super</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Temp1</span>[<span class="type">T</span>]</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Temp2</span>[+<span class="type">T</span>]</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Temp3</span>[-<span class="type">T</span>]</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">def</span> <span class="title">main</span>(<span class="params">args: <span class="type">Array</span>[<span class="type">String</span>]</span>)</span>: <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> a:<span class="type">Temp1</span>[<span class="type">Sub</span>] = <span class="keyword">new</span> <span class="type">Temp1</span>[<span class="type">Sub</span>]</span><br><span class="line">    <span class="comment">// 编译报错</span></span><br><span class="line">    <span class="comment">// 非变</span></span><br><span class="line">    <span class="comment">//val b:Temp1[Super] = a</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 协变</span></span><br><span class="line">    <span class="keyword">val</span> c: <span class="type">Temp2</span>[<span class="type">Sub</span>] = <span class="keyword">new</span> <span class="type">Temp2</span>[<span class="type">Sub</span>]</span><br><span class="line">    <span class="keyword">val</span> d: <span class="type">Temp2</span>[<span class="type">Super</span>] = c</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 逆变</span></span><br><span class="line">    <span class="keyword">val</span> e: <span class="type">Temp3</span>[<span class="type">Super</span>] = <span class="keyword">new</span> <span class="type">Temp3</span>[<span class="type">Super</span>]</span><br><span class="line">    <span class="keyword">val</span> f: <span class="type">Temp3</span>[<span class="type">Sub</span>] = e</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="六、Actor并发编程"><a href="#六、Actor并发编程" class="headerlink" title="六、Actor并发编程"></a>六、Actor并发编程</h2><p>scala的Actor并发编程模型可以用来开发比Java线程效率更高的并发程序。</p>
<p><strong>Java并发编程的问题</strong>：在Java并发编程中，每个对象都有一个逻辑监视器（monitor），可以用来控制对象的多线程访问。我们添加<code>sychronized</code>关键字来标记，需要进行同步加锁访问。这样，通过加锁的机制来确保同一时间只有一个线程访问共享数据。但这种方式存在资源争夺、以及死锁问题，程序越大问题越麻烦。</p>


<p><strong>线程死锁</strong></p>


<h3 id="1-Actor并发编程模型"><a href="#1-Actor并发编程模型" class="headerlink" title="1 Actor并发编程模型"></a>1 Actor并发编程模型</h3><p>Actor并发编程模型，是scala提供给程序员的一种与Java并发编程完全不一样的并发编程模型，是一种基于事件模型的并发机制。Actor并发编程模型是一种不共享数据，依赖消息传递的一种并发编程模式，有效避免资源争夺、死锁等情况。</p>


<p><strong>Java并发编程对比Actor并发编程</strong></p>
<table>
<thead>
<tr>
<th>Java内置线程模型</th>
<th>scala Actor模型</th>
</tr>
</thead>
<tbody><tr>
<td>“共享数据-锁”模型 (share data and lock)</td>
<td>share nothing</td>
</tr>
<tr>
<td>每个object有一个monitor，监视线程对共享数据的访问</td>
<td>不共享数据，Actor之间通过Message通讯</td>
</tr>
<tr>
<td>加锁代码使用synchronized标识</td>
<td></td>
</tr>
<tr>
<td>死锁问题</td>
<td></td>
</tr>
<tr>
<td>每个线程内部是顺序执行的</td>
<td>每个Actor内部是顺序执行的</td>
</tr>
</tbody></table>
<blockquote>
<p>scala在2.11.x版本中加入了Akka并发编程框架，老版本已经废弃。Actor的编程模型和Akka很像。</p>
</blockquote>
<h3 id="2-创建Actor"><a href="#2-创建Actor" class="headerlink" title="2 创建Actor"></a>2 创建Actor</h3><p>创建Actor的方式和Java中创建线程很类似，也是通过继承来创建。使用方式：</p>
<ol>
<li>定义class或object继承Actor特质</li>
<li>重写act方法</li>
<li>调用Actor的start方法执行Actor</li>
</ol>
<blockquote>
<p>类似于Java线程，这里的每个Actor是并行执行的</p>
</blockquote>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ActorDemo</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Actor1</span> <span class="keyword">extends</span> <span class="title">Actor</span> </span>&#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">act</span></span>(): <span class="type">Unit</span> = (<span class="number">1</span> to <span class="number">10</span>).foreach(println(_))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Actor2</span> <span class="keyword">extends</span> <span class="title">Actor</span> </span>&#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">act</span></span>(): <span class="type">Unit</span> = (<span class="number">11</span> to <span class="number">20</span>).foreach(println(_))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="type">Actor1</span>().start()</span><br><span class="line">        <span class="keyword">new</span> <span class="type">Actor2</span>().start()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用object继承Actor创建</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Actor1</span> <span class="keyword">extends</span> <span class="title">Actor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">act</span></span>(): <span class="type">Unit</span> =</span><br><span class="line">    <span class="keyword">for</span>(i &lt;- <span class="number">1</span> to <span class="number">10</span>) &#123;</span><br><span class="line">        println(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Actor2</span> <span class="keyword">extends</span> <span class="title">Actor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">act</span></span>(): <span class="type">Unit</span> =</span><br><span class="line">    <span class="keyword">for</span>(i &lt;- <span class="number">11</span> to <span class="number">20</span>) &#123;</span><br><span class="line">        println(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="type">Actor1</span>.start()</span><br><span class="line">    <span class="type">Actor2</span>.start()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Actor程序运行流程：</strong></p>
<ol>
<li>调用start()方法启动Actor</li>
<li>自动执行<strong>act</strong>()方法</li>
<li>向Actor发送消息</li>
<li>act方法执行完成后，程序会调用**exit()**方法</li>
</ol>
<h3 id="3-发送、接收消息"><a href="#3-发送、接收消息" class="headerlink" title="3 发送、接收消息"></a>3 发送、接收消息</h3><p>我们之前介绍Actor的时候，说过Actor是基于事件（消息）的并发编程模型，那么Actor是如何发送消息和接收消息的呢？</p>
<p><strong>发送消息</strong></p>
<p>我们可以使用三种方式来发送消息：</p>
<table>
<thead>
<tr>
<th><strong>！</strong></th>
<th><strong>发送异步消息，没有返回值</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>!?</strong></td>
<td><strong>发送同步消息，等待返回值</strong></td>
</tr>
<tr>
<td><strong>!!</strong></td>
<td><strong>发送异步消息，返回值是Future[Any]</strong></td>
</tr>
</tbody></table>
<p>例如：要给actor1发送一个异步字符串消息，使用以下代码：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">actor1 ! <span class="string">&quot;你好!&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>接收消息</strong></p>
<p>Actor中使用receive方法来接收消息，需要给receive方法传入一个偏函数</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> 变量名<span class="number">1</span>:消息类型<span class="number">1</span> =&gt; 业务处理<span class="number">1</span>,</span><br><span class="line">    <span class="keyword">case</span> 变量名<span class="number">2</span>:消息类型<span class="number">2</span> =&gt; 业务处理<span class="number">2</span>,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>receive方法只接收一次消息，接收完后继续执行act方法</p>
</blockquote>


<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ActorSender</span> <span class="keyword">extends</span> <span class="title">Actor</span> </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">act</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">// 发送消息</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">      <span class="type">ActorReceiver</span> ! <span class="string">&quot;hello!&quot;</span></span><br><span class="line">      <span class="type">TimeUnit</span>.<span class="type">SECONDS</span>.sleep(<span class="number">3</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ActorReceiver</span> <span class="keyword">extends</span> <span class="title">Actor</span> </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">act</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">// 持续接收消息</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">      receive &#123;</span><br><span class="line">        <span class="keyword">case</span> msg:<span class="type">String</span> =&gt; println(<span class="string">&quot;接收到消息：&quot;</span> + msg)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">  <span class="type">ActorReceiver</span>.start()</span><br><span class="line">  <span class="type">ActorSender</span>.start()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用loop和react优化接收消息</strong></p>
<p>上述代码，使用while循环来不断接收消息。</p>
<ul>
<li>如果当前Actor没有接收到消息，线程就会处于阻塞状态</li>
<li>如果有很多的Actor，就有可能会导致很多线程都是处于阻塞状态</li>
<li>每次有新的消息来时，重新创建线程来处理</li>
<li>频繁的线程创建、销毁和切换，会影响运行效率</li>
</ul>
<p>在scala中，可以使用loop + react来复用线程。比while + receive更高效</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 持续接收消息</span></span><br><span class="line">loop &#123;</span><br><span class="line">    react &#123;</span><br><span class="line">        <span class="keyword">case</span> msg:<span class="type">String</span> =&gt; println(<span class="string">&quot;接收到消息：&quot;</span> + msg)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-发送、接收自定义消息"><a href="#4-发送、接收自定义消息" class="headerlink" title="4 发送、接收自定义消息"></a>4 发送、接收自定义消息</h3><p>前面发送的消息是字符串类型，Actor中也支持发送自定义消息，常见的如：使用样例类封装消息，然后进行发送处理。示例说明：</p>
<blockquote>
<ul>
<li>使用<code>!?</code>来发送同步消息</li>
<li>在Actor的act方法中，可以使用sender获取发送者的Actor引用</li>
</ul>
</blockquote>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Message</span>(<span class="params">id:<span class="type">Int</span>, msg:<span class="type">String</span></span>)</span></span><br><span class="line"><span class="class"><span class="title">case</span> <span class="title">class</span> <span class="title">ReplyMessage</span>(<span class="params">msg:<span class="type">String</span>, name:<span class="type">String</span></span>)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">object</span> <span class="title">MsgActor</span> <span class="keyword">extends</span> <span class="title">Actor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">act</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">        loop &#123;</span><br><span class="line">            react &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="type">Message</span>(id, msg) =&gt; &#123;</span><br><span class="line">                    println(<span class="string">s&quot;接收到消息:<span class="subst">$&#123;id&#125;</span>/<span class="subst">$&#123;msg&#125;</span>&quot;</span>)</span><br><span class="line">                    sender ! <span class="type">ReplyMessage</span>(<span class="string">&quot;不太好&quot;</span>, <span class="string">&quot;Tom&quot;</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="type">MsgActor</span>.start()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> replyMessage: <span class="type">Any</span> = <span class="type">MsgActor</span> !? <span class="type">Message</span>(<span class="number">1</span>, <span class="string">&quot;你好&quot;</span>)</span><br><span class="line">    println(<span class="string">&quot;回复消息:&quot;</span> + replyMessage.asInstanceOf[<span class="type">ReplyMessage</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用<code>!</code>发送异步无返回消息</p>
</blockquote>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Mesasge</span>(<span class="params">message:<span class="type">String</span>, company:<span class="type">String</span></span>)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">object</span> <span class="title">MsgActor</span> <span class="keyword">extends</span> <span class="title">Actor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">act</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">        loop &#123;</span><br><span class="line">            react &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="type">Mesasge</span>(message, company) =&gt;</span><br><span class="line">                println(<span class="string">s&quot;MsgActor接收到消息:<span class="subst">$&#123;message&#125;</span>/<span class="subst">$&#123;company&#125;</span>&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="type">MsgActor</span>.start()</span><br><span class="line">    <span class="type">MsgActor</span> ! <span class="type">Mesasge</span>(<span class="string">&quot;中国联通&quot;</span>, <span class="string">&quot;大爷，快交话费！&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>使用<code>!!</code>发送异步有返回消息</li>
<li>发送后，返回类型为Future[Any]的对象</li>
<li>Future表示异步返回数据的封装，虽获取到Future的返回值，但不一定有值，可能在将来某一时刻才会返回消息</li>
<li>Future的isSet()可检查是否已经收到返回消息，apply()方法可获取返回数据</li>
</ul>
</blockquote>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Message</span>(<span class="params">id:<span class="type">Int</span>, message:<span class="type">String</span></span>)</span></span><br><span class="line"><span class="class"><span class="title">case</span> <span class="title">class</span> <span class="title">ReplyMessage</span>(<span class="params">message:<span class="type">String</span>, name:<span class="type">String</span></span>)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">object</span> <span class="title">MsgActor</span> <span class="keyword">extends</span> <span class="title">Actor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">act</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">        loop &#123;</span><br><span class="line">            react &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="type">Message</span>(id, message) =&gt;</span><br><span class="line">                println(<span class="string">s&quot;MsgActor接收到消息：<span class="subst">$&#123;id&#125;</span>/<span class="subst">$&#123;message&#125;</span>&quot;</span>)</span><br><span class="line">                sender ! <span class="type">ReplyMessage</span>(<span class="string">&quot;收到消息！&quot;</span>, <span class="string">&quot;JIm&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="type">MsgActor</span>.start()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> future: <span class="type">Future</span>[<span class="type">Any</span>] = <span class="type">MsgActor</span> !! <span class="type">Message</span>(<span class="number">1</span>, <span class="string">&quot;你好！&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!future.isSet) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> replyMessage = future.apply().asInstanceOf[<span class="type">ReplyMessage</span>]</span><br><span class="line">    println(replyMessage)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="七、高阶函数"><a href="#七、高阶函数" class="headerlink" title="七、高阶函数"></a>七、高阶函数</h2><p>scala 混合了面向对象和函数式的特性，在函数式编程语言中，函数是“头等公民”，它和Int、String、Class等其他类型处于同等的地位，可以像其他类型的变量一样被传递和操作。</p>
<h3 id="1-作为值的函数"><a href="#1-作为值的函数" class="headerlink" title="1 作为值的函数"></a>1 作为值的函数</h3><p>在scala中，函数就像和数字、字符串一样，可以将函数传递给一个方法。我们可以对算法进行封装，然后将具体的动作传递给方法，这种特性很有用。前面学过List的map方法，它就可以接收一个函数，完成List的转换。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> func: <span class="type">Int</span> =&gt; <span class="type">String</span> = (num:<span class="type">Int</span>) =&gt; <span class="string">&quot;*&quot;</span> * num</span><br><span class="line"></span><br><span class="line">println((<span class="number">1</span> to <span class="number">10</span>).map(func))</span><br></pre></td></tr></table></figure>

<h3 id="2-匿名函数"><a href="#2-匿名函数" class="headerlink" title="2 匿名函数"></a>2 匿名函数</h3><p>上面的代码，给(num:Int) =&gt; “*“ * num函数赋值给了一个变量，但是这种写法有一些啰嗦。在scala中，可以不需要给函数赋值给变量，没有赋值给变量的函数就是<strong>匿名函数</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = <span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串*方法，表示生成指定数量的字符串</span></span><br><span class="line"><span class="keyword">val</span> func_num2star = (num:<span class="type">Int</span>) =&gt; <span class="string">&quot;*&quot;</span> * num</span><br><span class="line"></span><br><span class="line">print(list.map(func_num2star))</span><br></pre></td></tr></table></figure>

<p>使用匿名函数优化上述代码</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">println((<span class="number">1</span> to <span class="number">10</span>).map(num =&gt; <span class="string">&quot;*&quot;</span> * num))</span><br><span class="line"><span class="comment">// 因为此处num变量只使用了一次，而且只是进行简单的计算，所以可以省略参数列表，使用_替代参数</span></span><br><span class="line">println((<span class="number">1</span> to <span class="number">10</span>).map(<span class="string">&quot;*&quot;</span> * _))</span><br></pre></td></tr></table></figure>

<h3 id="3-柯里化"><a href="#3-柯里化" class="headerlink" title="3 柯里化"></a>3 柯里化</h3><p>在scala和spark的源代码中，大量使用到了柯里化。方便阅读源代码。柯里化（Currying）是指将原先接受多个参数的方法转换为多个只有一个参数的参数列表的过程。</p>


<p><strong>柯里化过程解析</strong></p>


<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 柯里化：实现对两个数进行计算</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc_carried</span></span>(x:<span class="type">Double</span>, y:<span class="type">Double</span>)(func_calc:(<span class="type">Double</span>, <span class="type">Double</span>)=&gt;<span class="type">Double</span>) = &#123;</span><br><span class="line">    func_calc(x, y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Intrray</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    println(calc_carried(<span class="number">10.1</span>, <span class="number">10.2</span>)&#123;</span><br><span class="line">        (x,y) =&gt; x + y</span><br><span class="line">    &#125;)</span><br><span class="line">    println(calc_carried(<span class="number">10</span>, <span class="number">10</span>)(_ + _))</span><br><span class="line">    println(calc_carried(<span class="number">10.1</span>, <span class="number">10.2</span>)(_ * _))</span><br><span class="line">    println(calc_carried(<span class="number">100.2</span>, <span class="number">10</span>)(_ - _))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-闭包"><a href="#4-闭包" class="headerlink" title="4 闭包"></a>4 闭包</h3><p>闭包其实就是一个函数，只不过这个函数的返回值依赖于声明在函数外部的变量。可以简单认为，就是可以访问不在当前作用域范围的一个函数。</p>
<p><strong>定义一个闭包</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> y=<span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> add=(x:<span class="type">Int</span>)=&gt;&#123;</span><br><span class="line">    x+y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">println(add(<span class="number">5</span>)) <span class="comment">// 结果15</span></span><br></pre></td></tr></table></figure>

<p>add函数就是一个闭包</p>
<p><strong>柯里化就是一个闭包</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span></span>(x:<span class="type">Int</span>)(y:<span class="type">Int</span>) = &#123;</span><br><span class="line">    x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码相当于</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span></span>(x:<span class="type">Int</span>) = &#123;</span><br><span class="line">    (y:<span class="type">Int</span>) =&gt; x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="八、隐式转换与隐式参数"><a href="#八、隐式转换与隐式参数" class="headerlink" title="八、隐式转换与隐式参数"></a>八、隐式转换与隐式参数</h2><h3 id="1-使用隐式转换"><a href="#1-使用隐式转换" class="headerlink" title="1 使用隐式转换"></a>1 使用隐式转换</h3><p>隐式转换和隐式参数是scala非常有特色的功能，也是Java等其他编程语言没有的功能。我们可以很方便地利用隐式转换来丰富现有类的功能。所谓<strong>隐式转换</strong>，是指以<code>implicit</code>关键字声明的带有<strong>单个参数</strong>的方法。它是<strong>自动被调用</strong>的，自动将某种类型转换为另外一种类型。</p>
<p><strong>使用步骤</strong></p>
<ol>
<li>在object中定义隐式转换方法（使用implicit）</li>
<li>在需要用到隐式转换的地方，引入隐式转换（使用import）</li>
<li>自动调用隐式转化后的方法</li>
</ol>
<p><strong>示例：</strong>使用隐式转换，让File具备有read功能——实现将文本中的内容以字符串形式读取出来</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RichFile</span>(<span class="params">val file:<span class="type">File</span></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 读取文件为字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">read</span></span>() = &#123;</span><br><span class="line">        <span class="type">Source</span>.fromFile(file).mkString</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">RichFile</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义隐式转换方法</span></span><br><span class="line">    <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">file2RichFile</span></span>(file:<span class="type">File</span>) = <span class="keyword">new</span> <span class="type">RichFile</span>(file)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">// 加载文件</span></span><br><span class="line">    <span class="keyword">val</span> file = <span class="keyword">new</span> <span class="type">File</span>(<span class="string">&quot;./data/1.txt&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 导入隐式转换</span></span><br><span class="line">    <span class="keyword">import</span> <span class="type">RichFile</span>.file2RichFile</span><br><span class="line"></span><br><span class="line">    <span class="comment">// file对象具备有read方法</span></span><br><span class="line">    println(file.read())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>隐式转换的时机</strong></p>
<ul>
<li>当对象调用类中不存在的方法或者成员时，编译器会自动将对象进行隐式转换</li>
<li>当方法中的参数的类型与目标类型不一致时</li>
</ul>
<h3 id="2-自动导入隐式转换"><a href="#2-自动导入隐式转换" class="headerlink" title="2 自动导入隐式转换"></a>2 自动导入隐式转换</h3><p>前面，我们手动使用了import来导入隐式转换。是否可以不手动import呢？在scala中，如果在当前作用域中有隐式转换方法，会自动导入隐式转换。</p>
<p>示例：将隐式转换方法定义在main所在的object中</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RichFile</span>(<span class="params">val f:<span class="type">File</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 将文件中内容读取成字符串</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">read</span></span>() = <span class="type">Source</span>.fromFile(f).mkString</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ImplicitConvertDemo</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 定义隐式转换方法</span></span><br><span class="line">  <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">file2RichFile</span></span>(f:<span class="type">File</span>) = <span class="keyword">new</span> <span class="type">RichFile</span>(f)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> f = <span class="keyword">new</span> <span class="type">File</span>(<span class="string">&quot;./data/textfiles/1.txt&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用的其实是RichFile的read方法</span></span><br><span class="line">    println(f.read())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-隐式参数"><a href="#3-隐式参数" class="headerlink" title="3 隐式参数"></a>3 隐式参数</h3><p>方法可以带有一个标记为<code>implicit</code>的参数列表。这种情况，编译器会查找缺省值，提供给该方法。</p>
<ol>
<li>在方法后面添加一个参数列表，参数使用implicit修饰</li>
<li>在object中定义implicit修饰的隐式值</li>
<li>调用方法，可以不传入implicit修饰的参数列表，编译器会自动查找缺省值</li>
</ol>
<blockquote>
<p>[!NOTE]</p>
<ol>
<li>和隐式转换一样，可以使用import手动导入隐式参数</li>
<li>如果在当前作用域定义了隐式值，会自动进行导入</li>
</ol>
</blockquote>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用implicit定义一个参数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quote</span></span>(what:<span class="type">String</span>)(<span class="keyword">implicit</span> delimiter:(<span class="type">String</span>, <span class="type">String</span>)) = &#123;</span><br><span class="line">    delimiter._1 + what + delimiter._2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 隐式参数</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ImplicitParam</span> </span>&#123;</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">val</span> <span class="type">DEFAULT_DELIMITERS</span> = (<span class="string">&quot;&lt;&lt;&lt;&quot;</span>, <span class="string">&quot;&gt;&gt;&gt;&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">	<span class="comment">// 导入隐式参数</span></span><br><span class="line">    <span class="keyword">import</span> <span class="type">ImplicitParam</span>.<span class="type">DEFAULT_DELIMITERS</span></span><br><span class="line"></span><br><span class="line">    println(quote(<span class="string">&quot;李雷和韩梅梅&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="九、Akka并发编程框架"><a href="#九、Akka并发编程框架" class="headerlink" title="九、Akka并发编程框架"></a>九、Akka并发编程框架</h2><p>Akka是一个用于构建高并发、分布式和可扩展的基于事件驱动的应用的工具包。Akka是使用scala开发的库，同时可以使用scala和Java语言来开发基于Akka的应用程序。</p>
<p><strong>Akka</strong>特性</p>
<ul>
<li>提供基于异步非阻塞、高性能的事件驱动编程模型</li>
<li>内置容错机制，允许Actor在出错时进行恢复或者重置操作</li>
<li>超级轻量级的事件处理（每GB堆内存几百万Actor）</li>
<li>使用Akka可以在单机上构建高并发程序，也可以在网络中构建分布式程序。</li>
</ul>
<p><strong>Akka通信过程</strong></p>
<p>以下图片说明了Akka Actor的并发编程模型的基本流程：</p>
<ol>
<li>学生创建一个ActorSystem</li>
<li>通过ActorSystem来创建一个ActorRef（老师的引用），并将消息发送给ActorRef</li>
<li>ActorRef将消息发送给Message Dispatcher（消息分发器）</li>
<li>Message Dispatcher将消息按照顺序保存到目标Actor的MailBox中</li>
<li>Message Dispatcher将MailBox放到一个线程中</li>
<li>MailBox按照顺序取出消息，最终将它递给TeacherActor接受的方法中</li>
</ol>


<h3 id="1-案例入门"><a href="#1-案例入门" class="headerlink" title="1 案例入门"></a>1 案例入门</h3><p>基于Akka创建两个Actor，Actor之间可以互相发送消息。</p>


<p><strong>实现步骤</strong></p>
<ol>
<li><p>创建Maven模块</p>
<p>使用Akka需要导入Akka库，我们这里使用Maven来管理项目</p>
<ol>
<li>创建Maven模块</li>
<li>打开pom.xml文件，导入akka Maven依赖和插件</li>
</ol>
</li>
<li><p>创建并加载Actor</p>
<p>创建两个Actor</p>
<ul>
<li>SenderActor：用来发送消息</li>
<li>ReceiveActor：用来接收，回复消息</li>
</ul>
<p><strong>创建Actor</strong></p>
<ol>
<li>创建ActorSystem</li>
<li>创建自定义Actor</li>
<li>ActorSystem加载Actor</li>
</ol>
</li>
<li><p>发送/接收消息</p>
<ul>
<li>使用样例类封装消息</li>
<li>SubmitTaskMessage——提交任务消息</li>
<li>SuccessSubmitTaskMessage——任务提交成功消息</li>
<li>使用类似于之前学习的Actor方式，使用<code>!</code>发送异步消息</li>
</ul>
</li>
</ol>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">SubmitTaskMessage</span>(<span class="params">msg:<span class="type">String</span></span>)</span></span><br><span class="line"><span class="class"><span class="title">case</span> <span class="title">class</span> <span class="title">SuccessSubmitTaskMessage</span>(<span class="params">msg:<span class="type">String</span></span>)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="comment">// 注意：要导入的是Akka下的Actor</span></span></span><br><span class="line"><span class="class"><span class="title">object</span> <span class="title">SenderActor</span> <span class="keyword">extends</span> <span class="title">Actor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">preStart</span></span>(): <span class="type">Unit</span> = println(<span class="string">&quot;执行SenderActor的preStart()方法&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">receive</span></span>: <span class="type">Receive</span> = &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;start&quot;</span> =&gt;</span><br><span class="line">        <span class="keyword">val</span> receiveActor = <span class="keyword">this</span>.context.actorSelection(<span class="string">&quot;/user/receiverActor&quot;</span>)</span><br><span class="line">        receiveActor ! <span class="type">SubmitTaskMessage</span>(<span class="string">&quot;请完成#001任务!&quot;</span>)</span><br><span class="line">        <span class="keyword">case</span> <span class="type">SuccessSubmitTaskMessage</span>(msg) =&gt;</span><br><span class="line">        println(<span class="string">s&quot;接收到来自<span class="subst">$&#123;sender.path&#125;</span>的消息: <span class="subst">$msg</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ReceiverActor</span> <span class="keyword">extends</span> <span class="title">Actor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">preStart</span></span>(): <span class="type">Unit</span> = println(<span class="string">&quot;执行ReceiverActor()方法&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">receive</span></span>: <span class="type">Receive</span> = &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="type">SubmitTaskMessage</span>(msg) =&gt;</span><br><span class="line">        println(<span class="string">s&quot;接收到来自<span class="subst">$&#123;sender.path&#125;</span>的消息: <span class="subst">$msg</span>&quot;</span>)</span><br><span class="line">        sender ! <span class="type">SuccessSubmitTaskMessage</span>(<span class="string">&quot;完成提交&quot;</span>)</span><br><span class="line">        <span class="keyword">case</span> _ =&gt; println(<span class="string">&quot;未匹配的消息类型&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">SimpleAkkaDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">val</span> actorSystem = <span class="type">ActorSystem</span>(<span class="string">&quot;SimpleAkkaDemo&quot;</span>, <span class="type">ConfigFactory</span>.load())</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> senderActor: <span class="type">ActorRef</span> = actorSystem.actorOf(<span class="type">Props</span>(<span class="type">SenderActor</span>), <span class="string">&quot;senderActor&quot;</span>)</span><br><span class="line">        <span class="keyword">val</span> receiverActor: <span class="type">ActorRef</span> = actorSystem.actorOf(<span class="type">Props</span>(<span class="type">ReceiverActor</span>), <span class="string">&quot;receiverActor&quot;</span>)</span><br><span class="line"></span><br><span class="line">        senderActor ! <span class="string">&quot;start&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序输出：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">接收到来自akka://SimpleAkkaDemo/user/senderActor的消息: 请完成#001任务!</span><br><span class="line">接收到来自akka://SimpleAkkaDemo/user/receiverActor的消息: 完成提交</span><br></pre></td></tr></table></figure>

<h3 id="2-Akka定时任务"><a href="#2-Akka定时任务" class="headerlink" title="2 Akka定时任务"></a>2 Akka定时任务</h3><p>如果我们想要使用Akka框架定时的执行一些任务，该如何处理呢？Akka中，提供一个<strong>scheduler</strong>对象来实现定时调度功能。使用ActorSystem.scheduler.schedule方法，可以启动一个定时任务。schedule方法针对scala提供两种使用形式：</p>
<p><strong>第一种：发送消息</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">schedule</span></span>(</span><br><span class="line">    initialDelay: <span class="type">FiniteDuration</span>,		<span class="comment">// 延迟多久后启动定时任务</span></span><br><span class="line">    interval: <span class="type">FiniteDuration</span>,			<span class="comment">// 每隔多久执行一次</span></span><br><span class="line">    receiver: <span class="type">ActorRef</span>,					<span class="comment">// 给哪个Actor发送消息</span></span><br><span class="line">    message: <span class="type">Any</span>)						<span class="comment">// 要发送的消息</span></span><br><span class="line">(<span class="keyword">implicit</span> executor: <span class="type">ExecutionContext</span>)	<span class="comment">// 隐式参数：需要手动导入</span></span><br></pre></td></tr></table></figure>

<p><strong>第二种：自定义实现</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">schedule</span></span>(</span><br><span class="line">    initialDelay: <span class="type">FiniteDuration</span>,			<span class="comment">// 延迟多久后启动定时任务</span></span><br><span class="line">    interval: <span class="type">FiniteDuration</span>				<span class="comment">// 每隔多久执行一次</span></span><br><span class="line">)(f: ⇒ <span class="type">Unit</span>)								<span class="comment">// 定期要执行的函数，可以将逻辑写在这里</span></span><br><span class="line">(<span class="keyword">implicit</span> executor: <span class="type">ExecutionContext</span>)		<span class="comment">// 隐式参数：需要手动导入</span></span><br></pre></td></tr></table></figure>

<p><strong>示例一</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 创建一个Actor，用来接收消息，打印消息</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ReceiveActor</span> <span class="keyword">extends</span> <span class="title">Actor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">receive</span></span>: <span class="type">Receive</span> = &#123;</span><br><span class="line">        <span class="keyword">case</span> x =&gt; println(x)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 构建ActorSystem，加载Actor</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> actorSystem = <span class="type">ActorSystem</span>(<span class="string">&quot;actorSystem&quot;</span>, <span class="type">ConfigFactory</span>.load())</span><br><span class="line">    <span class="keyword">val</span> receiveActor = actorSystem.actorOf(<span class="type">Props</span>(<span class="type">ReceiveActor</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 启动scheduler，定期发送消息给Actor</span></span><br><span class="line">    <span class="comment">// 导入一个隐式转换</span></span><br><span class="line">    <span class="keyword">import</span> scala.concurrent.duration._</span><br><span class="line">    <span class="comment">// 导入隐式参数</span></span><br><span class="line">    <span class="keyword">import</span> actorSystem.dispatcher</span><br><span class="line"></span><br><span class="line">    actorSystem.scheduler.schedule(<span class="number">0</span> seconds,</span><br><span class="line">                                   <span class="number">1</span> seconds,</span><br><span class="line">                                   receiveActor, <span class="string">&quot;hello&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>示例二</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">SechdulerActor</span> <span class="keyword">extends</span> <span class="title">Actor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">receive</span></span>: <span class="type">Receive</span> = &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;timer&quot;</span> =&gt; println(<span class="string">&quot;收到消息...&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">AkkaSchedulerDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">val</span> actorSystem = <span class="type">ActorSystem</span>(<span class="string">&quot;SimpleAkkaDemo&quot;</span>, <span class="type">ConfigFactory</span>.load())</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> senderActor: <span class="type">ActorRef</span> = actorSystem.actorOf(<span class="type">Props</span>(<span class="type">SechdulerActor</span>), <span class="string">&quot;sechdulerActor&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">import</span> actorSystem.dispatcher</span><br><span class="line">        <span class="keyword">import</span> scala.concurrent.duration._</span><br><span class="line"></span><br><span class="line">        actorSystem.scheduler.schedule(<span class="number">0</span> seconds, <span class="number">1</span> seconds) &#123;</span><br><span class="line">            senderActor ! <span class="string">&quot;timer&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li>需要导入隐式转换<code>import scala.concurrent.duration._</code>才能调用0 seconds方法</li>
<li>需要导入隐式参数<code>import actorSystem.dispatcher</code>才能启动定时任务</li>
</ol>
</blockquote>
<h3 id="3-实现进程间通信-Master实现"><a href="#3-实现进程间通信-Master实现" class="headerlink" title="3 实现进程间通信-Master实现"></a>3 实现进程间通信-Master实现</h3><p>基于Akka实现在两个<strong>进程</strong>间发送、接收消息。Worker启动后去连接Master，并发送消息，Master接收到消息后，再回复Worker消息。</p>


<h4 id="3-1-Worker实现"><a href="#3-1-Worker实现" class="headerlink" title="3.1 Worker实现"></a>3.1 Worker实现</h4><p>Worker.scala</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> workerActorSystem = <span class="type">ActorSystem</span>(<span class="string">&quot;actorSystem&quot;</span>, <span class="type">ConfigFactory</span>.load())</span><br><span class="line"><span class="keyword">val</span> workerActor: <span class="type">ActorRef</span> = workerActorSystem.actorOf(<span class="type">Props</span>(<span class="type">WorkerActor</span>), <span class="string">&quot;WorkerActor&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送消息给WorkerActor</span></span><br><span class="line">workerActor ! <span class="string">&quot;setup&quot;</span></span><br></pre></td></tr></table></figure>

<p>WorkerActor.scala</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">WorkerActor</span> <span class="keyword">extends</span> <span class="title">Actor</span></span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">receive</span></span>: <span class="type">Receive</span> = &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;setup&quot;</span> =&gt;</span><br><span class="line">      println(<span class="string">&quot;WorkerActor:启动Worker&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-2-Master实现"><a href="#3-2-Master实现" class="headerlink" title="3.2 Master实现"></a>3.2 Master实现</h4><p>Master.scala</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> masterActorSystem = <span class="type">ActorSystem</span>(<span class="string">&quot;MasterActorSystem&quot;</span>, <span class="type">ConfigFactory</span>.load())</span><br><span class="line"><span class="keyword">val</span> masterActor: <span class="type">ActorRef</span> = masterActorSystem.actorOf(<span class="type">Props</span>(<span class="type">MasterActor</span>), <span class="string">&quot;MasterActor&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>MasterActor.scala</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MasterActor</span> <span class="keyword">extends</span> <span class="title">Actor</span></span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">receive</span></span>: <span class="type">Receive</span> = &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;connect&quot;</span> =&gt;</span><br><span class="line">      println(<span class="string">&quot;2. Worker连接到Master&quot;</span>)</span><br><span class="line">      sender ! <span class="string">&quot;success&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>WorkerActor.scala</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">WorkerActor</span> <span class="keyword">extends</span> <span class="title">Actor</span></span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">receive</span></span>: <span class="type">Receive</span> = &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;setup&quot;</span> =&gt;</span><br><span class="line">      println(<span class="string">&quot;1. 启动Worker...&quot;</span>)</span><br><span class="line">      <span class="keyword">val</span> masterActor = context.actorSelection(<span class="string">&quot;akka.tcp://MasterActorSystem@127.0.0.1:9999/user/MasterActor&quot;</span>)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 发送connect</span></span><br><span class="line">      masterActor ! <span class="string">&quot;connect&quot;</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;success&quot;</span> =&gt;</span><br><span class="line">      println(<span class="string">&quot;3. 连接Master成功...&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-简易Spark通信框架案例ni"><a href="#4-简易Spark通信框架案例ni" class="headerlink" title="4 简易Spark通信框架案例ni"></a>4 简易Spark通信框架案例ni</h3><p>模拟Spark的Master与Worker通信</p>
<ul>
<li>一个Master<ul>
<li>管理Worker</li>
</ul>
</li>
<li>若干个Worker（Worker可以按需添加）<ul>
<li>注册</li>
<li>发送心跳</li>
</ul>
</li>
</ul>


<p><strong>实现思路</strong></p>
<ol>
<li><p>构建Master、Worker阶段</p>
<ul>
<li>构建Master ActorSystem、Actor</li>
<li>构建Worker ActorSystem、Actor</li>
</ul>
</li>
<li><p>Worker注册阶段</p>
<ul>
<li>Worker进程向Master注册（将自己的ID、CPU核数、内存大小(M)发送给Master）</li>
</ul>
</li>
<li><p>Worker定时发送心跳阶段</p>
<ul>
<li>Worker定期向Master发送心跳消息</li>
</ul>
</li>
<li><p>Master定时心跳检测阶段</p>
<ul>
<li>Master定期检查Worker心跳，将一些超时的Worker移除，并对Worker按照内存进行倒序排序</li>
</ul>
</li>
<li><p>多个Worker测试阶段</p>
<ul>
<li>启动多个Worker，查看是否能够注册成功，并停止某个Worker查看是否能够正确移除</li>
</ul>
</li>
</ol>
<h4 id="4-1工程搭建"><a href="#4-1工程搭建" class="headerlink" title="4.1工程搭建"></a>4.1工程搭建</h4><p>项目使用Maven搭建工程</p>
<p><strong>步骤</strong></p>
<ol>
<li>分别搭建几下几个项目</li>
</ol>
<table>
<thead>
<tr>
<th>工程名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>spark-demo-common</td>
<td>存放公共的消息、实体类</td>
</tr>
<tr>
<td>spark-demo-master</td>
<td>Akka Master节点</td>
</tr>
<tr>
<td>spark-demo-worker</td>
<td>Akka Worker节点</td>
</tr>
</tbody></table>
<ol start="2">
<li>导入依赖(资料包中的pom.xml)<ul>
<li>master/worker添加common依赖</li>
</ul>
</li>
<li>导入配置文件(资料包中的application.conf)<ul>
<li>修改Master的端口为7000</li>
<li>修改Worker的端口为7100</li>
</ul>
</li>
</ol>
<h4 id="4-2-构建Master和Worker"><a href="#4-2-构建Master和Worker" class="headerlink" title="4.2 构建Master和Worker"></a>4.2 构建Master和Worker</h4><p>分别构建Master和Worker，并启动测试</p>
<p><strong>步骤</strong></p>
<ol>
<li>创建并加载Master Actor</li>
<li>创建并加载Worker Actor</li>
<li>测试是否能够启动成功</li>
</ol>
<p>Master.scala</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> sparkMasterActorSystem = <span class="type">ActorSystem</span>(<span class="string">&quot;sparkMaster&quot;</span>, <span class="type">ConfigFactory</span>.load())</span><br><span class="line"><span class="keyword">val</span> masterActor = sparkMasterActorSystem.actorOf(<span class="type">Props</span>(<span class="type">MasterActor</span>), <span class="string">&quot;masterActor&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>MasterActor.scala</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MasterActor</span> <span class="keyword">extends</span> <span class="title">Actor</span></span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">receive</span></span>: <span class="type">Receive</span> = &#123;</span><br><span class="line">    <span class="keyword">case</span> x =&gt; println(x)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Worker.scala</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> sparkWorkerActorSystem = <span class="type">ActorSystem</span>(<span class="string">&quot;sparkWorker&quot;</span>, <span class="type">ConfigFactory</span>.load())</span><br><span class="line">sparkWorkerActorSystem.actorOf(<span class="type">Props</span>(<span class="type">WorkerActor</span>), <span class="string">&quot;workerActor&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>WorkerActor.scala</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">WorkerActor</span> <span class="keyword">extends</span> <span class="title">Actor</span></span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">receive</span></span>: <span class="type">Receive</span> = &#123;</span><br><span class="line">    <span class="keyword">case</span> x =&gt; println(x)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-3-Worker注册阶段实现"><a href="#4-3-Worker注册阶段实现" class="headerlink" title="4.3 Worker注册阶段实现"></a>4.3 Worker注册阶段实现</h4><p>在Worker启动时，发送注册消息给Master</p>
<p><strong>步骤</strong></p>
<ol>
<li>Worker向Master发送注册消息（workerid、cpu核数、内存大小）<ul>
<li>随机生成CPU核（1、2、3、4、6、8）</li>
<li>随机生成内存大小（512、1024、2048、4096）（单位M）</li>
</ul>
</li>
<li>Master保存Worker信息，并给Worker回复注册成功消息</li>
<li>启动测试</li>
</ol>
<p>MasterActor.scala</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MasterActor</span> <span class="keyword">extends</span> <span class="title">Actor</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> regWorkerMap = collection.mutable.<span class="type">Map</span>[<span class="type">String</span>, <span class="type">WorkerInfo</span>]()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">receive</span></span>: <span class="type">Receive</span> = &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">WorkerRegisterMessage</span>(workerId, cpu, mem) =&gt; &#123;</span><br><span class="line">      println(<span class="string">s&quot;1. 注册新的Worker - <span class="subst">$&#123;workerId&#125;</span>/<span class="subst">$&#123;cpu&#125;</span>核/<span class="subst">$&#123;mem/1024.0&#125;</span>G&quot;</span>)</span><br><span class="line">      regWorkerMap += workerId -&gt; <span class="type">WorkerInfo</span>(workerId, cpu, mem, <span class="keyword">new</span> <span class="type">Date</span>().getTime)</span><br><span class="line">      sender ! <span class="type">RegisterSuccessMessage</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>WorkerInfo.scala</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 工作节点信息</span></span><br><span class="line"><span class="comment">  * @param workerId workerid</span></span><br><span class="line"><span class="comment">  * @param cpu CPU核数</span></span><br><span class="line"><span class="comment">  * @param mem 内存多少</span></span><br><span class="line"><span class="comment">  * @param lastHeartBeatTime 最后心跳更新时间</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkerInfo</span>(<span class="params">workerId:<span class="type">String</span>, cpu:<span class="type">Int</span>, mem:<span class="type">Int</span>, lastHeartBeatTime:<span class="type">Long</span></span>)</span></span><br></pre></td></tr></table></figure>

<p>MessagePackage.scala</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 注册消息</span></span><br><span class="line"><span class="comment">  * @param workerId</span></span><br><span class="line"><span class="comment">  * @param cpu CPU核数</span></span><br><span class="line"><span class="comment">  * @param mem 内存大小</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkerRegisterMessage</span>(<span class="params">workerId:<span class="type">String</span>, cpu:<span class="type">Int</span>, mem:<span class="type">Int</span></span>)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="comment">/**</span></span></span><br><span class="line"><span class="class"><span class="comment">  * 注册成功消息</span></span></span><br><span class="line"><span class="class"><span class="comment">  */</span></span></span><br><span class="line"><span class="class"><span class="title">case</span> <span class="title">object</span> <span class="title">RegisterSuccessMessage</span></span></span><br></pre></td></tr></table></figure>

<p>WorkerActor.scala</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">WorkerActor</span> <span class="keyword">extends</span> <span class="title">Actor</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> masterActor:<span class="type">ActorSelection</span> = _</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> <span class="type">CPU_LIST</span> = <span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>)</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> <span class="type">MEM_LIST</span> = <span class="type">List</span>(<span class="number">512</span>, <span class="number">1024</span>, <span class="number">2048</span>, <span class="number">4096</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">preStart</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">    masterActor = context.system.actorSelection(<span class="string">&quot;akka.tcp://sparkMaster@127.0.0.1:7000/user/masterActor&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> random = <span class="keyword">new</span> <span class="type">Random</span>()</span><br><span class="line">    <span class="keyword">val</span> workerId = <span class="type">UUID</span>.randomUUID().toString.hashCode.toString</span><br><span class="line">    <span class="keyword">val</span> cpu = <span class="type">CPU_LIST</span>(random.nextInt(<span class="type">CPU_LIST</span>.length))</span><br><span class="line">    <span class="keyword">val</span> mem = <span class="type">MEM_LIST</span>(random.nextInt(<span class="type">MEM_LIST</span>.length))</span><br><span class="line"></span><br><span class="line">    masterActor ! <span class="type">WorkerRegisterMessage</span>(workerId, cpu, mem)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-4-Worker定时发送心跳阶段"><a href="#4-4-Worker定时发送心跳阶段" class="headerlink" title="4.4 Worker定时发送心跳阶段"></a>4.4 Worker定时发送心跳阶段</h4><p>Worker接收到Master返回注册成功后，发送心跳消息。而Master收到Worker发送的心跳消息后，需要更新对应Worker的最后心跳时间。</p>
<p><strong>步骤</strong></p>
<ol>
<li>编写工具类读取心跳发送时间间隔</li>
<li>创建心跳消息</li>
<li>Worker接收到注册成功后，定时发送心跳消息</li>
<li>Master收到心跳消息，更新Worker最后心跳时间</li>
<li>启动测试</li>
</ol>
<p>ConfigUtil.scala</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ConfigUtil</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> config: <span class="type">Config</span> = <span class="type">ConfigFactory</span>.load()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> `worker.heartbeat.interval` = config.getInt(<span class="string">&quot;worker.heartbeat.interval&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>MessagePackage.scala</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.spark.common</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Worker心跳消息</span></span><br><span class="line"><span class="comment">  * @param workerId</span></span><br><span class="line"><span class="comment">  * @param cpu CPU核数</span></span><br><span class="line"><span class="comment">  * @param mem 内存大小</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkerHeartBeatMessage</span>(<span class="params">workerId:<span class="type">String</span>, cpu:<span class="type">Int</span>, mem:<span class="type">Int</span></span>)</span></span><br></pre></td></tr></table></figure>

<p>WorkerActor.scala</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">WorkerActor</span> <span class="keyword">extends</span> <span class="title">Actor</span></span>&#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">receive</span></span>: <span class="type">Receive</span> = &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">RegisterSuccessMessage</span> =&gt; &#123;</span><br><span class="line">      println(<span class="string">&quot;2. 成功注册到Master&quot;</span>)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">import</span> scala.concurrent.duration._</span><br><span class="line">      <span class="keyword">import</span> context.dispatcher</span><br><span class="line"></span><br><span class="line">      context.system.scheduler.schedule(<span class="number">0</span> seconds,</span><br><span class="line">        <span class="type">ConfigUtil</span>.`worker.heartbeat.interval` seconds)&#123;</span><br><span class="line">        <span class="comment">// 发送心跳消息</span></span><br><span class="line">        masterActor ! <span class="type">WorkerHeartBeatMessage</span>(workerId, cpu, mem)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MasterActor.scala</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MasterActor</span> <span class="keyword">extends</span> <span class="title">Actor</span></span>&#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">receive</span></span>: <span class="type">Receive</span> = &#123;</span><br><span class="line">	...</span><br><span class="line">    <span class="keyword">case</span> <span class="type">WorkerHeartBeatMessage</span>(workerId, cpu, mem) =&gt; &#123;</span><br><span class="line">      println(<span class="string">&quot;3. 接收到心跳消息, 更新最后心跳时间&quot;</span>)</span><br><span class="line">      regWorkerMap += workerId -&gt; <span class="type">WorkerInfo</span>(workerId, cpu, mem, <span class="keyword">new</span> <span class="type">Date</span>().getTime)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-5-Master定时心跳检测阶段"><a href="#4-5-Master定时心跳检测阶段" class="headerlink" title="4.5 Master定时心跳检测阶段"></a>4.5 Master定时心跳检测阶段</h4><p>如果某个worker超过一段时间没有发送心跳，Master需要将该worker从当前的Worker集合中移除。可以通过Akka的定时任务，来实现心跳超时检查。</p>
<p><strong>步骤</strong></p>
<ol>
<li>编写工具类，读取检查心跳间隔时间间隔、超时时间</li>
<li>定时检查心跳，过滤出来大于超时时间的Worker</li>
<li>移除超时的Worker</li>
<li>对现有Worker按照内存进行降序排序，打印可用Worker</li>
</ol>
<p>ConfigUtil.scala</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ConfigUtil</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> config: <span class="type">Config</span> = <span class="type">ConfigFactory</span>.load()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 心跳检查时间间隔</span></span><br><span class="line">  <span class="keyword">val</span> `master.heartbeat.check.interval` = config.getInt(<span class="string">&quot;master.heartbeat.check.interval&quot;</span>)</span><br><span class="line">  <span class="comment">// 心跳超时时间</span></span><br><span class="line">  <span class="keyword">val</span> `master.heartbeat.check.timeout` = config.getInt(<span class="string">&quot;master.heartbeat.check.timeout&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MasterActor.scala</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">preStart</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">import</span> scala.concurrent.duration._</span><br><span class="line">    <span class="keyword">import</span> context.dispatcher</span><br><span class="line"></span><br><span class="line">    context.system.scheduler.schedule(<span class="number">0</span> seconds,</span><br><span class="line">      <span class="type">ConfigUtil</span>.`master.heartbeat.check.interval` seconds) &#123;</span><br><span class="line">      <span class="comment">// 过滤出来超时的worker</span></span><br><span class="line">      <span class="keyword">val</span> timeoutWorkerList = regWorkerMap.filter &#123;</span><br><span class="line">        kv =&gt;</span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">new</span> <span class="type">Date</span>().getTime - kv._2.lastHeartBeatTime &gt; <span class="type">ConfigUtil</span>.`master.heartbeat.check.timeout` * <span class="number">1000</span>) &#123;</span><br><span class="line">            <span class="literal">true</span></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="literal">false</span></span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!timeoutWorkerList.isEmpty) &#123;</span><br><span class="line">        regWorkerMap --= timeoutWorkerList.map(_._1)</span><br><span class="line">        println(<span class="string">&quot;移除超时的worker:&quot;</span>)</span><br><span class="line">        timeoutWorkerList.map(_._2).foreach &#123;</span><br><span class="line">          println(_)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!regWorkerMap.isEmpty) &#123;</span><br><span class="line">        <span class="keyword">val</span> sortedWorkerList = regWorkerMap.map(_._2).toList.sortBy(_.mem).reverse</span><br><span class="line">        println(<span class="string">&quot;可用的Worker列表:&quot;</span>)</span><br><span class="line">        sortedWorkerList.foreach &#123;</span><br><span class="line">          <span class="keyword">var</span> rank = <span class="number">1</span></span><br><span class="line">          workerInfo =&gt;</span><br><span class="line">            println(<span class="string">s&quot;&lt;<span class="subst">$&#123;rank&#125;</span>&gt; <span class="subst">$&#123;workerInfo.workerId&#125;</span>/<span class="subst">$&#123;workerInfo.mem&#125;</span>/<span class="subst">$&#123;workerInfo.cpu&#125;</span>&quot;</span>)</span><br><span class="line">            rank = rank + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-6-多个Worker测试阶段"><a href="#4-6-多个Worker测试阶段" class="headerlink" title="4.6 多个Worker测试阶段"></a>4.6 多个Worker测试阶段</h4><p>修改配置文件，启动多个worker进行测试。</p>
<p><strong>步骤</strong></p>
<ol>
<li>测试启动新的Worker是否能够注册成功</li>
<li>停止Worker，测试是否能够从现有列表删除</li>
</ol>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/scala/" rel="tag"># scala</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2020/01/13/%E4%BD%BF%E7%94%A8java-API%E6%93%8D%E4%BD%9Chbase%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%E7%9A%84%E5%87%A0%E4%B8%AA%E6%93%8D%E4%BD%9C%E7%A4%BA%E4%BE%8B/" rel="prev" title="使用java API操作hbase增删改查的几个操作示例">
                  <i class="fa fa-chevron-left"></i> 使用java API操作hbase增删改查的几个操作示例
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2020/01/15/Hbase%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="next" title="Hbase学习笔记">
                  Hbase学习笔记 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>





<script src="/js/comments.js"></script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">浙ICP备18041583号-1 </a>
      <img src="/images/beian.png">
  </div>

<div class="copyright">
  &copy; 2018 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Mr.wj</span>
</div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
