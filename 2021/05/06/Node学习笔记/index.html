<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css">

<script class="next-config" data-name="main" type="application/json">{&quot;hostname&quot;:&quot;www.wjqixige.cn&quot;,&quot;root&quot;:&quot;&#x2F;&quot;,&quot;images&quot;:&quot;&#x2F;images&quot;,&quot;scheme&quot;:&quot;Gemini&quot;,&quot;version&quot;:&quot;8.3.0&quot;,&quot;exturl&quot;:false,&quot;sidebar&quot;:{&quot;position&quot;:&quot;left&quot;,&quot;display&quot;:&quot;post&quot;,&quot;padding&quot;:18,&quot;offset&quot;:12},&quot;copycode&quot;:false,&quot;bookmark&quot;:{&quot;enable&quot;:false,&quot;color&quot;:&quot;#222&quot;,&quot;save&quot;:&quot;auto&quot;},&quot;fancybox&quot;:false,&quot;mediumzoom&quot;:false,&quot;lazyload&quot;:false,&quot;pangu&quot;:false,&quot;comments&quot;:{&quot;style&quot;:&quot;tabs&quot;,&quot;active&quot;:null,&quot;storage&quot;:true,&quot;lazyload&quot;:false,&quot;nav&quot;:null},&quot;motion&quot;:{&quot;enable&quot;:false,&quot;async&quot;:false,&quot;transition&quot;:{&quot;post_block&quot;:&quot;fadeIn&quot;,&quot;post_header&quot;:&quot;fadeInDown&quot;,&quot;post_body&quot;:&quot;fadeInDown&quot;,&quot;coll_header&quot;:&quot;fadeInLeft&quot;,&quot;sidebar&quot;:&quot;fadeInUp&quot;}},&quot;prism&quot;:false,&quot;i18n&quot;:{&quot;placeholder&quot;:&quot;搜索...&quot;,&quot;empty&quot;:&quot;没有找到任何搜索结果：${query}&quot;,&quot;hits_time&quot;:&quot;找到 ${hits} 个搜索结果（用时 ${time} 毫秒）&quot;,&quot;hits&quot;:&quot;找到 ${hits} 个搜索结果&quot;}}</script>
<meta name="description" content="Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。Node.js 的官网地址: https:&#x2F;&#x2F;nodejs.org&#x2F;zh-cn&#x2F;">
<meta property="og:type" content="article">
<meta property="og:title" content="Node学习笔记">
<meta property="og:url" content="http://www.wjqixige.cn/2021/05/06/Node%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="栖溪阁晓生">
<meta property="og:description" content="Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。Node.js 的官网地址: https:&#x2F;&#x2F;nodejs.org&#x2F;zh-cn&#x2F;">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://www.wjqixige.cn/2021/05/06/Node%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/node001.png">
<meta property="og:image" content="http://www.wjqixige.cn/2021/05/06/Node%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/node002.png">
<meta property="og:image" content="http://www.wjqixige.cn/2021/05/06/Node%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/node003.png">
<meta property="og:image" content="http://www.wjqixige.cn/2021/05/06/Node%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/node004.png">
<meta property="og:image" content="http://www.wjqixige.cn/2021/05/06/Node%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/node005.png">
<meta property="og:image" content="http://www.wjqixige.cn/2021/05/06/Node%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/node006.png">
<meta property="og:image" content="http://www.wjqixige.cn/2021/05/06/Node%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/node007.png">
<meta property="og:image" content="http://www.wjqixige.cn/2021/05/06/Node%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/node009.png">
<meta property="og:image" content="http://www.wjqixige.cn/2021/05/06/Node%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/node010.png">
<meta property="og:image" content="http://www.wjqixige.cn/2021/05/06/Node%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/node011.png">
<meta property="og:image" content="http://www.wjqixige.cn/2021/05/06/Node%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/node012.png">
<meta property="og:image" content="http://www.wjqixige.cn/2021/05/06/Node%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/node013.png">
<meta property="og:image" content="http://www.wjqixige.cn/2021/05/06/Node%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/node014.png">
<meta property="og:image" content="http://www.wjqixige.cn/2021/05/06/Node%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/node015.png">
<meta property="og:image" content="http://www.wjqixige.cn/2021/05/06/Node%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/node016.png">
<meta property="og:image" content="http://www.wjqixige.cn/2021/05/06/Node%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/node017.png">
<meta property="og:image" content="http://www.wjqixige.cn/2021/05/06/Node%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/node018.png">
<meta property="og:image" content="http://www.wjqixige.cn/2021/05/06/Node%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/node020.png">
<meta property="og:image" content="http://www.wjqixige.cn/2021/05/06/Node%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/node021.png">
<meta property="og:image" content="http://www.wjqixige.cn/2021/05/06/Node%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/node022.png">
<meta property="og:image" content="http://www.wjqixige.cn/2021/05/06/Node%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/node023.png">
<meta property="og:image" content="http://www.wjqixige.cn/2021/05/06/Node%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/node024.png">
<meta property="og:image" content="http://www.wjqixige.cn/2021/05/06/Node%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/node025.png">
<meta property="og:image" content="http://www.wjqixige.cn/2021/05/06/Node%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/node026.png">
<meta property="og:image" content="http://www.wjqixige.cn/2021/05/06/Node%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/node027.png">
<meta property="og:image" content="http://www.wjqixige.cn/2021/05/06/Node%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/node029.png">
<meta property="og:image" content="http://www.wjqixige.cn/2021/05/06/Node%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/node030.png">
<meta property="og:image" content="http://www.wjqixige.cn/2021/05/06/Node%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/node031.png">
<meta property="og:image" content="http://www.wjqixige.cn/2021/05/06/Node%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/node032.png">
<meta property="og:image" content="http://www.wjqixige.cn/2021/05/06/Node%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/node033.png">
<meta property="og:image" content="http://www.wjqixige.cn/2021/05/06/Node%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/node034.png">
<meta property="og:image" content="http://www.wjqixige.cn/2021/05/06/Node%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/node035.png">
<meta property="og:image" content="http://www.wjqixige.cn/2021/05/06/Node%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/node036.png">
<meta property="article:published_time" content="2021-05-06T03:16:50.000Z">
<meta property="article:modified_time" content="2021-05-14T14:49:53.053Z">
<meta property="article:author" content="Mr.wj">
<meta property="article:tag" content="node">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://www.wjqixige.cn/2021/05/06/Node%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/node001.png">


<link rel="canonical" href="http://www.wjqixige.cn/2021/05/06/Node%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">



<script class="next-config" data-name="page" type="application/json">{&quot;sidebar&quot;:&quot;&quot;,&quot;isHome&quot;:false,&quot;isPost&quot;:true,&quot;lang&quot;:&quot;zh-CN&quot;,&quot;comments&quot;:true,&quot;permalink&quot;:&quot;http:&#x2F;&#x2F;www.wjqixige.cn&#x2F;2021&#x2F;05&#x2F;06&#x2F;Node%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0&#x2F;&quot;,&quot;path&quot;:&quot;2021&#x2F;05&#x2F;06&#x2F;Node学习笔记&#x2F;&quot;,&quot;title&quot;:&quot;Node学习笔记&quot;}</script>

<script class="next-config" data-name="calendar" type="application/json">&quot;&quot;</script>
<title>Node学习笔记 | 栖溪阁晓生</title><script src="/js/config.js"></script>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">栖溪阁晓生</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">个人在线笔记本</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#01%E3%80%81%E5%86%85%E7%BD%AE%E6%A8%A1%E5%9D%97"><span class="nav-text">01、内置模块</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A8%A1%E5%9D%97"><span class="nav-text">1 fs文件系统模块</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9"><span class="nav-text">1.1 读取文件内容</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-%E5%86%99%E5%85%A5%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9"><span class="nav-text">1.2 写入文件内容</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-%E8%B7%AF%E5%BE%84%E5%8A%A8%E6%80%81%E6%8B%BC%E6%8E%A5%E9%97%AE%E9%A2%98"><span class="nav-text">1.3 路径动态拼接问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-path%E8%B7%AF%E5%BE%84%E6%A8%A1%E5%9D%97"><span class="nav-text">2 path路径模块</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-%E8%B7%AF%E5%BE%84%E6%8B%BC%E6%8E%A5"><span class="nav-text">2.1 路径拼接</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-%E8%8E%B7%E5%8F%96%E8%B7%AF%E5%BE%84%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6%E5%90%8D"><span class="nav-text">2.2 获取路径中的文件名</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-%E8%8E%B7%E5%8F%96%E8%B7%AF%E5%BE%84%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6%E6%89%A9%E5%B1%95%E5%90%8D"><span class="nav-text">2.3 获取路径中的文件扩展名</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-http%E6%A8%A1%E5%9D%97"><span class="nav-text">3 http模块</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-http%E6%A8%A1%E5%9D%97%E4%BD%9C%E7%94%A8"><span class="nav-text">3.1 http模块作用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5"><span class="nav-text">3.2 服务器相关概念</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#3-2-1-IP%E5%9C%B0%E5%9D%80"><span class="nav-text">3.2.1 IP地址</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-2-2-%E5%9F%9F%E5%90%8D%E5%92%8C%E5%9F%9F%E5%90%8D%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="nav-text">3.2.2 域名和域名服务器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-2-3-%E7%AB%AF%E5%8F%A3%E5%8F%B7"><span class="nav-text">3.2.3 端口号</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-%E5%88%9B%E5%BB%BA%E5%9F%BA%E6%9C%ACweb%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="nav-text">3.3 创建基本web服务器</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#3-3-1-%E5%88%9B%E5%BB%BA%E6%AD%A5%E9%AA%A4"><span class="nav-text">3.3.1 创建步骤</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-3-2-req%E8%AF%B7%E6%B1%82%E5%AF%B9%E8%B1%A1"><span class="nav-text">3.3.2 req请求对象</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-3-3-res%E5%93%8D%E5%BA%94%E5%AF%B9%E8%B1%A1"><span class="nav-text">3.3.3 res响应对象</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-3-4-%E8%A7%A3%E5%86%B3%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98"><span class="nav-text">3.3.4 解决中文乱码问题</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-%E6%A0%B9%E6%8D%AE%E4%B8%8D%E5%90%8Curl%E5%93%8D%E5%BA%94%E4%B8%8D%E5%90%8Chtml%E5%86%85%E5%AE%B9"><span class="nav-text">3.4 根据不同url响应不同html内容</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#02%E3%80%81%E6%A8%A1%E5%9D%97%E5%8C%96"><span class="nav-text">02、模块化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-text">1 基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-%E6%A8%A1%E5%9D%97%E5%8C%96%E8%A7%84%E8%8C%83"><span class="nav-text">1.1 模块化规范</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-node%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%9D%97%E5%8C%96"><span class="nav-text">2 node中的模块化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-%E6%A8%A1%E5%9D%97%E7%9A%84%E5%88%86%E7%B1%BB"><span class="nav-text">2.1 模块的分类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-%E5%8A%A0%E8%BD%BD%E6%A8%A1%E5%BF%AB"><span class="nav-text">2.2 加载模快</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-%E6%A8%A1%E5%9D%97%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-text">2.3 模块作用域</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-%E5%90%91%E5%A4%96%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9D%97%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%AD%E7%9A%84%E6%88%90%E5%91%98"><span class="nav-text">2.4 向外共享模块作用域中的成员</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#2-4-1-module%E5%AF%B9%E8%B1%A1"><span class="nav-text">2.4.1 module对象</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-4-2-module-exports%E5%AF%B9%E8%B1%A1"><span class="nav-text">2.4.2 module.exports对象</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-4-3-%E6%B3%A8%E6%84%8F%E7%82%B9"><span class="nav-text">2.4.3 注意点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-4-4-exports%E5%AF%B9%E8%B1%A1"><span class="nav-text">2.4.4 exports对象</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-4-5-Node-js-%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%9D%97%E5%8C%96%E8%A7%84%E8%8C%83"><span class="nav-text">2.4.5 Node.js 中的模块化规范</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-npm%E4%B8%8E%E5%8C%85"><span class="nav-text">3 npm与包</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-%E5%8C%85"><span class="nav-text">3.1 包</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#3-1-1-%E6%9D%A5%E6%BA%90"><span class="nav-text">3.1.1 来源</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-1-2-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%8C%85"><span class="nav-text">3.1.2 为什么需要包</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-1-3-%E5%93%AA%E9%87%8C%E4%B8%8B%E8%BD%BD%E5%8C%85"><span class="nav-text">3.1.3 哪里下载包</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-1-4-%E5%A6%82%E4%BD%95%E4%B8%8B%E8%BD%BD"><span class="nav-text">3.1.4 如何下载</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-npm"><span class="nav-text">3.2 npm</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#3-2-1-%E4%B8%8B%E8%BD%BD%E5%8C%85%E5%91%BD%E4%BB%A4"><span class="nav-text">3.2.1 下载包命令</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-2-2-%E5%88%9D%E6%AC%A1%E8%A3%85%E5%8C%85%E5%90%8E%E5%A4%9A%E4%BA%86%E5%93%AA%E4%BA%9B%E6%96%87%E4%BB%B6"><span class="nav-text">3.2.2 初次装包后多了哪些文件</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-2-3-%E5%8C%85%E7%9A%84%E8%AF%AD%E4%B9%89%E5%8C%96%E7%89%88%E6%9C%AC%E8%A7%84%E8%8C%83"><span class="nav-text">3.2.3 包的语义化版本规范</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-%E5%8C%85%E7%AE%A1%E7%90%86%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="nav-text">3.3 包管理配置文件</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#3-3-1-%E5%A4%9A%E4%BA%BA%E5%8D%8F%E4%BD%9C%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-text">3.3.1 多人协作的问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-3-2-%E5%A6%82%E4%BD%95%E8%AE%B0%E5%BD%95%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%AE%89%E8%A3%85%E4%BA%86%E5%93%AA%E4%BA%9B%E5%8C%85"><span class="nav-text">3.3.2 如何记录项目中安装了哪些包</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-3-3-%E5%BF%AB%E9%80%9F%E5%88%9B%E5%BB%BApackage-json"><span class="nav-text">3.3.3 快速创建package.json</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-3-4-dependencies%E8%8A%82%E7%82%B9"><span class="nav-text">3.3.4 dependencies节点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-3-5-%E4%B8%80%E6%AC%A1%E6%80%A7%E5%AE%89%E8%A3%85%E6%89%80%E6%9C%89%E5%8C%85"><span class="nav-text">3.3.5 一次性安装所有包</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-3-6-%E5%8D%B8%E8%BD%BD%E5%8C%85"><span class="nav-text">3.3.6 卸载包</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-3-7-devDependencies%E8%8A%82%E7%82%B9"><span class="nav-text">3.3.7 devDependencies节点</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-%E8%A7%A3%E5%86%B3%E4%B8%8B%E5%8C%85%E9%80%9F%E5%BA%A6%E6%85%A2%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-text">3.4 解决下包速度慢的问题</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#3-4-1-%E5%88%87%E6%8D%A2npm%E7%9A%84%E4%B8%8B%E5%8C%85%E9%95%9C%E5%83%8F%E6%BA%90"><span class="nav-text">3.4.1 切换npm的下包镜像源</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-4-2-nrm"><span class="nav-text">3.4.2 nrm</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-%E5%8C%85%E7%9A%84%E5%88%86%E7%B1%BB"><span class="nav-text">3.4 包的分类</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#3-4-1-%E9%A1%B9%E7%9B%AE%E5%8C%85"><span class="nav-text">3.4.1 项目包</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-4-2-%E5%85%A8%E5%B1%80%E5%8C%85"><span class="nav-text">3.4.2 全局包</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-4-3-i5ting-toc"><span class="nav-text">3.4.3 i5ting_toc</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-%E8%A7%84%E8%8C%83%E7%9A%84%E5%8C%85%E7%BB%93%E6%9E%84"><span class="nav-text">3.5 规范的包结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-6-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8C%85"><span class="nav-text">3.6 自定义包</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-7-%E5%8F%91%E5%B8%83%E5%8C%85"><span class="nav-text">3.7 发布包</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#3-7-1-%E6%B3%A8%E5%86%8Cnpm%E8%B4%A6%E5%8F%B7"><span class="nav-text">3.7.1 注册npm账号</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-7-2-%E7%99%BB%E5%BD%95npm%E8%B4%A6%E5%8F%B7"><span class="nav-text">3.7.2 登录npm账号</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-7-3-%E6%8A%8A%E5%8C%85%E5%8F%91%E5%B8%83%E5%88%B0npm%E4%B8%8A"><span class="nav-text">3.7.3 把包发布到npm上</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-7-4-%E5%88%A0%E9%99%A4%E5%B7%B2%E5%8F%91%E5%B8%83%E7%9A%84%E5%8C%85"><span class="nav-text">3.7.4 删除已发布的包</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E6%A8%A1%E5%9D%97%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6"><span class="nav-text">4 模块的加载机制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-%E4%BC%98%E5%85%88%E4%BB%8E%E7%BC%93%E5%AD%98%E4%B8%AD%E5%8A%A0%E8%BD%BD"><span class="nav-text">4.1 优先从缓存中加载</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-%E5%86%85%E7%BD%AE%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6"><span class="nav-text">4.2 内置模块加载机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A8%A1%E5%9D%97%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6"><span class="nav-text">4.3 自定义模块的加载机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-4-%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A8%A1%E5%9D%97%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6"><span class="nav-text">4.4 第三方模块的加载机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-5-%E7%9B%AE%E5%BD%95%E4%BD%9C%E4%B8%BA%E6%A8%A1%E5%9D%97"><span class="nav-text">4.5 目录作为模块</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#03%E3%80%81Express"><span class="nav-text">03、Express</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%88%9D%E5%A7%8BExpress"><span class="nav-text">1 初始Express</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="nav-text">1.1 基本使用</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-1-1-%E5%88%9B%E5%BB%BA%E5%9F%BA%E6%9C%AC%E7%9A%84web%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="nav-text">1.1.1 创建基本的web服务器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-1-2-%E7%9B%91%E5%90%ACGET%E8%AF%B7%E6%B1%82"><span class="nav-text">1.1.2 监听GET请求</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-1-3-%E7%9B%91%E5%90%ACPOST%E8%AF%B7%E6%B1%82"><span class="nav-text">1.1.3 监听POST请求</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-1-4-%E6%8A%8A%E5%86%85%E5%AE%B9%E5%93%8D%E5%BA%94%E7%BB%99%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="nav-text">1.1.4 把内容响应给客户端</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-1-5-%E8%8E%B7%E5%8F%96URL%E4%B8%AD%E6%90%BA%E5%B8%A6%E7%9A%84%E6%9F%A5%E8%AF%A2%E5%8F%82%E6%95%B0"><span class="nav-text">1.1.5 获取URL中携带的查询参数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-1-6-%E8%8E%B7%E5%8F%96URL%E4%B8%AD%E7%9A%84%E5%8A%A8%E6%80%81%E5%8F%82%E6%95%B0"><span class="nav-text">1.1.6 获取URL中的动态参数</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-%E6%89%98%E7%AE%A1%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90"><span class="nav-text">1.2 托管静态资源</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-2-1-express-static"><span class="nav-text">1.2.1 express.static()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-2-2-%E6%89%98%E7%AE%A1%E5%A4%9A%E4%B8%AA%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E7%9B%AE%E5%BD%95"><span class="nav-text">1.2.2 托管多个静态资源目录</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-2-3-%E6%8C%82%E5%9C%A8%E8%B7%AF%E5%BE%84%E5%89%8D%E7%BC%80"><span class="nav-text">1.2.3 挂在路径前缀</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-nodemon"><span class="nav-text">1.3 nodemon</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-Express%E8%B7%AF%E7%94%B1"><span class="nav-text">2 Express路由</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-%E6%A6%82%E5%BF%B5"><span class="nav-text">2.1 概念</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#2-1-1-%E5%8C%B9%E9%85%8D%E8%BF%87%E7%A8%8B"><span class="nav-text">2.1.1 匹配过程</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-%E4%BD%BF%E7%94%A8"><span class="nav-text">2.2 使用</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#2-2-1-%E6%A8%A1%E5%9D%97%E5%8C%96%E8%B7%AF%E7%94%B1"><span class="nav-text">2.2.1 模块化路由</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-2-2-%E6%B3%A8%E5%86%8C%E8%B7%AF%E7%94%B1%E6%A8%A1%E5%9D%97"><span class="nav-text">2.2.2 注册路由模块</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-2-3-%E4%B8%BA%E8%B7%AF%E7%94%B1%E6%A8%A1%E5%9D%97%E6%B7%BB%E5%8A%A0%E5%89%8D%E7%BC%80"><span class="nav-text">2.2.3 为路由模块添加前缀</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-Express%E4%B8%AD%E9%97%B4%E4%BB%B6"><span class="nav-text">3 Express中间件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-%E6%A6%82%E5%BF%B5"><span class="nav-text">3.1 概念</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#3-1-1-%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%A0%BC%E5%BC%8F"><span class="nav-text">3.1.1 中间件格式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-1-2-next%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-text">3.1.2 next函数的作用</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-%E5%88%9D%E4%BD%93%E9%AA%8C"><span class="nav-text">3.2 初体验</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#3-2-1-%E5%AE%9A%E4%B9%89%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%87%BD%E6%95%B0"><span class="nav-text">3.2.1 定义中间件函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-2-2-%E5%85%A8%E5%B1%80%E7%94%9F%E6%95%88%E7%9A%84%E4%B8%AD%E9%97%B4%E4%BB%B6"><span class="nav-text">3.2.2 全局生效的中间件</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-2-3-%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-text">3.2.3 中间件的作用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-2-4-%E5%AE%9A%E4%B9%89%E5%A4%9A%E4%B8%AA%E5%85%A8%E5%B1%80%E4%B8%AD%E9%97%B4%E4%BB%B6"><span class="nav-text">3.2.4 定义多个全局中间件</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-2-5-%E5%B1%80%E9%83%A8%E7%94%9F%E6%95%88%E7%9A%84%E4%B8%AD%E9%97%B4%E4%BB%B6"><span class="nav-text">3.2.5 局部生效的中间件</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-2-6-%E5%AE%9A%E4%B9%89%E5%A4%9A%E4%B8%AA%E5%B1%80%E9%83%A8%E8%B7%AF%E7%94%B1"><span class="nav-text">3.2.6 定义多个局部路由</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-2-7-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-text">3.2.7 注意事项</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%9A%84%E5%88%86%E7%B1%BB"><span class="nav-text">3.3 中间件的分类</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#3-3-1-%E5%BA%94%E7%94%A8%E7%BA%A7%E5%88%AB%E7%9A%84%E4%B8%AD%E9%97%B4%E4%BB%B6"><span class="nav-text">3.3.1 应用级别的中间件</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-3-2-%E8%B7%AF%E7%94%B1%E7%BA%A7%E5%88%AB%E7%9A%84%E4%B8%AD%E9%97%B4%E4%BB%B6"><span class="nav-text">3.3.2 路由级别的中间件</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-3-3-%E9%94%99%E8%AF%AF%E7%BA%A7%E5%88%AB%E7%9A%84%E4%B8%AD%E9%97%B4%E4%BB%B6"><span class="nav-text">3.3.3 错误级别的中间件</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-3-4-Express%E5%86%85%E7%BD%AE%E7%9A%84%E4%B8%AD%E9%97%B4%E4%BB%B6"><span class="nav-text">3.3.4 Express内置的中间件</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-3-5-%E7%AC%AC%E4%B8%89%E6%96%B9%E7%9A%84%E4%B8%AD%E9%97%B4%E4%BB%B6"><span class="nav-text">3.3.5 第三方的中间件</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%AD%E9%97%B4%E4%BB%B6"><span class="nav-text">3.4 自定义中间件</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E4%BD%BF%E7%94%A8Express%E5%86%99%E6%8E%A5%E5%8F%A3"><span class="nav-text">4 使用Express写接口</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-%E5%88%9B%E5%BB%BA%E5%9F%BA%E6%9C%AC%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="nav-text">4.1 创建基本服务器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-%E5%88%9B%E5%BB%BAAPI%E8%B7%AF%E7%94%B1%E6%A8%A1%E5%9D%97"><span class="nav-text">4.2 创建API路由模块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-%E7%BC%96%E5%86%99GET%E6%8E%A5%E5%8F%A3"><span class="nav-text">4.3 编写GET接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-4-%E7%BC%96%E5%86%99POST%E6%8E%A5%E5%8F%A3"><span class="nav-text">4.4 编写POST接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-5-CORS%E8%B7%A8%E5%9F%9F%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%AB"><span class="nav-text">4.5 CORS跨域资源共享</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#4-5-1-%E6%8E%A5%E5%8F%A3%E7%9A%84%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98"><span class="nav-text">4.5.1 接口的跨域问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-5-2-%E4%BD%BF%E7%94%A8cors%E4%B8%AD%E9%97%B4%E4%BB%B6%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98"><span class="nav-text">4.5.2 使用cors中间件解决跨域问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-5-3-%E4%BB%80%E4%B9%88%E6%98%AFCORS"><span class="nav-text">4.5.3 什么是CORS</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-5-4-CORS%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-text">4.5.4 CORS注意事项</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-5-5-Access-Control-Allow-Origin"><span class="nav-text">4.5.5 Access-Control-Allow-Origin</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-5-6-Access-Control-Allow-Headers"><span class="nav-text">4.5.6 Access-Control-Allow-Headers</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-5-7-Access-Control-Allow-Methods"><span class="nav-text">4.5.7 Access-Control-Allow-Methods</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-5-8-CORS%E8%AF%B7%E6%B1%82%E7%9A%84%E5%88%86%E7%B1%BB"><span class="nav-text">4.5.8 CORS请求的分类</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-6-JSONP%E6%8E%A5%E5%8F%A3"><span class="nav-text">4.6 JSONP接口</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#4-6-1-%E5%88%9B%E5%BB%BAJSONP%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-text">4.6.1 创建JSONP接口的注意事项</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-6-2-%E5%AE%9E%E7%8E%B0JSONP%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%AD%A5%E9%AA%A4"><span class="nav-text">4.6.2 实现JSONP接口的步骤</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-6-3-%E4%BD%BF%E7%94%A8jQuery%E5%8F%91%E8%B5%B7jsonp%E8%AF%B7%E6%B1%82"><span class="nav-text">4.6.3 使用jQuery发起jsonp请求</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#04%E3%80%81Mysql%E6%A8%A1%E5%9D%97"><span class="nav-text">04、Mysql模块</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE"><span class="nav-text">5.1 安装与配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-%E6%93%8D%E4%BD%9CMysql"><span class="nav-text">5.2 操作Mysql</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-1-%E6%9F%A5%E8%AF%A2%E6%95%B0%E6%8D%AE"><span class="nav-text">5.2.1 查询数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-2-%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE"><span class="nav-text">5.2.2 插入数据</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#05%E3%80%81%E5%89%8D%E5%90%8E%E7%AB%AF%E7%9A%84%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81"><span class="nav-text">05、前后端的身份认证</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-web%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F"><span class="nav-text">1 web开发模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93Web%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F"><span class="nav-text">1.1 服务端渲染Web开发模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E7%9A%84%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F"><span class="nav-text">1.2 前后端分离的开发模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9web%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F"><span class="nav-text">1.3 如何选择web开发模式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81"><span class="nav-text">2 身份认证</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-session%E8%AE%A4%E8%AF%81%E6%9C%BA%E5%88%B6"><span class="nav-text">2.1 session认证机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-JWT%E8%AE%A4%E8%AF%81%E6%9C%BA%E5%88%B6"><span class="nav-text">2.2 JWT认证机制</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <a href="/"><img class="site-author-image" itemprop="image" alt="Mr.wj" src="/uploads/logo.jpg"></a>
  <p class="site-author-name" itemprop="name">Mr.wj</p>
  <div class="site-description" itemprop="description">欢迎来到栖息阁晓生博客</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">55</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">38</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/gadekuoen/wjqixige" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;gadekuoen&#x2F;wjqixige" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/wujiang569@126.com" title="E-Mail → wujiang569@126.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://me.csdn.net/weixin_39455881" title="CSDN → https:&#x2F;&#x2F;me.csdn.net&#x2F;weixin_39455881" rel="noopener" target="_blank"><i class="crosshairs fa-fw"></i>CSDN</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/2983932047/profile?rightmod=1&wvr=6&mod=personinfo&is_all=1" title="微博 → https:&#x2F;&#x2F;weibo.com&#x2F;2983932047&#x2F;profile?rightmod&#x3D;1&amp;wvr&#x3D;6&amp;mod&#x3D;personinfo&amp;is_all&#x3D;1" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>微博</a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.wjqixige.cn/2021/05/06/Node%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/logo.jpg">
      <meta itemprop="name" content="Mr.wj">
      <meta itemprop="description" content="欢迎来到栖息阁晓生博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="栖溪阁晓生">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Node学习笔记
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-05-06 11:16:50" itemprop="dateCreated datePublished" datetime="2021-05-06T11:16:50+08:00">2021-05-06</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-05-14 22:49:53" itemprop="dateModified" datetime="2021-05-14T22:49:53+08:00">2021-05-14</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Node/" itemprop="url" rel="index"><span itemprop="name">Node</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。Node.js 的官网地址: <a target="_blank" rel="noopener" href="https://nodejs.org/zh-cn/">https://nodejs.org/zh-cn/</a></p>
<img src="/2021/05/06/Node%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/node001.png" class="">

<span id="more"></span>

<p>Node.js 作为一个 JavaScript 的运行环境，仅仅提供了基础的功能和 API。然而，基于 Node.js 提供的这些基础功能，有很多强大的工具和框架：</p>
<ol>
<li>基于 Express 框架(<a target="_blank" rel="noopener" href="http://www.expressjs.com.cn/)%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%BF%AB%E9%80%9F%E6%9E%84%E5%BB%BA">http://www.expressjs.com.cn/)，可以快速构建</a> Web 应用；</li>
<li>基于 Electron 框架(<a target="_blank" rel="noopener" href="https://electronjs.org/)%EF%BC%8C%E5%8F%AF%E4%BB%A5%E6%9E%84%E5%BB%BA%E8%B7%A8%E5%B9%B3%E5%8F%B0%E7%9A%84%E6%A1%8C%E9%9D%A2%E5%BA%94%E7%94%A8%EF%BC%9B">https://electronjs.org/)，可以构建跨平台的桌面应用；</a></li>
<li>基于 restify 框架(<a target="_blank" rel="noopener" href="http://restify.com/)%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%BF%AB%E9%80%9F%E6%9E%84%E5%BB%BA">http://restify.com/)，可以快速构建</a> API 接口项目；</li>
<li>读写和操作数据库、创建实用的命令行工具辅助前端开发、etc…</li>
</ol>
<p><strong>环境安装</strong></p>
<p>通过 Node.js 来运行 Javascript 代码，则必须在计算机上安装 Node.js 环境才行。安装包可以从 Node.js 的官网首页直接下载，进入到 Node.js 的官网首页(<a target="_blank" rel="noopener" href="https://nodejs.org/en/)%EF%BC%8C%E7%82%B9%E5%87%BB">https://nodejs.org/en/)，点击</a> 绿色的按钮，下载所需的版本后，双击直接安装即可。</p>
<img src="/2021/05/06/Node%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/node002.png" class="">

<p><strong>区分 LTS 版本和 Current 版本的不同</strong></p>
<ol>
<li>LTS 为长期稳定版，对于追求稳定性的企业级项目来说，推荐安装 LTS 版本的 Node.js；</li>
<li>Current 为新特性尝鲜版，对热衷于尝试新特性的用户来说，推荐安装 Current 版本的 Node.js。但是，Current 版本中可能存在隐藏的Bug或安全性漏洞，因此不推荐在企业级项目中使用 Current 版本的 Node.js；</li>
</ol>
<p><strong>查看已安装的 Node.js 的版本号</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br></pre></td></tr></table></figure>

<p><strong>如何在node环境中执行js代码</strong></p>
<ol>
<li>打开终端；</li>
<li>输入 <code>node 要执行的js文件的路径</code></li>
</ol>
<h2 id="01、内置模块"><a href="#01、内置模块" class="headerlink" title="01、内置模块"></a>01、内置模块</h2><h3 id="1-fs文件系统模块"><a href="#1-fs文件系统模块" class="headerlink" title="1 fs文件系统模块"></a>1 fs文件系统模块</h3><p>fs 模块是 Node.js 官方提供的、用来操作文件的模块。它提供了一系列的方法和属性，用来满足用户对文件的操作需求。例如：</p>
<ul>
<li><code>fs.readFile()</code> 方法，用来读取指定文件中的内容</li>
<li><code>fs.writeFile()</code> 方法，用来向指定的文件中写入内容</li>
</ul>
<p>如果要在 JavaScript 代码中，使用 fs 模块来操作文件，则需要使用如下的方式先导入它：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="1-1-读取文件内容"><a href="#1-1-读取文件内容" class="headerlink" title="1.1 读取文件内容"></a>1.1 读取文件内容</h4><p>使用 <code>fs.readFile()</code> 方法，可以读取指定文件中的内容，语法格式如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile(path[, options], callback)</span><br></pre></td></tr></table></figure>

<p>参数解读：</p>
<ul>
<li>参数1：必选参数，字符串，表示文件的路径。</li>
<li>参数2：可选参数，表示以什么编码格式来读取文件。</li>
<li>参数3：必选参数，文件读取完成后，通过回调函数拿到读取的结果。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 导入fs模块，操作文件</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"><span class="comment">//2. 调用fs.readFile()读取文件</span></span><br><span class="line">fs.readFile(<span class="string">&#x27;./file/1.txt&#x27;</span>, <span class="string">&#x27;utf8&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, dataStr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err) &#123; <span class="comment">// 成功：err为null，失败：err为错误对象</span></span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">&#x27;读取文件失败！&#x27;</span> + err.message)  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;文件读取成功，内容是：&#x27;</span> + dataStr)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="1-2-写入文件内容"><a href="#1-2-写入文件内容" class="headerlink" title="1.2 写入文件内容"></a>1.2 写入文件内容</h4><p>使用 fs.writeFile() 方法，可以向指定的文件中写入内容，语法格式如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fs.writeFile(file, data[, options], callback)</span><br></pre></td></tr></table></figure>

<p>参数解读：</p>
<ul>
<li>参数1：必选参数，需要指定一个文件路径的字符串，表示文件的存放路径。</li>
<li>参数2：必选参数，表示要写入的内容。</li>
<li>参数3：可选参数，表示以什么格式写入文件内容，默认值是 utf8。</li>
<li>参数4：必选参数，文件写入完成后的回调函数。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line">fs.writeFile(<span class="string">&#x27;./file/2.txt&#x27;</span>, <span class="string">&#x27;abcd&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;文件写入失败！&#x27;</span> + err.message)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;文件写入成功！&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="1-3-路径动态拼接问题"><a href="#1-3-路径动态拼接问题" class="headerlink" title="1.3 路径动态拼接问题"></a>1.3 路径动态拼接问题</h4><p>在使用 fs 模块操作文件时，如果提供的操作路径是以 ./ 或 ../ 开头的相对路径时，很容易出现路径动态拼接错误的问题。</p>
<p><strong>原因：</strong>代码在运行的时候，会以执行 node 命令时所处的目录，动态拼接出被操作文件的完整路径。</p>
<p><strong>解决方案：</strong>在使用 fs 模块操作文件时，直接提供完整的路径，不要提供 ./ 或 ../ 开头的相对路径，从而防止路径动态拼接的问题。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不要使用 ./和../ 这样的相对路径</span></span><br><span class="line">fs.readFile(<span class="string">&#x27;./1.txt&#x27;</span>,<span class="string">&#x27;utf8&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err, dataStr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">&#x27;读取文件失败！&#x27;</span> + err.message)  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;文件读取成功，内容是：&#x27;</span> + dataStr)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// __dirname表示当前文件所处目录</span></span><br><span class="line">fs.readFile(__dirname + <span class="string">&#x27;./1.txt&#x27;</span>,<span class="string">&#x27;utf8&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err, dataStr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">&#x27;读取文件失败！&#x27;</span> + err.message)  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;文件读取成功，内容是：&#x27;</span> + dataStr)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="2-path路径模块"><a href="#2-path路径模块" class="headerlink" title="2 path路径模块"></a>2 path路径模块</h3><p>path 模块是 Node.js 官方提供的、用来处理路径的模块。它提供了一系列的方法和属性，用来满足用户对路径的处理需求。例如：</p>
<ul>
<li><code>path.join()</code>方法，用来将多个路径片段拼接成一个完整的路径字符串</li>
<li><code>path.basename()</code>方法，用来从路径字符串中，将文件名解析出来</li>
</ul>
<p>如果要在 JavaScript 代码中，使用 path 模块来处理路径，则需要使用如下的方式先导入它：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="2-1-路径拼接"><a href="#2-1-路径拼接" class="headerlink" title="2.1 路径拼接"></a>2.1 路径拼接</h4><p>使用 <code>path.join()</code> 方法，可以把多个路径片段拼接为完整的路径字符串，语法格式如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">path.join([...paths])</span><br></pre></td></tr></table></figure>

<p>参数解读：</p>
<ul>
<li><code>...paths &lt;string&gt;</code> 路径片段的序列</li>
<li>返回值: <code>&lt;string&gt;</code></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> pathStr = path.join(<span class="string">&#x27;/a&#x27;</span>,<span class="string">&#x27;/b/c&#x27;</span>, <span class="string">&#x27;../../&#x27;</span>, <span class="string">&#x27;/d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(pathStr)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> pathStr2 = path.join(__dirname, <span class="string">&#x27;/1.txt&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(pathStr2)</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>今后凡是涉及到路径拼接的操作，都要使用 path.join() 方法进行处理。不要直接使用 + 进行字符串的拼接。</p>
<h4 id="2-2-获取路径中的文件名"><a href="#2-2-获取路径中的文件名" class="headerlink" title="2.2 获取路径中的文件名"></a>2.2 获取路径中的文件名</h4><p>使用 <code>path.basename()</code> 方法，可以获取路径中的最后一部分，经常通过这个方法获取路径中的文件名，语法格式如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">path.basename(path[, ext])</span><br></pre></td></tr></table></figure>

<p>参数解读：</p>
<ul>
<li><code>path &lt;string&gt;</code> 必选参数，表示一个路径的字符串</li>
<li><code>ext &lt;string&gt; </code>可选参数，表示文件扩展名</li>
<li>返回: <code>&lt;string&gt;</code> 表示路径中的最后一部分</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fpath = <span class="string">&#x27;/a/b/c/index.html&#x27;</span></span><br><span class="line"><span class="keyword">const</span> fullName = path.basename(fpath)</span><br><span class="line"><span class="built_in">console</span>.log(fullName)</span><br><span class="line"><span class="keyword">const</span> fullName = path.basename(fpath,<span class="string">&#x27;.html&#x27;</span>) <span class="comment">//移除扩展名</span></span><br><span class="line"><span class="built_in">console</span>.log(fullName)</span><br></pre></td></tr></table></figure>

<h4 id="2-3-获取路径中的文件扩展名"><a href="#2-3-获取路径中的文件扩展名" class="headerlink" title="2.3 获取路径中的文件扩展名"></a>2.3 获取路径中的文件扩展名</h4><p>使用 path.extname() 方法，可以获取路径中的扩展名部分，语法格式如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">path.extname(path)</span><br></pre></td></tr></table></figure>

<p>参数解读：</p>
<ul>
<li><code>path &lt;string&gt;</code>必选参数，表示一个路径的字符串</li>
<li>返回: <code>&lt;string&gt;</code> 返回得到的扩展名字符串</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fpath = <span class="string">&#x27;/a/b/c/index.html&#x27;</span></span><br><span class="line"><span class="keyword">const</span> fext = path.extname(fpath)</span><br><span class="line"><span class="built_in">console</span>.log(fext) <span class="comment">//输出 .html</span></span><br></pre></td></tr></table></figure>

<h3 id="3-http模块"><a href="#3-http模块" class="headerlink" title="3 http模块"></a>3 http模块</h3><p>在网络节点中，负责消费资源的电脑，叫做客户端；负责对外提供网络资源的电脑，叫做服务器。</p>
<p>http 模块是 Node.js 官方提供的、用来创建 web 服务器的模块。通过 http 模块提供的 <code>http.createServer()</code> 方法，就能方便的把一台普通的电脑，变成一台 Web 服务器，从而对外提供 Web 资源服务。</p>
<p>如果要希望使用 http 模块创建 Web 服务器，则需要先导入它：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="3-1-http模块作用"><a href="#3-1-http模块作用" class="headerlink" title="3.1 http模块作用"></a>3.1 http模块作用</h4><p>服务器和普通电脑的<strong>区别</strong>在于，服务器上安装了 web 服务器软件，例如：IIS、Apache 等。通过安装这些服务器软件，就能把一台普通的电脑变成一台 web 服务器。</p>
<p>在 Node.js 中，我们不需要使用 IIS、Apache 等这些第三方 web 服务器软件。因为我们可以基于 Node.js 提供的 http 模块，<strong>通过几行简单的代码，就能轻松的手写一个服务器软件</strong>，从而对外提供 web 服务。</p>
<h4 id="3-2-服务器相关概念"><a href="#3-2-服务器相关概念" class="headerlink" title="3.2 服务器相关概念"></a>3.2 服务器相关概念</h4><h5 id="3-2-1-IP地址"><a href="#3-2-1-IP地址" class="headerlink" title="3.2.1 IP地址"></a>3.2.1 IP地址</h5><p><strong>IP</strong> <strong>地址</strong>就是互联网上每台计算机的唯一地址，因此 IP 地址具有唯一性。如果把“个人电脑”比作“一台电话”，那么“IP地址”就相当于“电话号码”，只有在知道对方 IP 地址的前提下，才能与对应的电脑之间进行数据通信。</p>
<p>IP 地址的格式：通常用“点分十进制”表示成（a.b.c.d）的形式，其中，a,b,c,d 都是 0~255 之间的十进制整数。例如：用点分十进表示的 IP地址（192.168.1.1）</p>
<p>注意：</p>
<ol>
<li><p><strong>互联网中每台</strong> <strong>Web</strong> <strong>服务器，都有自己的</strong> <strong>IP</strong> <strong>地址</strong>，例如：大家可以在 Windows 的终端中运行 ping <a target="_blank" rel="noopener" href="http://www.baidu.com/">www.baidu.com</a> 命令，即可查看到百度服务器的 IP 地址。</p>
</li>
<li><p>在开发期间，自己的电脑既是一台服务器，也是一个客户端，为了方便测试，可以在自己的浏览器中输入 127.0.0.1 这个 IP 地址，就能把自己的电脑当做一台服务器进行访问了。</p>
</li>
</ol>
<h5 id="3-2-2-域名和域名服务器"><a href="#3-2-2-域名和域名服务器" class="headerlink" title="3.2.2 域名和域名服务器"></a>3.2.2 域名和域名服务器</h5><p>尽管 IP 地址能够唯一地标记网络上的计算机，但IP地址是一长串数字，不直观，而且不便于记忆，于是人们又发明了另一套字符型的地址方案，即所谓的<strong>域名（Domain Name）地址</strong>。</p>
<p>IP地址和域名是一一对应的关系，这份对应关系存放在一种叫做<strong>域名服务器</strong>(DNS，Domain name server)的电脑中。使用者只需通过好记的域名访问对应的服务器即可，对应的转换工作由域名服务器实现。因此，<strong>域名服务器就是提供</strong> <strong>IP</strong> <strong>地址和域名之间的转换服务的服务器</strong>。</p>
<p>注意：</p>
<ol>
<li><p>单纯使用 IP 地址，互联网中的电脑也能够正常工作。但是有了域名的加持，能让互联网的世界变得更加方便。</p>
</li>
<li><p>在开发测试期间， 127.0.0.1 对应的域名是 localhost，它们都代表我们自己的这台电脑，在使用效果上没有任何区别。</p>
</li>
</ol>
<h5 id="3-2-3-端口号"><a href="#3-2-3-端口号" class="headerlink" title="3.2.3 端口号"></a>3.2.3 端口号</h5><p>计算机中的端口号，就好像是现实生活中的门牌号一样。通过门牌号，外卖小哥可以在整栋大楼众多的房间中，准确把外卖送到你的手中。同样的道理，在一台电脑中，可以运行成百上千个 web 服务。每个 web 服务都对应一个唯一的端口号。客户端发送过来的网络请求，通过端口号，可以被准确地交给对应的 web 服务进行处理。</p>
<img src="/2021/05/06/Node%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/node003.png" class="">

<p>注意：</p>
<ol>
<li><p>每个端口号不能同时被多个 web 服务占用。</p>
</li>
<li><p>在实际应用中，URL 中的 80 端口可以被省略</p>
</li>
</ol>
<h4 id="3-3-创建基本web服务器"><a href="#3-3-创建基本web服务器" class="headerlink" title="3.3 创建基本web服务器"></a>3.3 创建基本web服务器</h4><h5 id="3-3-1-创建步骤"><a href="#3-3-1-创建步骤" class="headerlink" title="3.3.1 创建步骤"></a>3.3.1 创建步骤</h5><ol>
<li><p>导入 http 模块；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
<li><p>创建 web 服务器实例；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> server = http.createServer()</span><br></pre></td></tr></table></figure></li>
<li><p>为服务器实例绑定 <strong>request</strong> 事件，监听客户端的请求</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用服务器实例 .on() 方法，为服务器绑定一个 request 时间</span></span><br><span class="line">server.on(<span class="string">&#x27;request&#x27;</span>, <span class="function">(<span class="params">req,res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 只要客户端请求服务器，就会出发request事件，从而调用这个事件处理函数</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Someone visit our web server.&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>启动服务器</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用 server.listen(端口号，cd回调)方法，即可启动web服务器</span></span><br><span class="line">server.listen(<span class="number">80</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;http server running at http://127.0.0.1&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ol>
<h5 id="3-3-2-req请求对象"><a href="#3-3-2-req请求对象" class="headerlink" title="3.3.2 req请求对象"></a>3.3.2 req请求对象</h5><p>只要服务器接收到了客户端的请求，就会调用通过 server.on() 为服务器绑定的 request 事件处理函数。</p>
<p>如果想在事件处理函数中，访问与客户端相关的<strong>数据</strong>或<strong>属性</strong>，可以使用如下的方式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">server.on(<span class="string">&#x27;request&#x27;</span>, <span class="function">(<span class="params">req</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> url = req.url</span><br><span class="line">    <span class="keyword">const</span> method = req.method</span><br><span class="line">    <span class="keyword">const</span> str = <span class="string">&#x27;your request url is &#x27;</span>+ url +<span class="string">&#x27;, and request method is &#x27;</span> + method</span><br><span class="line">    <span class="built_in">console</span>.log(str)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h5 id="3-3-3-res响应对象"><a href="#3-3-3-res响应对象" class="headerlink" title="3.3.3 res响应对象"></a>3.3.3 res响应对象</h5><p>在服务器的 request 事件处理函数中，如果想访问与服务器相关的<strong>数据</strong>或<strong>属性</strong>，可以使用如下的方式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">server.on(<span class="string">&#x27;request&#x27;</span>, <span class="function">(<span class="params">req,res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> url = req.url</span><br><span class="line">    <span class="keyword">const</span> method = req.method</span><br><span class="line">    <span class="keyword">const</span> str = <span class="string">&#x27;your request url is &#x27;</span>+ url +<span class="string">&#x27;, and request method is &#x27;</span> + method</span><br><span class="line">    </span><br><span class="line">    res.end(str)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h5 id="3-3-4-解决中文乱码问题"><a href="#3-3-4-解决中文乱码问题" class="headerlink" title="3.3.4 解决中文乱码问题"></a>3.3.4 解决中文乱码问题</h5><p>当调用 res.end() 方法，向客户端发送中文内容的时候，会出现乱码问题，此时，需要手动设置内容的编码格式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">server.on(<span class="string">&#x27;request&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> str = <span class="string">`您请求的url地址是<span class="subst">$&#123;req.url&#125;</span>, 请求的method类型是<span class="subst">$&#123;req.method&#125;</span>`</span></span><br><span class="line">    </span><br><span class="line">    res.setHeader(<span class="string">&#x27;Content-type&#x27;</span>, <span class="string">&#x27;text/html; charset=utf-8&#x27;</span>)</span><br><span class="line">    res.end(str)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="3-4-根据不同url响应不同html内容"><a href="#3-4-根据不同url响应不同html内容" class="headerlink" title="3.4 根据不同url响应不同html内容"></a>3.4 根据不同url响应不同html内容</h4><p><strong>实现步骤：</strong></p>
<ol>
<li>获取请求的 url 地址</li>
<li>设置默认的响应内容为 404 Not found</li>
<li>判断用户请求的是否为 / 或 /index.html 首页</li>
<li>判断用户请求的是否为 /about.html 关于页面</li>
<li>设置 Content-Type 响应头，防止中文乱码</li>
<li>使用 res.end() 把内容响应给客户端</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">server.on(<span class="string">&#x27;request&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> url = req.url</span><br><span class="line">    <span class="keyword">let</span> content = <span class="string">&#x27;&lt;h1&gt;404 NOT FOUND!&lt;/h1&gt;&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (url === <span class="string">&#x27;/&#x27;</span> || url === <span class="string">&#x27;/index.html&#x27;</span>) &#123;</span><br><span class="line">        content = <span class="string">&#x27;&lt;h1&gt;首页&lt;/h1&gt;&#x27;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (url === <span class="string">&#x27;/about.html&#x27;</span>) &#123;</span><br><span class="line">        content = <span class="string">&#x27;&lt;h1&gt;关于页面&lt;/h1&gt;&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    res.setHeader(<span class="string">&#x27;Content-Type&#x27;</span>, <span class="string">&#x27;text/html; charset=utf-8&#x27;</span>)</span><br><span class="line">    res.end(content)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="02、模块化"><a href="#02、模块化" class="headerlink" title="02、模块化"></a>02、模块化</h2><h3 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1 基本概念"></a>1 基本概念</h3><p><strong>模块化</strong>是指解决一个复杂问题时，自顶向下逐层把系统划分成若干模块的过程。对于整个系统来说，模块是可组合、分解和更换的单元。</p>
<p>编程领域中的模块化，就是<strong>遵守固定的规则</strong>，把一个大文件拆成独立并互相依赖的多个小模块。把代码进行模块化拆分的好处：</p>
<ol>
<li><p>提高了代码的<strong>复用性</strong></p>
</li>
<li><p>提高了代码的<strong>可维护性</strong></p>
</li>
<li><p>可以实现<strong>按需加载</strong></p>
</li>
</ol>
<h4 id="1-1-模块化规范"><a href="#1-1-模块化规范" class="headerlink" title="1.1 模块化规范"></a>1.1 模块化规范</h4><p><strong>模块化规范</strong>就是对代码进行模块化的拆分与组合时，需要遵守的那些规则。例如：</p>
<ul>
<li><p>使用什么样的语法格式来<strong>引用模块</strong></p>
</li>
<li><p>在模块中使用什么样的语法格式<strong>向外暴露成员</strong></p>
</li>
</ul>
<p><strong>模块化规范的好处</strong>：大家都遵守同样的模块化规范写代码，降低了沟通的成本，极大方便了各个模块之间的相互调用，利人利己。</p>
<h3 id="2-node中的模块化"><a href="#2-node中的模块化" class="headerlink" title="2 node中的模块化"></a>2 node中的模块化</h3><h4 id="2-1-模块的分类"><a href="#2-1-模块的分类" class="headerlink" title="2.1 模块的分类"></a>2.1 模块的分类</h4><p>Node.js 中根据模块来源的不同，将模块分为了 3 大类，分别是：</p>
<ul>
<li><strong>内置模块</strong>（内置模块是由 Node.js 官方提供的，例如 fs、path、http 等）</li>
<li><strong>自定义模块</strong>（用户创建的每个 .js 文件，都是自定义模块）</li>
<li><strong>第三方模块</strong>（由第三方开发出来的模块，并非官方提供的内置模块，也不是用户创建的自定义模块，使用前需要先下载）</li>
</ul>
<h4 id="2-2-加载模快"><a href="#2-2-加载模快" class="headerlink" title="2.2 加载模快"></a>2.2 加载模快</h4><p>使用强大的 require() 方法，可以加载需要的内置模块、用户自定义模块、第三方模块进行使用。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加载内置模块</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"><span class="comment">// 加载自定义模块</span></span><br><span class="line"><span class="keyword">const</span> custom = <span class="built_in">require</span>(<span class="string">&#x27;./custom.js&#x27;</span>)</span><br><span class="line"><span class="comment">// 加载第三方模块</span></span><br><span class="line"><span class="keyword">const</span> moment = <span class="built_in">require</span>(<span class="string">&#x27;moment&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>注意：使用 require() 方法加载其它模块时，会执行被加载模块中的代码。</p>
<h4 id="2-3-模块作用域"><a href="#2-3-模块作用域" class="headerlink" title="2.3 模块作用域"></a>2.3 模块作用域</h4><p>和函数作用域类似，在自定义模块中定义的变量、方法等成员，只能在当前模块内被访问，这种模块级别的访问限制，叫做<strong>模块作用域</strong>。</p>
<p>好处：防止了全局变量污染的问题。</p>
<img src="/2021/05/06/Node%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/node004.png" class="">

<h4 id="2-4-向外共享模块作用域中的成员"><a href="#2-4-向外共享模块作用域中的成员" class="headerlink" title="2.4 向外共享模块作用域中的成员"></a>2.4 向外共享模块作用域中的成员</h4><h5 id="2-4-1-module对象"><a href="#2-4-1-module对象" class="headerlink" title="2.4.1 module对象"></a>2.4.1 module对象</h5><p>在每个 .js 自定义模块中都有一个 module 对象，它里面存储了和当前模块有关的信息，打印如下：</p>
<img src="/2021/05/06/Node%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/node005.png" class="">

<h5 id="2-4-2-module-exports对象"><a href="#2-4-2-module-exports对象" class="headerlink" title="2.4.2 module.exports对象"></a>2.4.2 module.exports对象</h5><p>在自定义模块中，可以使用 <code>module.exports</code> 对象，将模块内的成员共享出去，供外界使用。外界用 <code>require()</code> 方法导入自定义模块时，得到的就是 <code>module.exports</code> 所指向的对象。</p>
<h5 id="2-4-3-注意点"><a href="#2-4-3-注意点" class="headerlink" title="2.4.3 注意点"></a>2.4.3 注意点</h5><p>使用 require() 方法导入模块时，导入的结果，<strong>永远以</strong> <strong>module.exports</strong> <strong>指向的对象为准</strong>。</p>
<img src="/2021/05/06/Node%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/node006.png" class="">

<h5 id="2-4-4-exports对象"><a href="#2-4-4-exports对象" class="headerlink" title="2.4.4 exports对象"></a>2.4.4 exports对象</h5><p>由于 module.exports 单词写起来比较复杂，为了简化向外共享成员的代码，Node 提供了 exports 对象。默认情况下，exports 和 module.exports 指向同一个对象。<strong>最终共享的结果，还是以 module.exports 指向的对象为准</strong>。</p>
<img src="/2021/05/06/Node%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/node007.png" class="">

<p><strong>exports和 module.exports 的使用误区</strong></p>
<p>时刻谨记，require() 模块时，得到的永远是 module.exports 指向的对象：</p>
<p>![image-20210415214308387](F:/wujiang/笔记/01_前端开发系列/10_Node/imgs/node008.png %}</p>
<p><strong>注意：</strong>为了防止混乱，建议大家不要在同一个模块中同时使用 exports 和 module.exports</p>
<h5 id="2-4-5-Node-js-中的模块化规范"><a href="#2-4-5-Node-js-中的模块化规范" class="headerlink" title="2.4.5 Node.js 中的模块化规范"></a>2.4.5 Node.js 中的模块化规范</h5><p>Node.js 遵循了 CommonJS 模块化规范，CommonJS 规定了模块的特性和各模块之间如何相互依赖。</p>
<p>CommonJS 规定：</p>
<ol>
<li><p>每个模块内部，module 变量代表当前模块。</p>
</li>
<li><p>module 变量是一个对象，它的 exports 属性（即 module.exports）是对外的接口。</p>
</li>
<li><p>加载某个模块，其实是加载该模块的 module.exports 属性。require() 方法用于加载模块。</p>
</li>
</ol>
<h3 id="3-npm与包"><a href="#3-npm与包" class="headerlink" title="3 npm与包"></a>3 npm与包</h3><h4 id="3-1-包"><a href="#3-1-包" class="headerlink" title="3.1 包"></a>3.1 包</h4><p>Node.js 中的第三方模块又叫做包。就像电脑和计算机指的是相同的东西，第三方模块和包指的是同一个概念，只不过叫法不同。</p>
<h5 id="3-1-1-来源"><a href="#3-1-1-来源" class="headerlink" title="3.1.1 来源"></a>3.1.1 来源</h5><p>不同于 Node.js 中的内置模块与自定义模块，包是由第三方个人或团队开发出来的，免费供所有人使用。</p>
<p><strong>注意</strong>：Node.js 中的包都是免费且开源的，不需要付费即可免费下载使用。</p>
<h5 id="3-1-2-为什么需要包"><a href="#3-1-2-为什么需要包" class="headerlink" title="3.1.2 为什么需要包"></a>3.1.2 为什么需要包</h5><p>由于 Node.js 的内置模块仅提供了一些底层的 API，导致在基于内置模块进行项目开发的时，效率很低。包是基于内置模块封装出来的，提供了更高级、更方便的 API，极大的提高了开发效率。包和内置模块之间的关系，类似于 jQuery 和 浏览器内置 API 之间的关系。</p>
<h5 id="3-1-3-哪里下载包"><a href="#3-1-3-哪里下载包" class="headerlink" title="3.1.3 哪里下载包"></a>3.1.3 哪里下载包</h5><p>国外有一家 IT 公司，叫做 <strong>npm, Inc.</strong> 这家公司旗下有一个非常著名的网站： <a target="_blank" rel="noopener" href="https://www.npmjs.com/">https://www.npmjs.com/</a> ，它是<strong>全球最大的包共享平台</strong>，可以从这个网站上搜索到任何你需要的包，只要有足够的耐心！到目前位置，全球约 1100 多万的开发人员，通过这个包共享平台，开发并共享了超过 120 多万个包 供我们使用。<strong>npm, Inc.</strong> <strong>公司</strong>提供了一个地址为 <a target="_blank" rel="noopener" href="https://registry.npmjs.org/">https://registry.npmjs.org/</a> 的服务器，来对外共享所有的包，我们可以从这个服务器上下载自己所需要的包。</p>
<p><strong>注意：</strong></p>
<ul>
<li><p>从 <a target="_blank" rel="noopener" href="https://www.npmjs.com/">https://www.npmjs.com/</a> 网站上搜索自己所需要的包</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://registry.npmjs.org/">https://registry.npmjs.org/</a> 服务器上下载自己需要的包</p>
</li>
</ul>
<h5 id="3-1-4-如何下载"><a href="#3-1-4-如何下载" class="headerlink" title="3.1.4 如何下载"></a>3.1.4 如何下载</h5><p><strong>npm, Inc.</strong> <strong>公司</strong>提供了一个包管理工具，我们可以使用这个包管理工具，从 <a target="_blank" rel="noopener" href="https://registry.npmjs.org/">https://registry.npmjs.org/</a> 服务器把需要的包下载到本地使用。</p>
<p>这个包管理工具的名字叫做 Node Package Manager（简称 npm 包管理工具），这个包管理工具随着 Node.js 的安装包一起被安装到了用户的电脑上。</p>
<p>大家可以在终端中执行 <strong>npm -v</strong> 命令，来查看自己电脑上所安装的 npm 包管理工具的版本号。</p>
<h4 id="3-2-npm"><a href="#3-2-npm" class="headerlink" title="3.2 npm"></a>3.2 npm</h4><p>格式化时间传统方法：</p>
<img src="/2021/05/06/Node%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/node009.png" class="">

<p>格式化时间高级做法：</p>
<img src="/2021/05/06/Node%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/node010.png" class="">

<h5 id="3-2-1-下载包命令"><a href="#3-2-1-下载包命令" class="headerlink" title="3.2.1 下载包命令"></a>3.2.1 下载包命令</h5><p>如何想在项目中安装指定名称的包，需要运行如下的命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install 包的完整名称</span><br><span class="line">npm i 包的完整名称</span><br></pre></td></tr></table></figure>

<p><strong>下载指定版本的包：</strong></p>
<p>默认情况下，使用 <code>npm install</code> 命令安装包的时候，会自动安装最新版本的包。如果需要安装指定版本的包，可以在包名之后，通过 <code>@符号</code>指定具体的版本，例如：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install 包名称@version</span><br></pre></td></tr></table></figure>

<h5 id="3-2-2-初次装包后多了哪些文件"><a href="#3-2-2-初次装包后多了哪些文件" class="headerlink" title="3.2.2 初次装包后多了哪些文件"></a>3.2.2 初次装包后多了哪些文件</h5><p>初次装包完成后，在项目文件夹下多一个叫做 <code>node_modules</code> 的文件夹和 <code>package-lock.json</code> 的配置文件。其中：</p>
<ul>
<li><p><code>node_modules</code> 文件夹用来存放所有已安装到项目中的包。<code>require()</code> 导入第三方包时，就是从这个目录中查找并加载包；</p>
</li>
<li><p><code>package-lock.json</code> 配置文件用来记录 <code>node_modules</code> 目录下的每一个包的下载信息，例如包的名字、版本号、下载地址等。</p>
</li>
</ul>
<p><strong>注意：</strong>程序员不要手动修改 node_modules 或 package-lock.json 文件中的任何代码，npm 包管理工具会自动维护它们。</p>
<h5 id="3-2-3-包的语义化版本规范"><a href="#3-2-3-包的语义化版本规范" class="headerlink" title="3.2.3 包的语义化版本规范"></a>3.2.3 包的语义化版本规范</h5><p>包的版本号是以“点分十进制”形式进行定义的，总共有三位数字，例如 <strong>2.24.0</strong>。其中每一位数字所代表的的含义如下：</p>
<ul>
<li><p>第1位数字：大版本</p>
</li>
<li><p>第2位数字：功能版本</p>
</li>
<li><p>第3位数字：Bug修复版本</p>
</li>
</ul>
<p>版本号提升的规则：只要前面的版本号增长了，则后面的版本号归零。</p>
<h4 id="3-3-包管理配置文件"><a href="#3-3-包管理配置文件" class="headerlink" title="3.3 包管理配置文件"></a>3.3 包管理配置文件</h4><p>npm 规定，在项目根目录中，<strong>必须</strong>提供一个叫做 <code>package.json</code> 的包管理配置文件。用来记录与项目有关的一些配置信息。例如：</p>
<ul>
<li>项目的名称、版本号、描述等</li>
<li>项目中都用到了哪些包</li>
<li>哪些包只在开发期间会用到</li>
<li>那些包在开发和部署时都需要用到</li>
</ul>
<h5 id="3-3-1-多人协作的问题"><a href="#3-3-1-多人协作的问题" class="headerlink" title="3.3.1 多人协作的问题"></a>3.3.1 多人协作的问题</h5><img src="/2021/05/06/Node%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/node011.png" class="">

<p>图片中，整个项目的体积是 30.4M，第三方包的体积是 28.8M，项目源代码的体积 1.6M</p>
<p><strong>遇到的问题：</strong>第三方包的体积过大，不方便团队成员之间共享项目源代码。</p>
<p><strong>解决方案：</strong>共享时剔除node_modules</p>
<h5 id="3-3-2-如何记录项目中安装了哪些包"><a href="#3-3-2-如何记录项目中安装了哪些包" class="headerlink" title="3.3.2 如何记录项目中安装了哪些包"></a>3.3.2 如何记录项目中安装了哪些包</h5><p>在项目根目录中，创建一个叫做 <code>package.json</code> 的配置文件，即可用来记录项目中安装了哪些包。从而方便剔除 node_modules 目录之后，在团队成员之间共享项目的源代码。</p>
<p><strong>注意</strong>：今后在项目开发中，一定要把 node_modules 文件夹，添加到 <code>.gitignore</code> 忽略文件中。</p>
<h5 id="3-3-3-快速创建package-json"><a href="#3-3-3-快速创建package-json" class="headerlink" title="3.3.3 快速创建package.json"></a>3.3.3 快速创建package.json</h5><p>npm 包管理工具提供了一个快捷命令，可以在执行命令时所处的目录中，快速创建 package.json 这个包管理配置文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 作用：在执行命令所处的目录中，快速新建 package.json文件</span><br><span class="line">npm init -y</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ol>
<li><p>上述命令只能在英文的目录下成功运行！所以，项目文件夹的名称一定要使用英文命名，不要使用中文，不能出现空格。</p>
</li>
<li><p>运行 <code>npm install</code> 命令安装包的时候，npm 包管理工具会自动把包的名称和版本号，记录到 package.json 中。</p>
</li>
</ol>
<h5 id="3-3-4-dependencies节点"><a href="#3-3-4-dependencies节点" class="headerlink" title="3.3.4 dependencies节点"></a>3.3.4 dependencies节点</h5><p>package.json 文件中，有一个 dependencies 节点，专门用来记录您使用 npm install 命令安装了哪些包。</p>
<img src="/2021/05/06/Node%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/node012.png" class="">

<h5 id="3-3-5-一次性安装所有包"><a href="#3-3-5-一次性安装所有包" class="headerlink" title="3.3.5 一次性安装所有包"></a>3.3.5 一次性安装所有包</h5><p>当我们拿到一个剔除了 node_modules 的项目之后，需要先把所有的包下载到项目中，才能将项目运行起来。</p>
<p>否则会报类似于下面的错误：</p>
<img src="/2021/05/06/Node%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/node013.png" class="">

<p>可以运行 npm install 命令（或 npm i）一次性安装所有的依赖包：</p>
<img src="/2021/05/06/Node%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/node014.png" class="">

<h5 id="3-3-6-卸载包"><a href="#3-3-6-卸载包" class="headerlink" title="3.3.6 卸载包"></a>3.3.6 卸载包</h5><p>可以运行 npm uninstall 命令，来卸载指定的包：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall 包名</span><br></pre></td></tr></table></figure>

<p>注意：npm uninstall 命令执行成功后，会把卸载的包，自动从 package.json 的 dependencies 中移除掉。</p>
<h5 id="3-3-7-devDependencies节点"><a href="#3-3-7-devDependencies节点" class="headerlink" title="3.3.7 devDependencies节点"></a>3.3.7 devDependencies节点</h5><p>如果某些包<strong>只在项目开发阶段</strong>会用到，在<strong>项目上线之后不会用到</strong>，则建议把这些包记录到 <code>devDependencies</code> 节点中。与之对应的，如果某些包在开发和项目上线之后都需要用到，则建议把这些包记录到 <code>dependencies</code> 节点中。您可以使用如下的命令，将包记录到 devDependencies 节点中：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 安装指定的包，并记录到devDependencies节点中</span></span><br><span class="line">npm i 包名 -D</span><br><span class="line"><span class="comment">## 上述简写形式，等价于下面这种写法 </span></span><br><span class="line">npm install 包名 --save-dev</span><br></pre></td></tr></table></figure>

<h4 id="3-4-解决下包速度慢的问题"><a href="#3-4-解决下包速度慢的问题" class="headerlink" title="3.4 解决下包速度慢的问题"></a>3.4 解决下包速度慢的问题</h4><p>在使用 npm 下包的时候，默认从国外的 <a target="_blank" rel="noopener" href="https://registry.npmjs.org/">https://registry.npmjs.org/</a> 服务器进行下载，此时，网络数据的传输需要经过漫长的海底光缆，因此下包速度会很慢。</p>
<blockquote>
<p>扩展阅读 - 海底光缆：</p>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%B5%B7%E5%BA%95%E5%85%89%E7%BC%86/4107830">https://baike.baidu.com/item/%E6%B5%B7%E5%BA%95%E5%85%89%E7%BC%86/4107830</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E4%B8%AD%E7%BE%8E%E6%B5%B7%E5%BA%95%E5%85%89%E7%BC%86/10520363">https://baike.baidu.com/item/%E4%B8%AD%E7%BE%8E%E6%B5%B7%E5%BA%95%E5%85%89%E7%BC%86/10520363</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/APG/23647721?fr=aladdin">https://baike.baidu.com/item/APG/23647721?fr=aladdin</a></p>
</li>
</ul>
</blockquote>
<p><strong>淘宝NPM镜像服务器</strong></p>
<p>淘宝在国内搭建了一个服务器，专门把国外官方服务器上的包同步到国内的服务器，然后在国内提供下包的服务。从而极大的提高了下包的速度。</p>
<blockquote>
<p>扩展：<strong>镜像</strong>（Mirroring）是一种文件存储形式，一个磁盘上的数据在另一个磁盘上存在一个完全相同的副本即为镜像。</p>
</blockquote>
<img src="/2021/05/06/Node%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/node015.png" class="">

<img src="/2021/05/06/Node%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/node016.png" class="">

<h5 id="3-4-1-切换npm的下包镜像源"><a href="#3-4-1-切换npm的下包镜像源" class="headerlink" title="3.4.1 切换npm的下包镜像源"></a>3.4.1 切换npm的下包镜像源</h5><p>下包的镜像源，指的就是下包的服务器地址。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看当前的下包镜像源</span></span><br><span class="line">npm config get registry</span><br><span class="line"><span class="meta">#</span><span class="bash"> 将下包的镜像源切换为淘宝镜像源</span></span><br><span class="line">npm config set registry=https://registry.npm.taobao.org/</span><br><span class="line"><span class="meta">#</span><span class="bash"> 检查镜像源是否下载成功</span></span><br><span class="line">npm config get registry</span><br></pre></td></tr></table></figure>

<h5 id="3-4-2-nrm"><a href="#3-4-2-nrm" class="headerlink" title="3.4.2 nrm"></a>3.4.2 nrm</h5><p>为了更方便的切换下包的镜像源，我们可以安装 <strong>nrm</strong> 这个小工具，利用 nrm 提供的终端命令，可以快速查看和切换下包的镜像源。</p>
<img src="/2021/05/06/Node%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/node017.png" class="">

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 通过npm包管理器，将nrm安装为全局可用的工具</span></span><br><span class="line">npm i nrm -g</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看所有可用的镜像源</span></span><br><span class="line">nrm ls</span><br><span class="line"><span class="meta">#</span><span class="bash"> 将下包的镜像源切换为taobao镜像</span></span><br><span class="line">nrm use taobao</span><br></pre></td></tr></table></figure>

<h4 id="3-4-包的分类"><a href="#3-4-包的分类" class="headerlink" title="3.4 包的分类"></a>3.4 包的分类</h4><h5 id="3-4-1-项目包"><a href="#3-4-1-项目包" class="headerlink" title="3.4.1 项目包"></a>3.4.1 项目包</h5><p>那些被安装到项目的 node_modules 目录中的包，都是项目包。项目包又分为两类，分别是：</p>
<ul>
<li><p>开发依赖包（被记录到 devDependencies 节点中的包，只在开发期间会用到）</p>
</li>
<li><p>核心依赖包（被记录到 dependencies 节点中的包，在开发期间和项目上线之后都会用到）</p>
</li>
</ul>
<img src="/2021/05/06/Node%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/node018.png" class="">

<h5 id="3-4-2-全局包"><a href="#3-4-2-全局包" class="headerlink" title="3.4.2 全局包"></a>3.4.2 全局包</h5><p>在执行 npm install 命令时，如果提供了 -g 参数，则会把包安装为全局包。全局包会被安装到 <code>C:\Users\用户目录\AppData\Roaming\npm\node_modules</code> 目录下。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm i 包名 -g				# 全局安装指定的包</span><br><span class="line">npm uninstall 包名 -g		# 卸载全局安装的包</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ol>
<li><p>只有工具性质的包，才有全局安装的必要性。因为它们提供了好用的终端命令。</p>
</li>
<li><p>判断某个包是否需要全局安装后才能使用，可以参考官方提供的使用说明即可。</p>
</li>
</ol>
<h5 id="3-4-3-i5ting-toc"><a href="#3-4-3-i5ting-toc" class="headerlink" title="3.4.3 i5ting_toc"></a>3.4.3 i5ting_toc</h5><p>i5ting_toc 是一个可以把 md 文档转为 html 页面的小工具，使用步骤如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 将i5ting_toc 安装为全局包</span></span><br><span class="line">npm install -g i5ting_toc</span><br><span class="line"><span class="meta">#</span><span class="bash"> 调用 i5ting_toc,轻松实现md 转 html的功能</span></span><br><span class="line">i5ting_toc -f 要转换的md文件路径 -o</span><br></pre></td></tr></table></figure>

<h4 id="3-5-规范的包结构"><a href="#3-5-规范的包结构" class="headerlink" title="3.5 规范的包结构"></a>3.5 规范的包结构</h4><p>在清楚了包的概念、以及如何下载和使用包之后，接下来，我们深入了解一下包的内部结构。一个规范的包，它的组成结构，必须符合以下 3 点要求：</p>
<ol>
<li><p>包必须以单独的目录而存在</p>
</li>
<li><p>包的顶级目录下要必须包含 package.json 这个包管理配置文件</p>
</li>
<li><p>package.json 中必须包含 name，version，main 这三个属性，分别代表包的名字、版本号、包的入口。</p>
</li>
</ol>
<p><strong>注意：</strong>以上 3 点要求是一个规范的包结构必须遵守的格式，关于更多的约束，可以参考如下网址：</p>
<p><a target="_blank" rel="noopener" href="https://yarnpkg.com/zh-Hans/docs/package-json">https://yarnpkg.com/zh-Hans/docs/package-json</a></p>
<h4 id="3-6-自定义包"><a href="#3-6-自定义包" class="headerlink" title="3.6 自定义包"></a>3.6 自定义包</h4><p><strong>初始化包基本结构</strong></p>
<ol>
<li><p>新建 itheima-tools 文件夹，作为包的根目录</p>
</li>
<li><p>在 itheima-tools 文件夹中，新建如下三个文件：</p>
<ul>
<li>package.json （包管理配置文件）</li>
<li>index.js     （包的入口文件）</li>
<li>README.md （包的说明文档）</li>
</ul>
</li>
</ol>
<p><strong>初始化package.json</strong></p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;wjqixige-tools&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;1.0.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;main&quot;</span>: <span class="string">&quot;index.js&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;提供了格式化时间，HTMLEscape的功能&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;keywords&quot;</span>: [<span class="string">&quot;wjqixige&quot;</span>,<span class="string">&quot;dateFormat&quot;</span>,<span class="string">&quot;escape&quot;</span>],</span><br><span class="line">    <span class="attr">&quot;license&quot;</span>: <span class="string">&quot;ISC&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>关于更多 license 许可协议相关的内容，可参考 <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/86251523e898">https://www.jianshu.com/p/86251523e898</a></p>
</blockquote>
<p><strong>在index.js中定义格式化时间的方法</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dateFormat</span>(<span class="params">dateStr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> dt = <span class="keyword">new</span> <span class="built_in">Date</span>(dateStr)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> y = dt.getFullYear()</span><br><span class="line">    <span class="keyword">const</span> m = padZero(dt.getMonth() + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">const</span> d = padZero(dt.getDate())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> hh = padZero(dt.getHours())</span><br><span class="line">    <span class="keyword">const</span> mm = padZero(dt.getMinutes())</span><br><span class="line">    <span class="keyword">const</span> ss = padZero(dt.getSeconds())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;y&#125;</span>-<span class="subst">$&#123;m&#125;</span>-<span class="subst">$&#123;d&#125;</span> <span class="subst">$&#123;hh&#125;</span>:<span class="subst">$&#123;mm&#125;</span>:<span class="subst">$&#123;ss&#125;</span>`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">padZero</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n &gt; <span class="number">9</span> ? n : <span class="string">&#x27;0&#x27;</span> + n</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    dateFormat</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>在index.js中定义转义HTML的方法</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">htmlEscape</span>(<span class="params">htmlStr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> htmlStr.replace(<span class="regexp">/&lt;|&gt;|&quot;|&amp;/g</span>, <span class="function">(<span class="params">match</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">switch</span>(match)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;&lt;&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&#x27;&amp;lt;&#x27;</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;&gt;&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&#x27;&amp;gt;&#x27;</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;&quot;&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&#x27;&amp;quot;&#x27;</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;&amp;&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&#x27;&amp;amp;&#x27;</span>   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>在index.js中定义还原HTML的方法</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">htmlUnEscape</span>(<span class="params">str</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> str.replace(<span class="regexp">/&amp;lt;|&amp;gt;|&amp;quot;|&amp;amp;/g</span>, <span class="function">(<span class="params">match</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">switch</span>(match)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;&amp;lt;&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&#x27;&lt;&#x27;</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;&amp;gt;&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&#x27;&gt;&#x27;</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;&amp;quot;&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&#x27;&quot;&#x27;</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;&amp;amp;&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&#x27;&amp;&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>将不同功能进行模块化拆分</strong></p>
<ol>
<li>将格式化时间的功能，拆分到 src -&gt; dateFormat.js 中</li>
<li>将处理 HTML 字符串的功能，拆分到 src -&gt; htmlEscape.js 中</li>
<li>在 index.js 中，导入两个模块，得到需要向外共享的方法</li>
<li>在 index.js 中，使用 module.exports 把对应的方法共享出去</li>
</ol>
<p><strong>编写包的说明文档</strong></p>
<p>包根目录中的 README.md 文件，是包的使用说明文档。通过它，我们可以事先把包的使用说明，以 markdown 的格式写出来，方便用户参考。README 文件中具体写什么内容，没有强制性的要求；只要能够清晰地把包的作用、用法、注意事项等描述清楚即可。我们所创建的这个包的 README.md 文档中，会包含以下 6 项内容：</p>
<p>安装方式、导入方式、格式化时间、转义 HTML 中的特殊字符、还原 HTML 中的特殊字符、开源协议</p>
<h4 id="3-7-发布包"><a href="#3-7-发布包" class="headerlink" title="3.7 发布包"></a>3.7 发布包</h4><h5 id="3-7-1-注册npm账号"><a href="#3-7-1-注册npm账号" class="headerlink" title="3.7.1 注册npm账号"></a>3.7.1 注册npm账号</h5><ol>
<li><p>访问 <a target="_blank" rel="noopener" href="https://www.npmjs.com/">https://www.npmjs.com/</a> 网站，点击 sign up 按钮，进入注册用户界面</p>
</li>
<li><p>填写账号相关的信息：Full Name、Public Email、Username、Password</p>
<p>wjqixige, <a href="mailto:&#x77;&#117;&#x6a;&#x69;&#97;&#x6e;&#x67;&#53;&#x36;&#x39;&#64;&#x31;&#x32;&#x36;&#x2e;&#99;&#111;&#x6d;">&#x77;&#117;&#x6a;&#x69;&#97;&#x6e;&#x67;&#53;&#x36;&#x39;&#64;&#x31;&#x32;&#x36;&#x2e;&#99;&#111;&#x6d;</a>, wjAIpbj,./1314</p>
</li>
<li><p>点击 Create an Account 按钮，注册账号</p>
</li>
<li><p>登录邮箱，点击验证链接，进行账号的验证</p>
</li>
</ol>
<h5 id="3-7-2-登录npm账号"><a href="#3-7-2-登录npm账号" class="headerlink" title="3.7.2 登录npm账号"></a>3.7.2 登录npm账号</h5><p>npm 账号注册完成后，可以在终端中执行 <code>npm login</code> 命令，依次输入用户名、密码、邮箱后，即可登录成功。</p>
<p>![image-20210417115926066](C:\Users\伍江\AppData\Roaming\Typora\typora-user-images\image-20210417115926066.png %}</p>
<p>注意：在运行 npm login 命令之前，必须先把下包的服务器地址切换为 npm 的官方服务器。否则会导致发布包失败！</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nrm ls</span><br><span class="line">nrm use npm</span><br></pre></td></tr></table></figure>

<h5 id="3-7-3-把包发布到npm上"><a href="#3-7-3-把包发布到npm上" class="headerlink" title="3.7.3 把包发布到npm上"></a>3.7.3 把包发布到npm上</h5><p>将终端切换到包的根目录之后，运行 <code>npm publish</code> 命令，即可将包发布到 npm 上（注意：包名不能雷同）。</p>
<p>![image-20210417115913540](C:\Users\伍江\AppData\Roaming\Typora\typora-user-images\image-20210417115913540.png %}</p>
<h5 id="3-7-4-删除已发布的包"><a href="#3-7-4-删除已发布的包" class="headerlink" title="3.7.4 删除已发布的包"></a>3.7.4 删除已发布的包</h5><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm unpublish 包名 --force</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ol>
<li><p>npm unpublish 命令只能删除 72 小时以内发布的包</p>
</li>
<li><p>npm unpublish 删除的包，在 24 小时内不允许重复发布</p>
</li>
<li><p>发布包的时候要慎重，尽量不要往 npm 上发布没有意义的包！</p>
</li>
</ol>
<h3 id="4-模块的加载机制"><a href="#4-模块的加载机制" class="headerlink" title="4 模块的加载机制"></a>4 模块的加载机制</h3><h4 id="4-1-优先从缓存中加载"><a href="#4-1-优先从缓存中加载" class="headerlink" title="4.1 优先从缓存中加载"></a>4.1 优先从缓存中加载</h4><p><strong>模块在第一次加载后会被缓存</strong>。 这也意味着多次调用 require() 不会导致模块的代码被执行多次。</p>
<p>注意：不论是内置模块、用户自定义模块、还是第三方模块，它们都会优先从缓存中加载，从而提高模块的加载效率。</p>
<h4 id="4-2-内置模块加载机制"><a href="#4-2-内置模块加载机制" class="headerlink" title="4.2 内置模块加载机制"></a>4.2 内置模块加载机制</h4><p>内置模块是由 Node.js 官方提供的模块，内置模块的加载优先级最高。例如，require(‘fs’) 始终返回内置的 fs 模块，即使在 node_modules 目录下有名字相同的包也叫做 fs。</p>
<h4 id="4-3-自定义模块的加载机制"><a href="#4-3-自定义模块的加载机制" class="headerlink" title="4.3 自定义模块的加载机制"></a>4.3 自定义模块的加载机制</h4><p>使用 require() 加载自定义模块时，必须指定以 <code>./</code> 或 <code>../</code> 开头的路径标识符。在加载自定义模块时，如果没有指定 <code>./</code> 或 <code>../</code> 这样的路径标识符，则 node 会把它当作内置模块或第三方模块进行加载。</p>
<p>同时，在使用 require() 导入自定义模块时，如果省略了文件的扩展名，则 Node.js 会按顺序分别尝试加载以下的文件：</p>
<ol>
<li><p>按照确切的文件名进行加载</p>
</li>
<li><p>补全 .js 扩展名进行加载</p>
</li>
<li><p>补全 .json 扩展名进行加载</p>
</li>
<li><p>补全 .node 扩展名进行加载</p>
</li>
<li><p>加载失败，终端报错</p>
</li>
</ol>
<h4 id="4-4-第三方模块的加载机制"><a href="#4-4-第三方模块的加载机制" class="headerlink" title="4.4 第三方模块的加载机制"></a>4.4 第三方模块的加载机制</h4><p>如果传递给 require() 的模块标识符不是一个内置模块，也没有以 <code>./</code> 或 <code>../</code> 开头，则 Node.js 会从当前模块的父目录开始，尝试从 /node_modules 文件夹中加载第三方模块。</p>
<p>如果没有找到对应的第三方模块，则移动到再上一层父目录中，进行加载，直到文件系统的根目录。</p>
<p>例如，假设在 ‘C:\Users\wjqixige\project\foo.js’ 文件里调用了 require(‘tools’)，则 Node.js 会按以下顺序查找：</p>
<ol>
<li>C:\Users\wjqixige\project\node_modules\tools</li>
<li>C:\Users\wjqixige\node_modules\tools</li>
<li>C:\Users\node_modules\tools</li>
<li>C:\node_modules\tools</li>
</ol>
<h4 id="4-5-目录作为模块"><a href="#4-5-目录作为模块" class="headerlink" title="4.5 目录作为模块"></a>4.5 目录作为模块</h4><p>当把目录作为模块标识符，传递给 require() 进行加载的时候，有三种加载方式：</p>
<ol>
<li><p>在被加载的目录下查找一个叫做 package.json 的文件，并寻找 main 属性，作为 require() 加载的入口</p>
</li>
<li><p>如果目录里没有 package.json 文件，或者 main 入口不存在或无法解析，则 Node.js 将会试图加载目录下的 index.js 文件。</p>
</li>
<li><p>如果以上两步都失败了，则 Node.js 会在终端打印错误消息，报告模块的缺失：Error: Cannot find module ‘xxx’</p>
</li>
</ol>
<h2 id="03、Express"><a href="#03、Express" class="headerlink" title="03、Express"></a>03、Express</h2><h3 id="1-初始Express"><a href="#1-初始Express" class="headerlink" title="1 初始Express"></a>1 初始Express</h3><p>官方给出的概念：Express 是基于 Node.js 平台，快速、开放、极简的 Web 开发框架。通俗的理解：Express 的作用和 Node.js 内置的 http 模块类似，是专门用来创建 Web 服务器的。</p>
<p><strong>Express</strong> <strong>的本质</strong>：就是一个 npm 上的第三方包，提供了快速创建 Web 服务器的便捷方法。</p>
<p><strong>中文官网：</strong><a target="_blank" rel="noopener" href="http://www.expressjs.com.cn/"> http://www.expressjs.com.cn/</a></p>
<p><strong>Express能做什么</strong></p>
<p>对于前端程序员来说，最常见的两种服务器，分别是：</p>
<ul>
<li><p>Web 网站服务器：专门对外提供 Web 网页资源的服务器。</p>
</li>
<li><p>API 接口服务器：专门对外提供 API 接口的服务器。</p>
</li>
</ul>
<p>使用 Express，我们可以方便、快速的创建 Web 网站的服务器或 API 接口的服务器。</p>
<h4 id="1-1-基本使用"><a href="#1-1-基本使用" class="headerlink" title="1.1 基本使用"></a>1.1 基本使用</h4><p>在项目所处的目录中，运行如下的终端命令，即可将 express 安装到项目中使用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i express@<span class="number">4.17</span><span class="number">.1</span></span><br></pre></td></tr></table></figure>

<h5 id="1-1-1-创建基本的web服务器"><a href="#1-1-1-创建基本的web服务器" class="headerlink" title="1.1.1 创建基本的web服务器"></a>1.1.1 创建基本的web服务器</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 导入express</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>)</span><br><span class="line"><span class="comment">//2. 创建web服务器</span></span><br><span class="line"><span class="keyword">const</span> app = express()</span><br><span class="line"><span class="comment">//3. 调用app.listen(端口号，回调函数)，启动服务器</span></span><br><span class="line">app.listen(<span class="number">80</span>, <span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;express server running at http://127.0.0.1&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h5 id="1-1-2-监听GET请求"><a href="#1-1-2-监听GET请求" class="headerlink" title="1.1.2 监听GET请求"></a>1.1.2 监听GET请求</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="string">&#x27;请求URL&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>)</span>&#123;<span class="comment">/* 处理函数 */</span>&#125;)</span><br></pre></td></tr></table></figure>

<h5 id="1-1-3-监听POST请求"><a href="#1-1-3-监听POST请求" class="headerlink" title="1.1.3 监听POST请求"></a>1.1.3 监听POST请求</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.post(<span class="string">&#x27;请求URL&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>)</span>&#123;<span class="comment">/* 处理函数 */</span>&#125;)</span><br></pre></td></tr></table></figure>

<h5 id="1-1-4-把内容响应给客户端"><a href="#1-1-4-把内容响应给客户端" class="headerlink" title="1.1.4 把内容响应给客户端"></a>1.1.4 把内容响应给客户端</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="string">&#x27;/user&#x27;</span>, <span class="function">(<span class="params">req,res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//向客户端发送JSON请求</span></span><br><span class="line">    res.send(&#123; <span class="attr">name</span>: <span class="string">&#x27;zs&#x27;</span>, <span class="attr">age</span>: <span class="number">20</span>, <span class="attr">gender</span>: <span class="string">&#x27;男&#x27;</span>&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">app.post(<span class="string">&#x27;/user&#x27;</span>, <span class="function">(<span class="params">req,res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//向客户端发送文本内容</span></span><br><span class="line">    res.send(<span class="string">&#x27;请求成功&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h5 id="1-1-5-获取URL中携带的查询参数"><a href="#1-1-5-获取URL中携带的查询参数" class="headerlink" title="1.1.5 获取URL中携带的查询参数"></a>1.1.5 获取URL中携带的查询参数</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="string">&#x27;/&#x27;</span>, <span class="function">(<span class="params">req,res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// req.query 默认是一个空对象</span></span><br><span class="line">    <span class="comment">// 客户端使用 ?name=zs&amp;age=20 这种查询字符串形式，发送到服务器的参数</span></span><br><span class="line">    <span class="comment">// 可以通过req.query对象访问，例如：</span></span><br><span class="line">    <span class="comment">// req.query.name req.query.age</span></span><br><span class="line">    <span class="built_in">console</span>.log(req.query)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h5 id="1-1-6-获取URL中的动态参数"><a href="#1-1-6-获取URL中的动态参数" class="headerlink" title="1.1.6 获取URL中的动态参数"></a>1.1.6 获取URL中的动态参数</h5><p>通过 req.params 对象，可以访问到 URL 中，通过 <code>:</code> 匹配到的动态参数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// URL地址中，可以通过 :参数名 的形式，匹配动态参数值</span></span><br><span class="line">app.get(<span class="string">&#x27;/user/:id/:name&#x27;</span>, <span class="function">(<span class="params">req,res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// req.params 默认是一个空对象</span></span><br><span class="line">    <span class="comment">// 里面存放着通过：动态匹配到的参数值</span></span><br><span class="line">    <span class="built_in">console</span>.log(req.params)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="1-2-托管静态资源"><a href="#1-2-托管静态资源" class="headerlink" title="1.2 托管静态资源"></a>1.2 托管静态资源</h4><h5 id="1-2-1-express-static"><a href="#1-2-1-express-static" class="headerlink" title="1.2.1 express.static()"></a>1.2.1 express.static()</h5><p>express 提供了一个非常好用的函数，叫做 <code>express.static()</code>，通过它，我们可以非常方便地<strong>创建一个静态资源服务器</strong>，例如，通过如下代码就可以将 public 目录下的图片、CSS 文件、JavaScript 文件对外开放访问了：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.use(express.static(<span class="string">&#x27;public&#x27;</span>))</span><br></pre></td></tr></table></figure>

<p>现在，你就可以访问 public 目录中的所有文件了：</p>
<p><a target="_blank" rel="noopener" href="http://localhost:3000/images/bg.jpg">http://localhost:3000/images/bg.jpg</a></p>
<p><a target="_blank" rel="noopener" href="http://localhost:3000/css/style.css">http://localhost:3000/css/style.css</a></p>
<p><a target="_blank" rel="noopener" href="http://localhost:3000/js/login.js">http://localhost:3000/js/login.js</a></p>
<blockquote>
<p><strong>注意：</strong>Express 在指定的静态目录中查找文件，并对外提供资源的访问路径。因此，存放静态文件的目录名不会出现在 URL 中。</p>
</blockquote>
<h5 id="1-2-2-托管多个静态资源目录"><a href="#1-2-2-托管多个静态资源目录" class="headerlink" title="1.2.2 托管多个静态资源目录"></a>1.2.2 托管多个静态资源目录</h5><p>如果要托管多个静态资源目录，请多次调用 express.static() 函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">app.use(express.static(<span class="string">&#x27;public&#x27;</span>))</span><br><span class="line">app.use(express.static(<span class="string">&#x27;files&#x27;</span>))</span><br></pre></td></tr></table></figure>

<p>访问静态资源文件时，express.static() 函数会根据目录的添加顺序查找所需的文件。</p>
<h5 id="1-2-3-挂在路径前缀"><a href="#1-2-3-挂在路径前缀" class="headerlink" title="1.2.3 挂在路径前缀"></a>1.2.3 挂在路径前缀</h5><p>如果希望在托管的静态资源访问路径之前，挂载路径前缀，则可以使用如下的方式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.use(<span class="string">&#x27;/public&#x27;</span>, express.static(<span class="string">&#x27;public&#x27;</span>))</span><br></pre></td></tr></table></figure>

<p>现在，你就可以通过带有 /public 前缀地址来访问 public 目录中的文件了：</p>
<p><a target="_blank" rel="noopener" href="http://localhost:3000/public/images/kitten.jpg">http://localhost:3000/public/images/kitten.jpg</a></p>
<p><a target="_blank" rel="noopener" href="http://localhost:3000/public/css/style.css">http://localhost:3000/public/css/style.css</a></p>
<p><a target="_blank" rel="noopener" href="http://localhost:3000/public/js/app.js">http://localhost:3000/public/js/app.js</a></p>
<h4 id="1-3-nodemon"><a href="#1-3-nodemon" class="headerlink" title="1.3 nodemon"></a>1.3 nodemon</h4><p>在编写调试 Node.js 项目的时候，如果修改了项目的代码，则需要频繁的手动close 掉，然后再重新启动，非常繁琐。现在，我们可以使用 nodemon（<a target="_blank" rel="noopener" href="https://www.npmjs.com/package/nodemon%EF%BC%89">https://www.npmjs.com/package/nodemon）</a> 这个工具，它能够监听项目文件的变动，当代码被修改后，nodemon 会自动帮我们重启项目，极大方便了开发和调试。</p>
<p><strong>安装</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g nodemon</span><br></pre></td></tr></table></figure>

<p><strong>使用</strong></p>
<p>当基于 Node.js 编写了一个网站应用的时候，传统的方式，是运行 node app.js 命令，来启动项目。这样做的坏处是：代码被修改之后，需要手动重启项目。现在，我们可以将 node 命令替换为 nodemon 命令，使用 nodemon app.js 来启动项目。</p>
<p>好处：代码被修改之后，会被 nodemon 监听到，从而实现自动重启项目的效果。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nodemon app.js</span><br></pre></td></tr></table></figure>

<h3 id="2-Express路由"><a href="#2-Express路由" class="headerlink" title="2 Express路由"></a>2 Express路由</h3><h4 id="2-1-概念"><a href="#2-1-概念" class="headerlink" title="2.1 概念"></a>2.1 概念</h4><p>广义上来讲，路由就是映射关系。</p>
<p>在 Express 中，路由指的是<strong>客户端的请求与服务器处理函数之间的映射关系</strong>。Express 中的路由分 3 部分组成，分别是<code>请求的类型</code>、<code>请求的 URL 地址</code>、<code>处理函数</code>，格式如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.METHOD(PATH, HANDLER)</span><br></pre></td></tr></table></figure>

<p><strong>示例</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="string">&#x27;/&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">    res.send(<span class="string">&#x27;hello world&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">app.post(<span class="string">&#x27;/&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">    res.send(<span class="string">&#x27;GET a POST request&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h5 id="2-1-1-匹配过程"><a href="#2-1-1-匹配过程" class="headerlink" title="2.1.1 匹配过程"></a>2.1.1 匹配过程</h5><p>每当一个请求到达服务器之后，需要先经过路由的匹配，只有匹配成功之后，才会调用对应的处理函数。</p>
<p>在匹配时，会按照路由的顺序进行匹配，如果请求类型和请求的 URL 同时匹配成功，则 Express 会将这次请求，转交给对应的 function 函数进行处理。</p>
<img src="/2021/05/06/Node%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/node020.png" class="">

<p>路由匹配的注意点：</p>
<ol>
<li><p>按照定义的先后顺序进行匹配</p>
</li>
<li><p>请求类型和请求的URL同时匹配成功，才会调用对应的处理函数</p>
</li>
</ol>
<h4 id="2-2-使用"><a href="#2-2-使用" class="headerlink" title="2.2 使用"></a>2.2 使用</h4><p>在 Express 中使用路由最简单的方式，就是把路由挂载到 app 上，示例代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = express()</span><br><span class="line"><span class="comment">//挂在路由</span></span><br><span class="line">app.get(<span class="string">&#x27;/&#x27;</span>, <span class="function">(<span class="params">req,res</span>) =&gt;</span> &#123; res.send(<span class="string">&#x27;Get Request.&#x27;</span>)&#125;)</span><br><span class="line">app.posp(<span class="string">&#x27;/&#x27;</span>, <span class="function">(<span class="params">req,res</span>) =&gt;</span> &#123; res.send(<span class="string">&#x27;Post Request.&#x27;</span>)&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">80</span>, <span class="function">()=&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;server running at http://127.0.0.1&#x27;</span>)&#125;)</span><br></pre></td></tr></table></figure>

<h5 id="2-2-1-模块化路由"><a href="#2-2-1-模块化路由" class="headerlink" title="2.2.1 模块化路由"></a>2.2.1 模块化路由</h5><p>为了方便对路由进行模块化的管理，Express <strong>不建议</strong>将路由直接挂载到 app 上，而是推荐将路由抽离为单独的模块。将路由抽离为单独模块的步骤如下：</p>
<ol>
<li><p>创建路由模块对应的 .js 文件</p>
</li>
<li><p>调用 express.Router() 函数创建路由对象</p>
</li>
<li><p>向路由对象上挂载具体的路由</p>
</li>
<li><p>使用 module.exports 向外共享路由对象</p>
</li>
<li><p>使用 app.use() 函数注册路由模块</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> router = express.Router()  <span class="comment">// 创建路由对象</span></span><br><span class="line"></span><br><span class="line">router.get(<span class="string">&#x27;/user/list&#x27;</span>, <span class="function">(<span class="params">req,res</span>) =&gt;</span> &#123;  <span class="comment">// 挂载路由</span></span><br><span class="line">    res.send(<span class="string">&#x27;Get user list.&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">router.post(<span class="string">&#x27;/user/add&#x27;</span>, <span class="function">(<span class="params">req,res</span>) =&gt;</span> &#123;</span><br><span class="line">    res.send(<span class="string">&#x27;Add new user.&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = router  <span class="comment">// 向外导出路由对象</span></span><br></pre></td></tr></table></figure>

<h5 id="2-2-2-注册路由模块"><a href="#2-2-2-注册路由模块" class="headerlink" title="2.2.2 注册路由模块"></a>2.2.2 注册路由模块</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 导入路由模块</span></span><br><span class="line"><span class="keyword">const</span> userRouter = <span class="built_in">require</span>(<span class="string">&#x27;./router/user.js&#x27;</span>)</span><br><span class="line"><span class="comment">//2. 使用app.use() 注册路由模块</span></span><br><span class="line">app.use(userRouter)</span><br></pre></td></tr></table></figure>

<h5 id="2-2-3-为路由模块添加前缀"><a href="#2-2-3-为路由模块添加前缀" class="headerlink" title="2.2.3 为路由模块添加前缀"></a>2.2.3 为路由模块添加前缀</h5><p>类似于托管静态资源时，为静态资源统一挂载访问前缀一样，路由模块添加前缀的方式也非常简单：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> userRouter = <span class="built_in">require</span>(<span class="string">&#x27;./router/user.js&#x27;</span>)</span><br><span class="line">app.use(<span class="string">&#x27;/api&#x27;</span>, userRouter)</span><br></pre></td></tr></table></figure>

<h3 id="3-Express中间件"><a href="#3-Express中间件" class="headerlink" title="3 Express中间件"></a>3 Express中间件</h3><h4 id="3-1-概念"><a href="#3-1-概念" class="headerlink" title="3.1 概念"></a>3.1 概念</h4><p>中间件（Middleware ），特指业务流程的中间处理环节。当一个请求到达 Express 的服务器之后，可以连续调用多个中间件，从而对这次请求进行预处理。</p>
<img src="/2021/05/06/Node%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/node021.png" class="">

<h5 id="3-1-1-中间件格式"><a href="#3-1-1-中间件格式" class="headerlink" title="3.1.1 中间件格式"></a>3.1.1 中间件格式</h5><p>Express 的中间件，本质上就是一个 <strong>function</strong> <strong>处理函数</strong>，Express 中间件的格式如下：</p>
<img src="/2021/05/06/Node%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/node022.png" class="">

<p>注意：中间件函数的形参列表中，<strong>必须包含 next 参数</strong>。而路由处理函数中只包含 req 和 res。</p>
<h5 id="3-1-2-next函数的作用"><a href="#3-1-2-next函数的作用" class="headerlink" title="3.1.2 next函数的作用"></a>3.1.2 next函数的作用</h5><p><strong>next</strong> <strong>函数</strong>是实现<strong>多个中间件连续调用</strong>的关键，它表示把流转关系转交给下一个<strong>中间件</strong>或<strong>路由</strong>。</p>
<img src="/2021/05/06/Node%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/node023.png" class="">

<h4 id="3-2-初体验"><a href="#3-2-初体验" class="headerlink" title="3.2 初体验"></a>3.2 初体验</h4><h5 id="3-2-1-定义中间件函数"><a href="#3-2-1-定义中间件函数" class="headerlink" title="3.2.1 定义中间件函数"></a>3.2.1 定义中间件函数</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//常量mw所指向的，就是一个中间件函数</span></span><br><span class="line"><span class="keyword">const</span> mw = <span class="function"><span class="keyword">function</span>(<span class="params">req,res,next</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;这是一个最简单的中间件函数&#x27;</span>)</span><br><span class="line">    <span class="comment">//注意：在房钱中间件的业务处理完毕后，必须调用next()函数</span></span><br><span class="line">    <span class="comment">//表示把流转关系转交给下一个中间件或路由</span></span><br><span class="line">    next()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-2-2-全局生效的中间件"><a href="#3-2-2-全局生效的中间件" class="headerlink" title="3.2.2 全局生效的中间件"></a>3.2.2 全局生效的中间件</h5><p>客户端发起的<strong>任何请求</strong>，到达服务器之后，<strong>都会触发的中间件</strong>，叫做全局生效的中间件。通过调用 <code>app.use(中间件函数)</code>，即可定义一个全局生效的中间件，示例代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mw = <span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;这是一个最简单的中间件函数&#x27;</span>)</span><br><span class="line">    next()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 全局生效的中间件</span></span><br><span class="line">app.use(mw)</span><br></pre></td></tr></table></figure>

<p><strong>简化形式</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.use(<span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;这是一个最简单的中间件函数&#x27;</span>)</span><br><span class="line">    next()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h5 id="3-2-3-中间件的作用"><a href="#3-2-3-中间件的作用" class="headerlink" title="3.2.3 中间件的作用"></a>3.2.3 中间件的作用</h5><p>多个中间件之间，<strong>共享同一份</strong> <strong>req</strong> <strong>和</strong> <strong>res</strong>。基于这样的特性，我们可以在上游的中间件中，<strong>统一</strong>为 req 或 res 对象添加自定义的属性或方法，供下游的中间件或路由进行使用。</p>
<h5 id="3-2-4-定义多个全局中间件"><a href="#3-2-4-定义多个全局中间件" class="headerlink" title="3.2.4 定义多个全局中间件"></a>3.2.4 定义多个全局中间件</h5><p>可以使用 app.use() <strong>连续定义多个</strong>全局中间件。客户端请求到达服务器之后，会按照中间件<strong>定义的先后顺序</strong>依次进行调用，示例代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">app.use(<span class="function"><span class="keyword">function</span>(<span class="params">req,res,next</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;调用了第1个全局中间件&#x27;</span>)</span><br><span class="line">    next()</span><br><span class="line">&#125;)</span><br><span class="line">app.use(<span class="function"><span class="keyword">function</span>(<span class="params">req,res,next</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;调用了第2个全局中间件&#x27;</span>)</span><br><span class="line">    next()</span><br><span class="line">&#125;)</span><br><span class="line">app.get(<span class="string">&#x27;/user&#x27;</span>, <span class="function">(<span class="params">req,res</span>) =&gt;</span> &#123;</span><br><span class="line">    res.send(<span class="string">&#x27;Home page.&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h5 id="3-2-5-局部生效的中间件"><a href="#3-2-5-局部生效的中间件" class="headerlink" title="3.2.5 局部生效的中间件"></a>3.2.5 局部生效的中间件</h5><p><strong>不使用</strong> app.use() 定义的中间件，叫做局部生效的中间件，示例代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mw = <span class="function"><span class="keyword">function</span>(<span class="params">req,res,next</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;中间件&#x27;</span>)</span><br><span class="line">    next()</span><br><span class="line">&#125;</span><br><span class="line">app.get(<span class="string">&#x27;/&#x27;</span>, mw, <span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123; res.send(<span class="string">&#x27;Home page.&#x27;</span>)&#125;)  <span class="comment">//在当前路由有效</span></span><br><span class="line">app.get(<span class="string">&#x27;/user&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123; res.send(<span class="string">&quot;User page.&quot;</span>)&#125;)  <span class="comment">//在该路由中无效</span></span><br></pre></td></tr></table></figure>

<h5 id="3-2-6-定义多个局部路由"><a href="#3-2-6-定义多个局部路由" class="headerlink" title="3.2.6 定义多个局部路由"></a>3.2.6 定义多个局部路由</h5><p>可以在路由中，通过如下两种等价的方式，使用多个局部中间件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="string">&#x27;/&#x27;</span>, mw1,mw2, <span class="function">(<span class="params">req,res</span>) =&gt;</span> &#123; res.send(<span class="string">&#x27;Home page.&#x27;</span>)&#125;)</span><br><span class="line">app.get(<span class="string">&#x27;/&#x27;</span>, [mw1,mw2], <span class="function">(<span class="params">req,res</span>) =&gt;</span> &#123; res.send(<span class="string">&#x27;Home page.&#x27;</span>)&#125;)</span><br></pre></td></tr></table></figure>

<h5 id="3-2-7-注意事项"><a href="#3-2-7-注意事项" class="headerlink" title="3.2.7 注意事项"></a>3.2.7 注意事项</h5><ol>
<li>一定要在路由<strong>之前</strong>注册中间件</li>
<li>客户端发送过来的请求，<strong>可以连续调用多个</strong>中间件进行处理</li>
<li>执行完中间件的业务代码之后，<strong>不要忘记调用 next() 函数</strong></li>
<li>为了<strong>防止代码逻辑混乱</strong>，调用 next() 函数后不要再写额外的代码</li>
<li>连续调用多个中间件时，多个中间件之间，<strong>共享</strong> req 和 res 对象</li>
</ol>
<h4 id="3-3-中间件的分类"><a href="#3-3-中间件的分类" class="headerlink" title="3.3 中间件的分类"></a>3.3 中间件的分类</h4><p>为了方便理解和记忆中间件的使用，Express 官方把常见的中间件用法，分成了 5 大类，分别是：</p>
<ol>
<li>应用级别的中间件</li>
<li>路由级别的中间件</li>
<li>错误级别的中间件</li>
<li>Express 内置的中间件</li>
<li>第三方的中间件</li>
</ol>
<h5 id="3-3-1-应用级别的中间件"><a href="#3-3-1-应用级别的中间件" class="headerlink" title="3.3.1 应用级别的中间件"></a>3.3.1 应用级别的中间件</h5><p>通过 <code>app.use()</code> 或 <code>app.get()</code> 或 <code>app.post()</code> ，绑定到 app 实例上的中间件，叫做应用级别的中间件，代码示例如下：</p>
<img src="/2021/05/06/Node%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/node024.png" class="">

<h5 id="3-3-2-路由级别的中间件"><a href="#3-3-2-路由级别的中间件" class="headerlink" title="3.3.2 路由级别的中间件"></a>3.3.2 路由级别的中间件</h5><p>绑定到 <code>express.Router()</code> 实例上的中间件，叫做路由级别的中间件。它的用法和应用级别中间件没有任何区别。只不过，应用级别中间件是绑定到 app 实例上，路由级别中间件绑定到 router 实例上，代码示例如下：</p>
<img src="/2021/05/06/Node%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/node025.png" class="">

<h5 id="3-3-3-错误级别的中间件"><a href="#3-3-3-错误级别的中间件" class="headerlink" title="3.3.3 错误级别的中间件"></a>3.3.3 错误级别的中间件</h5><p><strong>作用</strong>：专门用来捕获整个项目中发生的异常错误，从而防止项目异常崩溃的问题。</p>
<p><strong>格式</strong>：错误级别中间件的 function 处理函数中，<strong>必须有 4 个形参</strong>，形参顺序从前到后，分别是 <code>(err, req, res, next)</code></p>
<img src="/2021/05/06/Node%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/node026.png" class="">

<p><strong>注意：</strong>错误级别的中间件，必须注册在所有路由之后！</p>
<h5 id="3-3-4-Express内置的中间件"><a href="#3-3-4-Express内置的中间件" class="headerlink" title="3.3.4 Express内置的中间件"></a>3.3.4 Express内置的中间件</h5><p>自 Express 4.16.0 版本开始，Express 内置了 3 个常用的中间件，极大的提高了 Express 项目的开发效率和体验：</p>
<ol>
<li><p><code>express.static</code> 快速托管静态资源的内置中间件，例如： HTML 文件、图片、CSS 样式等（无兼容性）</p>
</li>
<li><p><code>express.json</code> 解析 JSON 格式的请求体数据（有兼容性，仅在 4.16.0+ 版本中可用）</p>
</li>
<li><p><code>express.urlencoded</code> 解析 URL-encoded 格式的请求体数据（有兼容性，仅在 4.16.0+ 版本中可用）</p>
</li>
</ol>
<img src="/2021/05/06/Node%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/node027.png" class="">

<h5 id="3-3-5-第三方的中间件"><a href="#3-3-5-第三方的中间件" class="headerlink" title="3.3.5 第三方的中间件"></a>3.3.5 第三方的中间件</h5><p>非 Express 官方内置的，而是由第三方开发出来的中间件，叫做第三方中间件。在项目中，大家可以<strong>按需</strong>下载并<strong>配置</strong>第三方中间件，从而提高项目的开发效率。</p>
<p>例如：在 <a href="mailto:&#x65;&#120;&#x70;&#114;&#x65;&#115;&#115;&#64;&#52;&#x2e;&#49;&#x36;&#46;&#48;">&#x65;&#120;&#x70;&#114;&#x65;&#115;&#115;&#64;&#52;&#x2e;&#49;&#x36;&#46;&#48;</a> 之前的版本中，经常使用 body-parser 这个第三方中间件，来解析请求体数据。使用步骤如下：</p>
<ol>
<li><p>运行 <code>npm install body-parser</code> 安装中间件</p>
</li>
<li><p>使用 require 导入中间件</p>
</li>
<li><p>调用 <code>app.use()</code> 注册并使用中间件</p>
</li>
</ol>
<p><strong>注意：</strong>Express 内置的 express.urlencoded 中间件，就是基于 body-parser 这个第三方中间件进一步封装出来的。</p>
<h4 id="3-4-自定义中间件"><a href="#3-4-自定义中间件" class="headerlink" title="3.4 自定义中间件"></a>3.4 自定义中间件</h4><p>自己手动模拟一个类似于 express.urlencoded 这样的中间件，来解析 POST 提交到服务器的表单数据。</p>
<p>实现步骤：</p>
<ol>
<li><p>定义中间件</p>
<p>使用app.use()来定义全局生效的中间件，代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.use(<span class="function"><span class="keyword">function</span>(<span class="params">req,res,next</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//中间件的业务逻辑</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>监听 req 的 data 事件</p>
<p>在中间件中，需要监听 req 对象的 data 事件，来获取客户端发送到服务器的数据。</p>
<p>如果数据量比较大，无法一次性发送完毕，则客户端会把数据切割后，分批发送到服务器。所以 data 事件可能会触发多次，每一次触发 data 事件时，获取到数据只是完整数据的一部分，需要手动对接收到的数据进行拼接。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义变量，用来存储客户端发送过来的请求数据</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="comment">//监听 req对象的 data事件(客户端发送过来的新的请求体数据)</span></span><br><span class="line">req.on(<span class="string">&#x27;data&#x27;</span>, <span class="function">(<span class="params">chunk</span>) =&gt;</span>&#123;</span><br><span class="line">    str += chunk</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>监听 req 的 end 事件</p>
<p>当请求体数据接收完毕后，会自动触发req和end事件。因此，可以在req和end事件中，拿到并处理完整的请求体数。示例如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">req.on(<span class="string">&#x27;end&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(str)</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 把字符串格式的请求体数据，解析成对象格式</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>使用 querystring 模块解析请求体数据</p>
<p>Node.js 内置了一个 querystring 模块，专门用来处理查询字符串。通过这个模块提供的 parse() 函数，可以轻松把查询字符串，解析成对象的格式。示例代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> qs = <span class="built_in">require</span>(<span class="string">&#x27;querystring&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> body = qs.parse(str)</span><br></pre></td></tr></table></figure></li>
<li><p>将解析出来的数据对象挂载为 req.body</p>
<p>上游的中间件和下游的中间件及路由之间，<strong>共享同一份</strong> <strong>req</strong> <strong>和</strong> <strong>res</strong>。因此，我们可以将解析出来的数据，挂载为 req 的自定义属性，命名为 req.body，供下游使用。示例代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">req.on(<span class="string">&#x27;end&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> body = qs.parse(str)</span><br><span class="line">    req.body = body</span><br><span class="line">    next()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>将自定义中间件封装为模块</p>
<p>为了优化代码的结构，我们可以把自定义的中间件函数，封装为独立的模块，示例代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> qs = <span class="built_in">require</span>(<span class="string">&#x27;querystring&#x27;</span>)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bodyParser</span>(<span class="params">req,res,next</span>)</span>&#123; <span class="comment">/* 省略其它代码 */</span> &#125;</span><br><span class="line"><span class="built_in">module</span>.exports = bodyParser  <span class="comment">//向外导出</span></span><br><span class="line"><span class="comment">//---------------分割线------------------</span></span><br><span class="line"><span class="keyword">const</span> myBodyParser = <span class="built_in">require</span>(<span class="string">&#x27;custom-body-parser&#x27;</span>)</span><br><span class="line">app.use(myBodyParser)</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="4-使用Express写接口"><a href="#4-使用Express写接口" class="headerlink" title="4 使用Express写接口"></a>4 使用Express写接口</h3><h4 id="4-1-创建基本服务器"><a href="#4-1-创建基本服务器" class="headerlink" title="4.1 创建基本服务器"></a>4.1 创建基本服务器</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> app = express()</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">80</span>,<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Express server running at http://127.0.0.1&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="4-2-创建API路由模块"><a href="#4-2-创建API路由模块" class="headerlink" title="4.2 创建API路由模块"></a>4.2 创建API路由模块</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//apiRouter.js【路由模块】</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> apiRouter = express.Router()</span><br><span class="line"><span class="built_in">module</span>.exports = apiRouter</span><br><span class="line"><span class="comment">//--------------------------------</span></span><br><span class="line"><span class="comment">//api.js【导入并注册路由模块】</span></span><br><span class="line"><span class="keyword">const</span> apiRouter = <span class="built_in">require</span>(<span class="string">&#x27;./apiRouter.js&#x27;</span>)</span><br><span class="line">app.use(<span class="string">&#x27;/api&#x27;</span>, apiRouter)</span><br></pre></td></tr></table></figure>

<h4 id="4-3-编写GET接口"><a href="#4-3-编写GET接口" class="headerlink" title="4.3 编写GET接口"></a>4.3 编写GET接口</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">apiRouter.get(<span class="string">&#x27;/get&#x27;</span>, <span class="function">(<span class="params">req,res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> query = req.query</span><br><span class="line">    res.send(&#123;</span><br><span class="line">        status: <span class="number">0</span>,</span><br><span class="line">        msg: <span class="string">&#x27;GET请求成功&#x27;</span>,</span><br><span class="line">        data: query</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="4-4-编写POST接口"><a href="#4-4-编写POST接口" class="headerlink" title="4.4 编写POST接口"></a>4.4 编写POST接口</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">apiRouter.post(<span class="string">&#x27;/post&#x27;</span>, <span class="function">(<span class="params">req,res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> body = req.body</span><br><span class="line">    res.send(&#123;</span><br><span class="line">        status: <span class="number">0</span>,</span><br><span class="line">        msg: <span class="string">&#x27;POST请求成功！&#x27;</span>,</span><br><span class="line">        data: body</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p> 注意：如果要获取 URL-encoded 格式的请求体数据，必须配置中间件 app.use(express.urlencoded({ extended: false }))</p>
</blockquote>
<h4 id="4-5-CORS跨域资源共享"><a href="#4-5-CORS跨域资源共享" class="headerlink" title="4.5 CORS跨域资源共享"></a>4.5 CORS跨域资源共享</h4><h5 id="4-5-1-接口的跨域问题"><a href="#4-5-1-接口的跨域问题" class="headerlink" title="4.5.1 接口的跨域问题"></a>4.5.1 接口的跨域问题</h5><p>刚才编写的 GET 和 POST接口，存在一个很严重的问题：不支持跨域请求。</p>
<p>解决接口跨域问题的方案主要有两种：</p>
<ol>
<li><p>CORS（主流的解决方案，推荐使用）</p>
</li>
<li><p>JSONP（有缺陷的解决方案：只支持 GET 请求）</p>
</li>
</ol>
<h5 id="4-5-2-使用cors中间件解决跨域问题"><a href="#4-5-2-使用cors中间件解决跨域问题" class="headerlink" title="4.5.2 使用cors中间件解决跨域问题"></a>4.5.2 使用cors中间件解决跨域问题</h5><p>cors 是 Express 的一个第三方中间件。通过安装和配置 cors 中间件，可以很方便地解决跨域问题。</p>
<p>使用步骤分为如下 3 步：</p>
<ol>
<li>运行 <code>npm install cors</code> 安装中间件</li>
<li>使用 <code>const cors = require(&#39;cors&#39;)</code>导入中间件(路由之前)</li>
<li>在路由之前调用 <code>app.use(cors())</code> 配置中间件</li>
</ol>
<h5 id="4-5-3-什么是CORS"><a href="#4-5-3-什么是CORS" class="headerlink" title="4.5.3 什么是CORS"></a>4.5.3 什么是CORS</h5><p>CORS （Cross-Origin Resource Sharing，跨域资源共享）由一系列 HTTP 响应头组成，<strong>这些</strong> <strong>HTTP</strong> <strong>响应头决定浏览器是否阻止前端</strong> <strong>JS</strong> <strong>代码跨域获取资源</strong>。</p>
<p>浏览器的同源安全策略默认会阻止网页“跨域”获取资源。但如果接口服务器配置了 CORS 相关的 HTTP 响应头，就可以解除浏览器端的跨域访问限制。</p>
<p>![image-20210417193219606](F:/wujiang/笔记/01_前端开发系列/10_Node/imgs/node028.png %}</p>
<h5 id="4-5-4-CORS注意事项"><a href="#4-5-4-CORS注意事项" class="headerlink" title="4.5.4 CORS注意事项"></a>4.5.4 CORS注意事项</h5><ol>
<li><p>CORS 主要在服务器端进行配置。客户端浏览器<strong>无须做任何额外的配置</strong>，即可请求开启了 CORS 的接口。</p>
</li>
<li><p>CORS 在浏览器中有兼容性。只有支持 XMLHttpRequest Level2 的浏览器，才能正常访问开启了 CORS 的服务端接口（例如：IE10+、Chrome4+、FireFox3.5+）。</p>
</li>
</ol>
<h5 id="4-5-5-Access-Control-Allow-Origin"><a href="#4-5-5-Access-Control-Allow-Origin" class="headerlink" title="4.5.5 Access-Control-Allow-Origin"></a>4.5.5 Access-Control-Allow-Origin</h5><p>响应头部中可以携带一个 <strong>Access-Control-Allow-Origin</strong> 字段，其语法如下:</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Access-Control-Allow-Origin</span><span class="punctuation">: </span>&lt;origin&gt; | *</span><br></pre></td></tr></table></figure>

<p>其中，origin 参数的值指定了允许访问该资源的外域 URL。例如，下面的字段值将<strong>只允许</strong>来自 <a target="_blank" rel="noopener" href="http://wjqixige.cn/">http://wjqixige.cn</a> 的请求：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res.setHeader(&#x27;Access-Control-Allow-Origin&#x27;,&#x27;http://www.wjqixige.cn&#x27;)</span><br></pre></td></tr></table></figure>

<p>如果指定了 Access-Control-Allow-Origin 字段的值为通配符 <code>*</code>，表示允许来自任何域的请求，示例代码如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res.setHeader(&#x27;Access-Control-Allow-Origin&#x27;, &#x27;*&#x27;)</span><br></pre></td></tr></table></figure>

<h5 id="4-5-6-Access-Control-Allow-Headers"><a href="#4-5-6-Access-Control-Allow-Headers" class="headerlink" title="4.5.6 Access-Control-Allow-Headers"></a>4.5.6 Access-Control-Allow-Headers</h5><p>默认情况下，CORS <strong>仅</strong>支持客户端向服务器发送如下的 9 个请求头：</p>
<p><code>Accept</code>、<code>Accept-Language</code>、<code>Content-Language</code>、<code>DPR</code>、<code>Downlink</code>、<code>Save-Data</code>、<code>Viewport-Width</code>、<code>Width</code> 、<code>Content-Type</code> （值仅限于 text/plain、multipart/form-data、application/x-www-form-urlencoded 三者之一）</p>
<p>如果客户端向服务器<strong>发送了额外的请求头信息</strong>，则需要在<strong>服务器端</strong>，通过 <code>Access-Control-Allow-Headers</code> <strong>对额外的请求头进行声明</strong>，否则这次请求会失败！</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//允许客户端额外向服务器发送Content-Type请求头和X-Custom-Header请求头</span><br><span class="line">//注意：多个请求头之间使用英文的逗号进行分割</span><br><span class="line">res.setHeader(&#x27;Access-Control-Allow-Headers&#x27;, &#x27;Content-Type, X-Custom-Header&#x27;)</span><br></pre></td></tr></table></figure>

<h5 id="4-5-7-Access-Control-Allow-Methods"><a href="#4-5-7-Access-Control-Allow-Methods" class="headerlink" title="4.5.7 Access-Control-Allow-Methods"></a>4.5.7 Access-Control-Allow-Methods</h5><p>默认情况下，CORS 仅支持客户端发起 GET、POST、HEAD 请求。如果客户端希望通过 PUT、DELETE 等方式请求服务器的资源，则需要在服务器端，通过 <code>Access-Control-Alow-Methods</code>来指明实际请求所允许使用的 HTTP 方法。示例代码如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//只允许POST、GET、DELETE、HEAD请求方法</span><br><span class="line">res.setHeader(&#x27;Access-Control-Allow-Methods&#x27;, &#x27;POST, GET, DELETE, HEAD&#x27;)</span><br><span class="line">//允许所有的HTTP请求方法</span><br><span class="line">res.setHeader(&#x27;Access-Control-Allow-Methods&#x27;, &#x27;*&#x27;)</span><br></pre></td></tr></table></figure>

<h5 id="4-5-8-CORS请求的分类"><a href="#4-5-8-CORS请求的分类" class="headerlink" title="4.5.8 CORS请求的分类"></a>4.5.8 CORS请求的分类</h5><p>客户端在请求 CORS 接口时，根据<strong>请求方式</strong>和<strong>请求头</strong>的不同，可以将 CORS 的请求分为两大类，分别是：</p>
<ol>
<li><p><strong>简单请求</strong></p>
<p>同时满足以下两大条件的请求，就属于简单请求：</p>
<ol>
<li><p>请求方式：GET、POST、HEAD 三者之一</p>
</li>
<li><p>HTTP 头部信息不超过以下几种字段：无自定义头部字段、Accept、Accept-Language、Content-Language、DPR、Downlink、Save-Data、Viewport-Width、Width 、Content-Type（只有三个值application/x-www-form-urlencoded、multipart/form-data、text/plain）</p>
</li>
</ol>
</li>
<li><p>预检请求</p>
<p>只要符合以下任何一个条件的请求，都需要进行预检请求：</p>
<ol>
<li><p>请求方式为 <strong>GET、POST、HEAD 之外的请求 Method 类型</strong></p>
</li>
<li><p>请求头中<strong>包含自定义头部字段</strong></p>
</li>
<li><p>向服务器发送了 <strong>application/json 格式的数据</strong></p>
</li>
</ol>
<p>在浏览器与服务器正式通信之前，浏览器会先发送 OPTION 请求进行预检，以获知服务器是否允许该实际请求，所以这一次的 OPTION 请求称为“预检请求”。服务器成功响应预检请求后，才会发送真正的请求，并且携带真实数据。</p>
</li>
</ol>
<p><strong>简单请求和预检请求的区别</strong></p>
<p><strong>简单请求的特点</strong>：客户端与服务器之间只会发生一次请求。</p>
<p><strong>预检请求的特点</strong>：客户端与服务器之间会发生两次请求，OPTION 预检请求成功之后，才会发起真正的请求。</p>
<h4 id="4-6-JSONP接口"><a href="#4-6-JSONP接口" class="headerlink" title="4.6 JSONP接口"></a>4.6 JSONP接口</h4><p><strong>概念：</strong>浏览器端通过 <code>&lt;script&gt;</code> 标签的 src 属性，请求服务器上的数据，同时，服务器返回一个函数的调用。这种请求数据的方式叫做 JSONP。</p>
<p><strong>特点：</strong></p>
<ol>
<li><p>JSONP 不属于真正的 Ajax 请求，因为它没有使用 XMLHttpRequest 这个对象。</p>
</li>
<li><p>JSONP 仅支持 GET 请求，不支持 POST、PUT、DELETE 等请求。</p>
</li>
</ol>
<h5 id="4-6-1-创建JSONP接口的注意事项"><a href="#4-6-1-创建JSONP接口的注意事项" class="headerlink" title="4.6.1 创建JSONP接口的注意事项"></a>4.6.1 创建JSONP接口的注意事项</h5><p>如果项目中已经配置了 CORS 跨域资源共享，为了<strong>防止冲突</strong>，必须在配置 CORS 中间件之前声明 JSONP 的接口。否则 JSONP 接口会被处理成开启了 CORS 的接口。示例代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//优先创建JSONP接口【这个接口不会被处理成cors接口】</span></span><br><span class="line">app.get(<span class="string">&#x27;/api/jsonp&#x27;</span>, <span class="function">(<span class="params">req,res</span>) =&gt;</span> &#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//再配置CORS中间件【后续的所有接口，都会被处理成CORS接口】</span></span><br><span class="line">app.use(cors())</span><br><span class="line"></span><br><span class="line"><span class="comment">//这是一个开启了CORS的接口</span></span><br><span class="line">app.get(<span class="string">&#x27;/api/get&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;&#125;)</span><br></pre></td></tr></table></figure>

<h5 id="4-6-2-实现JSONP接口的步骤"><a href="#4-6-2-实现JSONP接口的步骤" class="headerlink" title="4.6.2 实现JSONP接口的步骤"></a>4.6.2 实现JSONP接口的步骤</h5><ol>
<li><p>获取客户端发送过来的回调函数的名字</p>
</li>
<li><p>得到要通过 JSONP 形式发送给客户端的数据</p>
</li>
<li><p>根据前两步得到的数据，拼接出一个函数调用的字符串</p>
</li>
<li><p>把上一步拼接得到的字符串，响应给客户端的 <code>&lt;script&gt;</code> 标签进行解析执行</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="string">&#x27;/api/jsonp&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//获取客户端发送过来的回调函数的名字</span></span><br><span class="line">    <span class="keyword">const</span> funcName = req.query.callback</span><br><span class="line">    <span class="comment">//得到要通过JSONP形式发送的客户端的数据</span></span><br><span class="line">    <span class="keyword">const</span> data = &#123; <span class="attr">name</span>: <span class="string">&#x27;zs&#x27;</span>, <span class="attr">age</span>: <span class="number">22</span>&#125;</span><br><span class="line">    <span class="comment">//根据前两步得到的数据，拼接出一个函数调用的字符串</span></span><br><span class="line">    <span class="keyword">const</span> scriptStr = <span class="string">`<span class="subst">$&#123;funcName&#125;</span>(<span class="subst">$&#123;<span class="built_in">JSON</span>.stringfy(data)&#125;</span>)`</span></span><br><span class="line">    <span class="comment">//把上一步拼接得到的字符串，响应给客户端的&lt;Script&gt;标签进行解析执行</span></span><br><span class="line">    res.send(scriptStr)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h5 id="4-6-3-使用jQuery发起jsonp请求"><a href="#4-6-3-使用jQuery发起jsonp请求" class="headerlink" title="4.6.3 使用jQuery发起jsonp请求"></a>4.6.3 使用jQuery发起jsonp请求</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&quot;#btnJSONP&quot;</span>).on(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">        method: <span class="string">&#x27;GET&#x27;</span>,</span><br><span class="line">        url: <span class="string">&#x27;http://127.0.0.1/api/jsonp&#x27;</span>,</span><br><span class="line">        dataType: <span class="string">&#x27;jsonp&#x27;</span>,</span><br><span class="line">        success: <span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(res)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="04、Mysql模块"><a href="#04、Mysql模块" class="headerlink" title="04、Mysql模块"></a>04、Mysql模块</h2><h3 id="5-1-安装与配置"><a href="#5-1-安装与配置" class="headerlink" title="5.1 安装与配置"></a>5.1 安装与配置</h3><p><strong>安装</strong></p>
<p>mysql 模块是托管于 npm 上的第三方模块。它提供了在 Node.js 项目中连接和操作 MySQL 数据库的能力。</p>
<p>想要在项目中使用它，需要先运行如下命令，将 mysql 安装为项目的依赖包：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install mysql</span><br></pre></td></tr></table></figure>

<p><strong>配置</strong></p>
<p>在使用 mysql 模块操作 MySQL 数据库之前，必须先对 mysql 模块进行必要的配置，主要的配置步骤如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mysql = <span class="built_in">require</span>(<span class="string">&#x27;mysql&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> db = mysql.createPool(&#123;</span><br><span class="line">    host: <span class="string">&#x27;127.0.0.1&#x27;</span>,</span><br><span class="line">    user: <span class="string">&#x27;root&#x27;</span>,</span><br><span class="line">    password: <span class="string">&#x27;123456&#x27;</span>,</span><br><span class="line">    database: <span class="string">&#x27;my_db&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>测试</strong></p>
<p>调用 db.query() 函数，指定要执行的 SQL 语句，通过回调函数拿到执行的结果：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">db.query(<span class="string">&#x27;SELECT 1&#x27;</span>, <span class="function">(<span class="params">err, results</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(err) <span class="keyword">return</span> <span class="built_in">console</span>.log(err.message)</span><br><span class="line">    <span class="comment">//只要能打印出 【RowDataPacket &#123;&#x27;1&#x27;: 1&#125;】的结果，就证明连接正常</span></span><br><span class="line">    <span class="built_in">console</span>.log(results)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="5-2-操作Mysql"><a href="#5-2-操作Mysql" class="headerlink" title="5.2 操作Mysql"></a>5.2 操作Mysql</h3><h4 id="5-2-1-查询数据"><a href="#5-2-1-查询数据" class="headerlink" title="5.2.1 查询数据"></a>5.2.1 查询数据</h4><img src="/2021/05/06/Node%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/node029.png" class="">

<h4 id="5-2-2-插入数据"><a href="#5-2-2-插入数据" class="headerlink" title="5.2.2 插入数据"></a>5.2.2 插入数据</h4><img src="/2021/05/06/Node%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/node030.png" class="">

<p><strong>插入数据快捷方式</strong></p>
<p>向表中新增数据时，如果数据对象的每个属性和数据表的字段<strong>一一对应</strong>，则可以通过如下方式快速插入数据：</p>
<img src="/2021/05/06/Node%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/node031.png" class="">

<h2 id="05、前后端的身份认证"><a href="#05、前后端的身份认证" class="headerlink" title="05、前后端的身份认证"></a>05、前后端的身份认证</h2><h3 id="1-web开发模式"><a href="#1-web开发模式" class="headerlink" title="1 web开发模式"></a>1 web开发模式</h3><p>目前主流的 Web 开发模式有两种，分别是：</p>
<ul>
<li>基于服务端渲染的传统 Web 开发模式</li>
<li>基于前后端分离的新型 Web 开发模式</li>
</ul>
<h4 id="1-1-服务端渲染Web开发模式"><a href="#1-1-服务端渲染Web开发模式" class="headerlink" title="1.1 服务端渲染Web开发模式"></a>1.1 服务端渲染Web开发模式</h4><p>服务端渲染的概念：服务器发送给客户端的 HTML 页面，是在服务器通过字符串的拼接，动态生成的。因此，客户端不需要使用 Ajax 这样的技术额外请求页面的数据。代码示例如下：</p>
<img src="/2021/05/06/Node%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/node032.png" class="">

<p><strong>优缺点</strong></p>
<p>优点：</p>
<ul>
<li>前端耗时少。因为服务器端负责动态生成 HTML 内容，浏览器只需要直接渲染页面即可。尤其是移动端，更省电。</li>
<li>有利于SEO。因为服务器端响应的是完整的 HTML 页面内容，所以爬虫更容易爬取获得信息，更有利于SEO。</li>
</ul>
<p>缺点：</p>
<ul>
<li><strong>占用服务器端资源。</strong>即服务器端完成 HTML 页面内容的拼接，如果请求较多，会对服务器造成一定的访问压力。</li>
<li><strong>不利于前后端分离，开发效率低。</strong>使用服务器端渲染，则<strong>无法进行分工合作</strong>，尤其对于<strong>前端复杂度高</strong>的项目，不利于项目高效开发。</li>
</ul>
<h4 id="1-2-前后端分离的开发模式"><a href="#1-2-前后端分离的开发模式" class="headerlink" title="1.2 前后端分离的开发模式"></a>1.2 前后端分离的开发模式</h4><p>前后端分离的概念：前后端分离的开发模式，<strong>依赖于</strong> <strong>Ajax</strong> <strong>技术的广泛应用</strong>。简而言之，前后端分离的 Web 开发模式，就是<strong>后端只负责提供</strong> <strong>API</strong> <strong>接口，前端使用</strong> <strong>Ajax</strong> <strong>调用接口</strong>的开发模式。</p>
<p><strong>优缺点</strong></p>
<p>优点：</p>
<ul>
<li><p><strong>开发体验好。</strong>前端专注于 UI 页面的开发，后端专注于api 的开发，且前端有更多的选择性。</p>
</li>
<li><p><strong>用户体验好。</strong>Ajax 技术的广泛应用，极大的提高了用户的体验，可以轻松实现页面的局部刷新。</p>
</li>
<li><p><strong>减轻了服务器端的渲染压力。</strong>因为页面最终是在每个用户的浏览器中生成的。</p>
</li>
</ul>
<p>缺点：</p>
<ul>
<li><strong>不利于SEO</strong>。因为完整的 HTML 页面需要在客户端动态拼接完成，所以爬虫对无法爬取页面的有效信息。（解决方案：利用 Vue、React 等前端框架的 <strong>SSR</strong> （server side render）技术能够很好的解决 SEO 问题！）</li>
</ul>
<h4 id="1-3-如何选择web开发模式"><a href="#1-3-如何选择web开发模式" class="headerlink" title="1.3 如何选择web开发模式"></a>1.3 如何选择web开发模式</h4><p><strong>不谈业务场景而盲目选择使用何种开发模式都是耍流氓。</strong></p>
<ul>
<li><p>比如企业级网站，主要功能是展示而没有复杂的交互，并且需要良好的 SEO，则这时我们就需要使用服务器端渲染；</p>
</li>
<li><p>而类似后台管理项目，交互性比较强，不需要考虑 SEO，那么就可以使用前后端分离的开发模式。</p>
</li>
</ul>
<p>另外，具体使用何种开发模式并不是绝对的，为了<strong>同时兼顾</strong>了<strong>首页的渲染速度</strong>和<strong>前后端分离的开发效率</strong>，一些网站采用了首屏服务器端渲染 + 其他页面前后端分离的开发模式。</p>
<h3 id="2-身份认证"><a href="#2-身份认证" class="headerlink" title="2 身份认证"></a>2 身份认证</h3><p><strong>身份认证</strong>（Authentication）又称“身份验证”、“鉴权”，是指<strong>通过一定的手段，完成对用户身份的确认</strong>。</p>
<ul>
<li>日常生活中的身份认证随处可见，例如：高铁的验票乘车，手机的密码或指纹解锁，支付宝或微信的支付密码等。</li>
<li>在 Web 开发中，也涉及到用户身份的认证，例如：各大网站的<strong>手机验证码登录</strong>、<strong>邮箱密码登录</strong>、<strong>二维码登录</strong>等。</li>
</ul>
<p><strong>不同开发模式下的身份认证</strong></p>
<p>对于服务端渲染和前后端分离这两种开发模式来说，分别有着不同的身份认证方案：</p>
<ul>
<li><p>服务端渲染推荐使用 <strong>Session</strong> <strong>认证机制</strong></p>
</li>
<li><p>前后端分离推荐使用 <strong>JWT</strong> <strong>认证机制</strong></p>
</li>
</ul>
<h4 id="2-1-session认证机制"><a href="#2-1-session认证机制" class="headerlink" title="2.1 session认证机制"></a>2.1 session认证机制</h4><p><strong>http协议的无状态性</strong></p>
<p>了解 HTTP 协议的无状态性是进一步学习 Session 认证机制的必要前提。HTTP 协议的无状态性，指的是客户端的每次HTTP请求都是独立的，连续多个请求之间没有直接的关系，服务器不会主动保留每次HTTP请求的状态。</p>
<p><strong>突破http无状态的限制</strong></p>
<p>使用Cookie</p>
<p><strong>什么是Cookie</strong></p>
<p>Cookie 是存储在用户浏览器中的一段不超过4 KB的字符串。它由一个名称（Name）、一个值（Value）和其它几个用于控制 Cookie 有效期、安全性、使用范围的可选属性组成。</p>
<p>不同域名下的 Cookie 各自独立，每当客户端发起请求时，会自动把当前域名下所有未过期的Cookie 一同发送到服务器。</p>
<p>Cookie的几大特性：</p>
<ul>
<li>自动发送</li>
<li>域名独立</li>
<li>过期时限</li>
<li>4KB 限制</li>
</ul>
<p><strong>Cookie在身份认证中的作用</strong></p>
<p>客户端第一次请求服务器的时候，服务器<strong>通过响应头的形式</strong>，向客户端发送一个身份认证的 Cookie，客户端会自动将 Cookie 保存在浏览器中。随后，当客户端浏览器每次请求服务器的时候，浏览器会<strong>自动</strong>将身份认证相关的 Cookie，<strong>通过请求头的形式</strong>发送给服务器，服务器即可验明客户端的身份。</p>
<img src="/2021/05/06/Node%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/node033.png" class="">

<p><strong>Cookie不具有安全性</strong></p>
<p>由于 Cookie 是存储在浏览器中的，而且<strong>浏览器也提供了读写</strong> <strong>Cookie</strong> <strong>的</strong> <strong>API</strong>，因此 <strong>Cookie</strong> <strong>很容易被伪造</strong>，不具有安全性。因此不建议服务器将重要的隐私数据，通过 Cookie 的形式发送给浏览器。</p>
<p><strong>Session的工作原理</strong></p>
<img src="/2021/05/06/Node%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/node034.png" class="">

<p><strong>在Express中使用Session认证</strong></p>
<ol>
<li><p>安装express-session中间件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install express-session</span><br></pre></td></tr></table></figure></li>
<li><p>配置</p>
<p>express-session 中间件安装成功后，需要通过 app.use() 来注册 session 中间件，示例代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> session = <span class="built_in">require</span>(<span class="string">&#x27;express-session&#x27;</span>)</span><br><span class="line"></span><br><span class="line">app.use(session(&#123;</span><br><span class="line">    secret: <span class="string">&#x27;keyboard cat&#x27;</span>,</span><br><span class="line">    resave: <span class="literal">false</span>,</span><br><span class="line">    saveUninitialized: <span class="literal">true</span></span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure></li>
<li><p>存数据</p>
<p>当 express-session 中间件配置成功后，即可通过 <strong>req.session</strong> 来访问和使用 session 对象，从而存储用户的关键信息：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">app.post(<span class="string">&#x27;/api/login&#x27;</span>, <span class="function">(<span class="params">req,res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(req.body.username !== <span class="string">&#x27;admin&#x27;</span> || req.body.password !== <span class="string">&#x27;00000&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> res.send(&#123;<span class="attr">status</span>: <span class="number">1</span>, <span class="attr">msg</span>: <span class="string">&#x27;登录失败&#x27;</span>&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    req.session.user = req.body</span><br><span class="line">	req.session.islogin = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">	res.send(&#123;<span class="attr">status</span>: <span class="number">0</span>, <span class="attr">msg</span>: <span class="string">&#x27;登录成功&#x27;</span>&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>取数据</p>
<p>可以直接从 <strong>req.session</strong> 对象上获取之前存储的数据，示例代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="string">&#x27;api/username&#x27;</span>, <span class="function">(<span class="params">req,res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>( !req.session.islogin) &#123;</span><br><span class="line">        <span class="keyword">return</span> res.send(&#123;<span class="attr">status</span>: <span class="number">1</span>, <span class="attr">msg</span>: <span class="string">&#x27;fail&#x27;</span>&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    res.send(&#123;<span class="attr">status</span>: <span class="number">0</span>, <span class="attr">msg</span>: <span class="string">&#x27;success&#x27;</span>, <span class="attr">username</span>: req.session.user.username&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>清空session</p>
<p>调用 <strong>req.session.destroy()</strong> 函数，即可清空服务器保存的 session 信息。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">app.post(<span class="string">&#x27;/api/logout&#x27;</span>, <span class="function">(<span class="params">req,res</span>) =&gt;</span> &#123;</span><br><span class="line">    req.session.destroy()</span><br><span class="line">    res.send(&#123;</span><br><span class="line">        status: <span class="number">0</span>,</span><br><span class="line">        msg: <span class="string">&#x27;退出登录成功&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ol>
<p>Session 认证机制需要配合 Cookie 才能实现。由于 Cookie 默认不支持跨域访问，所以，当涉及到前端跨域请求后端接口的时候，<strong>需要做很多额外的配置</strong>，才能实现跨域 Session 认证。</p>
<p>注意：</p>
<ul>
<li><p>当前端请求后端接口<strong>不存在跨域问题</strong>的时候，<strong>推荐使用</strong> <strong>Session</strong> 身份认证机制。</p>
</li>
<li><p>当前端需要跨域请求后端接口的时候，不推荐使用 Session 身份认证机制，推荐使用 JWT 认证机制。</p>
</li>
</ul>
<h4 id="2-2-JWT认证机制"><a href="#2-2-JWT认证机制" class="headerlink" title="2.2 JWT认证机制"></a>2.2 JWT认证机制</h4><p>JWT（英文全称：JSON Web Token）是目前<strong>最流行</strong>的<strong>跨域认证解决方案</strong>。</p>
<p><strong>工作原理</strong></p>
<img src="/2021/05/06/Node%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/node035.png" class="">

<p>用户的信息通过 Token 字符串的形式，保存在客户端浏览器中。服务器通过还原 Token 字符串的形式来认证用户的身份。</p>
<p><strong>组成部分</strong></p>
<p>JWT 通常由三部分组成，分别是 Header（头部）、Payload（有效荷载）、Signature（签名）。三者之间使用英文的<code>.</code>分隔，格式如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Header.Payload.Signature</span><br></pre></td></tr></table></figure>

<p>JWT 的三个组成部分，从前到后分别是 Header、Payload、Signature。其中：</p>
<ul>
<li><p><strong>Payload</strong> 部分<strong>才是真正的用户信息</strong>，它是用户信息经过加密之后生成的字符串。</p>
</li>
<li><p>Header 和 Signature 是<strong>安全性相关</strong>的部分，只是为了保证 Token 的安全性。</p>
</li>
</ul>
<img src="/2021/05/06/Node%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/node036.png" class="">

<p><strong>使用方式</strong></p>
<p>客户端收到服务器返回的 JWT 之后，通常会将它储存在 localStorage 或 sessionStorage 中。此后，客户端每次与服务器通信，都要带上这个 JWT 的字符串，从而进行身份认证。推荐的做法是<strong>把</strong> <strong>JWT</strong> <strong>放在</strong> <strong>HTTP</strong> <strong>请求头的</strong> <strong>Authorization</strong> <strong>字段中</strong>，格式如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Authorization: Bearer &lt;token&gt;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>安装</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install jsonwebtoken express-jwt</span><br></pre></td></tr></table></figure>

<p><strong>jsonwebtoken</strong> 用于<strong>生成</strong> <strong>JWT</strong> <strong>字符串</strong></p>
<p><strong>express-jwt</strong> 用于<strong>将</strong> <strong>JWT</strong> <strong>字符串解析还原成</strong> <strong>JSON</strong> <strong>对象</strong></p>
</li>
<li><p>导入</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> jwt = <span class="built_in">require</span>(<span class="string">&#x27;jsonwebtoken&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> expressJMT = <span class="built_in">require</span>(<span class="string">&#x27;express-jwt&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
<li><p>定义secret秘钥</p>
<p>为了保证 JWT 字符串的安全性，防止 JWT 字符串在网络传输过程中被别人破解，我们需要专门定义一个用于<strong>加密</strong>和<strong>解密</strong>的 secret 密钥：</p>
<ol>
<li><p>当生成 JWT 字符串的时候，需要使用 secret 密钥对用户的信息进行加密，最终得到加密好的 JWT 字符串</p>
</li>
<li><p>当把 JWT 字符串解析还原成 JSON 对象的时候，需要使用 secret 密钥进行解密</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> secretKey = <span class="string">&#x27;sldfjasldkfjlaskdjfjl&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li><p>登录成功后生成JWT字符串</p>
<p>调用 <strong>jsonwebtoken</strong> 包提供的 <strong>sign()</strong> 方法，将用户的信息加密成 JWT 字符串，响应给客户端：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">app.post(<span class="string">&#x27;/api/login&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    res.send(&#123;</span><br><span class="line">        status: <span class="number">200</span>,</span><br><span class="line">        message: <span class="string">&#x27;登录成功&#x27;</span>,</span><br><span class="line">        token: jwt.sign(&#123;<span class="attr">username</span>: userinfo.username&#125;, secretKey, &#123;<span class="attr">expiresIn</span>: <span class="string">&#x27;30s&#x27;</span>&#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>将JWT字符串还原为JSON对象</p>
<p>客户端每次在访问那些有权限接口的时候，都需要主动通过<strong>请求头中的</strong> <strong>Authorization</strong> <strong>字段</strong>，将 Token 字符串发送到服务器进行身份认证。此时，服务器可以通过 <strong>express-jwt</strong> 这个中间件，自动将客户端发送过来的 Token 解析还原成 JSON 对象：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.use(expressJWT(&#123; <span class="attr">secret</span>: secretKey&#125;)).unless(&#123; <span class="attr">path</span>: [<span class="regexp">/^\api\//</span>]&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>使用<code>req.user</code>获取用户信息</p>
<p>当 express-jwt 这个中间件配置成功之后，即可在那些有权限的接口中，使用 <strong>req.user</strong> 对象，来访问从 JWT 字符串中解析出来的用户信息了，示例代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="string">&#x27;/admin/getinfo&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>)</span>&#123;</span><br><span class="line">    res.send(&#123;</span><br><span class="line">        status: <span class="number">200</span>,</span><br><span class="line">        message: <span class="string">&#x27;获取用户信息成功！&#x27;</span>,</span><br><span class="line">        data: req.user</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>捕获解析JWT失败后产生的错误</p>
<p>当使用 express-jwt 解析 Token 字符串时，如果客户端发送过来的 Token 字符串<strong>过期</strong>或<strong>不合法</strong>，会产生一个<strong>解析失败</strong>的错误，影响项目的正常运行。我们可以通过 <strong>Express</strong> <strong>的错误中间件</strong>，捕获这个错误并进行相关的处理，示例代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">app.use(<span class="function">(<span class="params">err,req,res,next</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// token解析失败导致的错误</span></span><br><span class="line">    <span class="keyword">if</span>(err.name == <span class="string">&#x27;UnauthorizedError&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> res.send(&#123;<span class="attr">status</span>: <span class="number">401</span>, <span class="attr">message</span>: <span class="string">&#x27;无效的token&#x27;</span>&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//其它原因导致的错误</span></span><br><span class="line">    res.send(&#123;<span class="attr">status</span>: <span class="number">500</span>, <span class="attr">message</span>: <span class="string">&#x27;未知错误&#x27;</span>&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ol>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/node/" rel="tag"># node</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/04/29/http%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="prev" title="http学习笔记">
                  <i class="fa fa-chevron-left"></i> http学习笔记
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2021/05/14/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/" rel="next" title="linux常用命令总结">
                  linux常用命令总结 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>





<script src="/js/comments.js"></script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">浙ICP备18041583号-1 </a>
      <img src="/images/beian.png">
  </div>

<div class="copyright">
  &copy; 2018 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Mr.wj</span>
</div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
