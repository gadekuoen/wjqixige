<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css">

<script class="next-config" data-name="main" type="application/json">{&quot;hostname&quot;:&quot;www.wjqixige.cn&quot;,&quot;root&quot;:&quot;&#x2F;&quot;,&quot;images&quot;:&quot;&#x2F;images&quot;,&quot;scheme&quot;:&quot;Gemini&quot;,&quot;version&quot;:&quot;8.3.0&quot;,&quot;exturl&quot;:false,&quot;sidebar&quot;:{&quot;position&quot;:&quot;left&quot;,&quot;display&quot;:&quot;post&quot;,&quot;padding&quot;:18,&quot;offset&quot;:12},&quot;copycode&quot;:false,&quot;bookmark&quot;:{&quot;enable&quot;:false,&quot;color&quot;:&quot;#222&quot;,&quot;save&quot;:&quot;auto&quot;},&quot;fancybox&quot;:false,&quot;mediumzoom&quot;:false,&quot;lazyload&quot;:false,&quot;pangu&quot;:false,&quot;comments&quot;:{&quot;style&quot;:&quot;tabs&quot;,&quot;active&quot;:null,&quot;storage&quot;:true,&quot;lazyload&quot;:false,&quot;nav&quot;:null},&quot;motion&quot;:{&quot;enable&quot;:false,&quot;async&quot;:false,&quot;transition&quot;:{&quot;post_block&quot;:&quot;fadeIn&quot;,&quot;post_header&quot;:&quot;fadeInDown&quot;,&quot;post_body&quot;:&quot;fadeInDown&quot;,&quot;coll_header&quot;:&quot;fadeInLeft&quot;,&quot;sidebar&quot;:&quot;fadeInUp&quot;}},&quot;prism&quot;:false,&quot;i18n&quot;:{&quot;placeholder&quot;:&quot;搜索...&quot;,&quot;empty&quot;:&quot;没有找到任何搜索结果：${query}&quot;,&quot;hits_time&quot;:&quot;找到 ${hits} 个搜索结果（用时 ${time} 毫秒）&quot;,&quot;hits&quot;:&quot;找到 ${hits} 个搜索结果&quot;}}</script>
<meta name="description" content="Hive是基于Hadoop的一个数据仓库工具，可以将结构化的数据文件映射为一张数据库表，并提供类SQL查询功能。其本质是将SQL转换为MapReduce的任务进行运算，底层由HDFS来提供数据的存储；通俗来讲，hive就是将SQL转换为MapReduce的任务的工具，或者可以说hive就是一个MapReduce的客户端。 尽管hive具有sql数据库的外表，但它不是一个完整的数据库，首先hive不">
<meta property="og:type" content="article">
<meta property="og:title" content="Hive学习笔记">
<meta property="og:url" content="http://www.wjqixige.cn/2021/05/19/Hive%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="栖溪阁晓生">
<meta property="og:description" content="Hive是基于Hadoop的一个数据仓库工具，可以将结构化的数据文件映射为一张数据库表，并提供类SQL查询功能。其本质是将SQL转换为MapReduce的任务进行运算，底层由HDFS来提供数据的存储；通俗来讲，hive就是将SQL转换为MapReduce的任务的工具，或者可以说hive就是一个MapReduce的客户端。 尽管hive具有sql数据库的外表，但它不是一个完整的数据库，首先hive不">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://www.wjqixige.cn/2021/05/19/Hive%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/wj-hive-20191006003.png">
<meta property="og:image" content="http://www.wjqixige.cn/2021/05/19/Hive%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/wj-hive-20191006006.png">
<meta property="og:image" content="http://www.wjqixige.cn/2021/05/19/Hive%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/wj-hive-20191006007.png">
<meta property="og:image" content="http://www.wjqixige.cn/2021/05/19/Hive%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/wj-hive-20191006008.png">
<meta property="article:published_time" content="2021-05-19T06:02:35.000Z">
<meta property="article:modified_time" content="2021-05-22T09:01:45.410Z">
<meta property="article:author" content="Mr.wj">
<meta property="article:tag" content="Hive">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://www.wjqixige.cn/2021/05/19/Hive%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/wj-hive-20191006003.png">


<link rel="canonical" href="http://www.wjqixige.cn/2021/05/19/Hive%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">



<script class="next-config" data-name="page" type="application/json">{&quot;sidebar&quot;:&quot;&quot;,&quot;isHome&quot;:false,&quot;isPost&quot;:true,&quot;lang&quot;:&quot;zh-CN&quot;,&quot;comments&quot;:true,&quot;permalink&quot;:&quot;http:&#x2F;&#x2F;www.wjqixige.cn&#x2F;2021&#x2F;05&#x2F;19&#x2F;Hive%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0&#x2F;&quot;,&quot;path&quot;:&quot;2021&#x2F;05&#x2F;19&#x2F;Hive学习笔记&#x2F;&quot;,&quot;title&quot;:&quot;Hive学习笔记&quot;}</script>

<script class="next-config" data-name="calendar" type="application/json">&quot;&quot;</script>
<title>Hive学习笔记 | 栖溪阁晓生</title><script src="/js/config.js"></script>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">栖溪阁晓生</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">个人在线笔记本</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E6%95%B0%E6%8D%AE%E5%AE%9A%E4%B9%89"><span class="nav-text">一、数据定义</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C"><span class="nav-text">1 数据库操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%E6%93%8D%E4%BD%9C"><span class="nav-text">2 数据库表操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-%E5%88%9B%E5%BB%BA%E8%A1%A8"><span class="nav-text">2.1 创建表</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#2-1-1-%E5%86%85%E9%83%A8%E8%A1%A8"><span class="nav-text">2.1.1 内部表</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-1-2-%E5%A4%96%E9%83%A8%E8%A1%A8"><span class="nav-text">2.1.2 外部表</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-%E5%88%86%E5%8C%BA%E8%A1%A8"><span class="nav-text">2.2 分区表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-%E5%88%86%E6%A1%B6%E8%A1%A8"><span class="nav-text">2.3 分桶表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-%E4%BF%AE%E6%94%B9%E8%A1%A8"><span class="nav-text">2.4 修改表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-5-%E5%88%A0%E9%99%A4%E8%A1%A8"><span class="nav-text">2.5 删除表</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C"><span class="nav-text">二、数据操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E8%A3%85%E8%BD%BD%E6%95%B0%E6%8D%AE"><span class="nav-text">1 装载数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE"><span class="nav-text">2 插入数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%8A%A0%E8%BD%BD%E6%95%B0%E6%8D%AE"><span class="nav-text">3 加载数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E5%AF%BC%E5%87%BA%E6%95%B0%E6%8D%AE"><span class="nav-text">4 导出数据</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E6%9F%A5%E8%AF%A2"><span class="nav-text">三、查询</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-SELECT%E2%80%A6FROM%E8%AF%AD%E5%8F%A5"><span class="nav-text">1 SELECT…FROM语句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-WHERE%E8%AF%AD%E5%8F%A5"><span class="nav-text">2 WHERE语句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-GROUP-BY%E8%AF%AD%E5%8F%A5"><span class="nav-text">3 GROUP BY语句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-JOIN%E8%AF%AD%E5%8F%A5"><span class="nav-text">4 JOIN语句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-ORDER-BY-%E5%92%8C-SORT-BY"><span class="nav-text">5 ORDER BY 和 SORT BY</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-DISTRIBUTE-BY"><span class="nav-text">6 DISTRIBUTE BY</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-CLUSTER-BY"><span class="nav-text">7 CLUSTER BY</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-UNION-ALL"><span class="nav-text">8 UNION ALL</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E8%B0%83%E4%BC%98"><span class="nav-text">三、调优</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E4%BD%BF%E7%94%A8Explain"><span class="nav-text">1 使用Explain</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-Fetch%E6%8A%93%E5%8F%96"><span class="nav-text">2 Fetch抓取</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E9%99%90%E5%88%B6%E8%B0%83%E6%95%B4"><span class="nav-text">3 限制调整</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-Join%E4%BC%98%E5%8C%96"><span class="nav-text">4 Join优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E6%9C%AC%E5%9C%B0%E6%A8%A1%E5%BC%8F"><span class="nav-text">5 本地模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E5%B9%B6%E8%A1%8C%E6%89%A7%E8%A1%8C"><span class="nav-text">6 并行执行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F"><span class="nav-text">7 严格模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-GROUP-BY"><span class="nav-text">8 GROUP BY</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-JVM%E9%87%8D%E7%94%A8"><span class="nav-text">9 JVM重用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-%E7%B4%A2%E5%BC%95"><span class="nav-text">10 索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E8%B0%83%E6%95%B4"><span class="nav-text">11 动态分区调整</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-%E6%8E%A8%E6%B5%8B%E6%89%A7%E8%A1%8C"><span class="nav-text">12 推测执行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-Count-distinct"><span class="nav-text">13 Count(distinct)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-%E7%AC%9B%E5%8D%A1%E5%B0%94%E7%A7%AF"><span class="nav-text">14 笛卡尔积</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9B%E3%80%81%E6%95%B0%E6%8D%AE%E5%8E%8B%E7%BC%A9"><span class="nav-text">四、数据压缩</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%BC%80%E5%90%AFMap%E8%BE%93%E5%87%BA%E9%98%B6%E6%AE%B5%E5%8E%8B%E7%BC%A9"><span class="nav-text">1 开启Map输出阶段压缩</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%BC%80%E5%90%AFReduce%E8%BE%93%E5%87%BA%E9%98%B6%E6%AE%B5%E5%8E%8B%E7%BC%A9"><span class="nav-text">2 开启Reduce输出阶段压缩</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%94%E3%80%81%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E6%A0%BC%E5%BC%8F"><span class="nav-text">五、数据存储格式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%88%97%E5%BC%8F%E5%AD%98%E5%82%A8%E5%92%8C%E8%A1%8C%E5%BC%8F%E5%AD%98%E5%82%A8"><span class="nav-text">1 列式存储和行式存储</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E6%A0%BC%E5%BC%8F"><span class="nav-text">2 常用数据存储格式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%AD%E3%80%81%E5%87%BD%E6%95%B0"><span class="nav-text">六、函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0"><span class="nav-text">1 内置函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0"><span class="nav-text">2 自定义函数</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <a href="/"><img class="site-author-image" itemprop="image" alt="Mr.wj" src="/uploads/logo.jpg"></a>
  <p class="site-author-name" itemprop="name">Mr.wj</p>
  <div class="site-description" itemprop="description">欢迎来到栖息阁晓生博客</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">54</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">37</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/gadekuoen/wjqixige" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;gadekuoen&#x2F;wjqixige" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/wujiang569@126.com" title="E-Mail → wujiang569@126.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://me.csdn.net/weixin_39455881" title="CSDN → https:&#x2F;&#x2F;me.csdn.net&#x2F;weixin_39455881" rel="noopener" target="_blank"><i class="crosshairs fa-fw"></i>CSDN</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/2983932047/profile?rightmod=1&wvr=6&mod=personinfo&is_all=1" title="微博 → https:&#x2F;&#x2F;weibo.com&#x2F;2983932047&#x2F;profile?rightmod&#x3D;1&amp;wvr&#x3D;6&amp;mod&#x3D;personinfo&amp;is_all&#x3D;1" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>微博</a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.wjqixige.cn/2021/05/19/Hive%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/logo.jpg">
      <meta itemprop="name" content="Mr.wj">
      <meta itemprop="description" content="欢迎来到栖息阁晓生博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="栖溪阁晓生">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Hive学习笔记
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-05-19 14:02:35" itemprop="dateCreated datePublished" datetime="2021-05-19T14:02:35+08:00">2021-05-19</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-05-22 17:01:45" itemprop="dateModified" datetime="2021-05-22T17:01:45+08:00">2021-05-22</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/" itemprop="url" rel="index"><span itemprop="name">大数据</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>Hive是基于Hadoop的一个数据仓库工具，可以将结构化的数据文件映射为一张数据库表，并提供类SQL查询功能。其本质是将SQL转换为MapReduce的任务进行运算，底层由HDFS来提供数据的存储；通俗来讲，hive就是将SQL转换为MapReduce的任务的工具，或者可以说hive就是一个MapReduce的客户端。</p>
<p>尽管hive具有sql数据库的外表，但它不是一个完整的数据库，首先hive不支持记录级别的更新、插入或者删除操作，而且查询延时也比较严重，还不支持事务。因此，hive最适合于数据仓库应用程序，使用该程序进行相关的静态数据分析，不需要快速响应给出结果，而且数据本身不会频繁变化。</p>
<span id="more"></span>

<p>hive大致由用户接口、元数据库和驱动模块三部分组成。用户接口提供了如CLI、webGUI，以及可通过JDBC/ODBC和Thrift服务器进行编程访问的几个模块；元数据库主要用来存储表的名字、表的列和分区及其属性，以及表的数据所在目录等，常用使用关系型数据库Mysql来作为源数据库。hive默认的元数据库为derby。机构图如下如所示：</p>
<img src="/2021/05/19/Hive%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/wj-hive-20191006003.png" class="">

<p>明白了什么是Hive之后，接下来要做的就是如何安装Hive。具体安装方法请参考官网、书籍或其它博文解决。安装好了hive之后，启动HIVE。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 配置了环境变量，则可以在任意目录下输入hive即可启动</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> /usr/<span class="built_in">local</span>/hive-2.1.1/bin/hive</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>提示：下文默认用户已经配置了环境变量，将不在使用绝对路径</p>
</blockquote>
<p>有时候只是执行一个或者多个查询(分号分隔)，执行完毕后就退出，则可以采用以下形式：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> hive -e <span class="string">&quot;SELECT * FROM mytable LIMIT 3&quot;</span>;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># -S：开启静默模式，去掉一些无关紧要的输出信息</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> hive -S -e <span class="string">&quot;SELECT * FROM mytable LIMIT 3&quot;</span>;</span></span><br></pre></td></tr></table></figure>

<p>如果使用sql脚本的方式执行，则采用以下形式：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> hive -f /&lt;path&gt;/xxx.sql</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>补充知识点：</p>
<ol>
<li>想要不退出hiveCLI就可以执行简单的bash shell命令，则在命令前面加上<code>!</code>并且以分号<code>;</code>结尾即可；</li>
</ol>
</blockquote>
<p>了解了hive的交互方式之后，紧接着就要学习hive的基本操作。首当其冲的就是HiveQL，它是Hive的查询语言，用法和MySQL很接近，但也存在显著的差异。</p>
<h2 id="一、数据定义"><a href="#一、数据定义" class="headerlink" title="一、数据定义"></a>一、数据定义</h2><h3 id="1-数据库操作"><a href="#1-数据库操作" class="headerlink" title="1 数据库操作"></a>1 数据库操作</h3><p><strong>创建数据库</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE [IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>] dbName;</span><br><span class="line">USE dbName;</span><br></pre></td></tr></table></figure>

<p>说明：hive的表存放位置模式是由hive-site.xml当中的一个属性指定的</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>hive.metastore.warehouse.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>/user/hive/warehouse<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>创建数据库并指定hdfs存储位置</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE dbName LOCATION <span class="string">&#x27;/my/preferred/directory&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>设置数据库键值对信息</strong></p>
<p>数据库可以有一些描述性的键值对信息，在创建时添加：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE dbName <span class="keyword">WITH</span> DBPROPERTIES(<span class="string">&#x27;owner&#x27;</span><span class="operator">=</span><span class="string">&#x27;wjqixige&#x27;</span>,<span class="string">&#x27;date&#x27;</span><span class="operator">=</span><span class="string">&#x27;20190120&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>查看数据库键值对信息</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DESC</span> DATABASE EXTENDED dbName;</span><br></pre></td></tr></table></figure>

<p><strong>修改数据库键值对信息</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> DATABASE dbName <span class="keyword">SET</span> DBPROPERTIES(<span class="string">&#x27;owner&#x27;</span><span class="operator">=</span><span class="string">&#x27;wjqixige&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>删除数据库</strong></p>
<p>删除一个空数据库，如果数据库下面有数据表，则会报错</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> DATABASE dbName;</span><br></pre></td></tr></table></figure>

<p>强制删除数据库，包含数据库下面的表一起删除</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP DATABASE dbName CASCADE;</span><br></pre></td></tr></table></figure>

<h3 id="2-数据库表操作"><a href="#2-数据库表操作" class="headerlink" title="2 数据库表操作"></a>2 数据库表操作</h3><h4 id="2-1-创建表"><a href="#2-1-创建表" class="headerlink" title="2.1 创建表"></a>2.1 创建表</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [<span class="keyword">EXTERNAL</span>] <span class="keyword">TABLE</span> [IF NOTE <span class="keyword">EXISTS</span>] table_name(</span><br><span class="line">    col_name data_type [COMMENT <span class="string">&#x27;字段描述信息&#x27;</span>]，</span><br><span class="line">    col_name data_type [COMMENT <span class="string">&#x27;字段描述信息&#x27;</span>]) [COMMENT <span class="string">&#x27;表描述信息&#x27;</span>] </span><br><span class="line">   [PARTITIONED <span class="keyword">BY</span> (col_name data_type [COMMENT <span class="string">&#x27;字段描述信息&#x27;</span>], ...)] </span><br><span class="line">   [CLUSTERED <span class="keyword">BY</span> (col_name, col_name, ...)]</span><br><span class="line">   [SORTED <span class="keyword">BY</span> (col_name [<span class="keyword">ASC</span><span class="operator">|</span><span class="keyword">DESC</span>], ...)] <span class="keyword">INTO</span> num_buckets buckets] </span><br><span class="line">   [<span class="type">ROW</span> FORMAT row_format] </span><br><span class="line">   [STORED <span class="keyword">AS</span> file_format] </span><br><span class="line">   [LOCATION <span class="string">&#x27;指定表的路径&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p>关键字说明，如下表：</p>
<table>
<thead>
<tr>
<th>关键字</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>CREATE TABLE</td>
<td>创建一个指定名字的表。名字存在，则抛出异常；可以用 IF NOT EXISTS 选项忽略异常</td>
</tr>
<tr>
<td>EXTERNAL</td>
<td>创建一个外部表，在建表的同时指定一个指向实际数据的路径（LOCATION），<br>Hive 创建内部表时，会将数据移动到数据仓库指向的路径；<br/>若创建外部表，仅记录数据所在的路径，不对数据的位置做任何改变。<br/>在删除表的时候，内部表的元数据和数据会被一起删除，而外部表只删除元数据，不删除数据。</td>
</tr>
<tr>
<td>COMMENT</td>
<td>注释，默认不能使用中文</td>
</tr>
<tr>
<td>PARTITIONED BY</td>
<td>表分区，一个表可以拥有一个或者多个分区，每一个分区单独存在一个目录下</td>
</tr>
<tr>
<td>CLUSTERED BY</td>
<td>对于每一个表分文件，Hive可以进一步组织成桶，是更为细粒度的数据范围划分</td>
</tr>
<tr>
<td>SORTED BY</td>
<td>指定排序字段和排序规则</td>
</tr>
<tr>
<td>ROW FORMAT</td>
<td>指定表文件字段分隔符</td>
</tr>
<tr>
<td>STORED AS</td>
<td>指定表文件的存储格式。<br/>常用格式：SEQUENCEFILE, TEXTFILE,RCFILE,如果文件数据是纯文本，可以使用SRORED AS TEXTFILE。<br/>如果数据需要压缩，使用storted as SEQUENCEFILE。</td>
</tr>
<tr>
<td>LOCATION</td>
<td>指定表文件的存储路径</td>
</tr>
</tbody></table>
<h5 id="2-1-1-内部表"><a href="#2-1-1-内部表" class="headerlink" title="2.1.1 内部表"></a>2.1.1 内部表</h5><p>创建表时，如果没有使用external关键字，则该表是内部表。</p>
<p><strong>复制表结构和表内容创建表</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE tb1 AS SELECT * FROM tb2;</span><br></pre></td></tr></table></figure>

<p><strong>复制表结构，不复制内容</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE tb1 LIKE tb2;</span><br></pre></td></tr></table></figure>

<p><strong>查询表详细信息</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DESC FORMATTED tb1;</span><br></pre></td></tr></table></figure>

<p><strong>删除表</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP TABLE tb2;</span><br></pre></td></tr></table></figure>

<h5 id="2-1-2-外部表"><a href="#2-1-2-外部表" class="headerlink" title="2.1.2 外部表"></a>2.1.2 外部表</h5><p>创建表时，如果使用external关键字，则该表是外部表。外部表因为是指定其他的hdfs路径的数据加载到表当中来，所以hive表会认为自己不完全独占这份数据，所以删除hive表的时候，数据仍然存放在hdfs当中，不会删掉。</p>
<h4 id="2-2-分区表"><a href="#2-2-分区表" class="headerlink" title="2.2 分区表"></a>2.2 分区表</h4><p>在大数据中，最常用的一种思想就是分治，我们可以把大的文件切割划分成一个个的小文件，这样每次操作一个小的文件就很容易了，同样的道理，在hive中也是支持这种思想的，就是我么你可以把大的数据，按照每月，或者天进行切分成一个个的小的文件，这样去操作小的文件就很容易了。</p>
<p><strong>语法：</strong>在创建表的时候添加以下字段</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[PARTITIONED BY (col_name data_type [COMMENT &#39;字段描述信息&#39;], ...)] </span><br></pre></td></tr></table></figure>

<p><strong>查看分区</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW PARTITIONS tb_name;</span><br></pre></td></tr></table></figure>

<p><strong>添加表分区</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE tb_name ADD [IF NOT EXISTS] PARTITION(col_name data_type,...);</span><br></pre></td></tr></table></figure>

<p><strong>修改表分区</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 通过移动位置来修改分区的路径；旧路径和旧数据仍保留</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tb_name <span class="keyword">PARTITION</span>(col_name data_type,...) <span class="keyword">SET</span> LOCATION <span class="string">&#x27;&lt;new path&gt;&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>删除表分区</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE tb_name DROP [IF NOT EXISTS] PARTITION(col_name data_type,...);</span><br></pre></td></tr></table></figure>

<h4 id="2-3-分桶表"><a href="#2-3-分桶表" class="headerlink" title="2.3 分桶表"></a>2.3 分桶表</h4><p>分桶，就是将数据按照指定的字段进行划分到多个文件当中去，分桶就是MapReduce中的分区。</p>
<p><strong>开启分桶功能</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET hive.enforce.bucketing&#x3D;true;</span><br></pre></td></tr></table></figure>

<p><strong>设置reduce的个数</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET mapreduce.job.reduces&#x3D;1;</span><br></pre></td></tr></table></figure>

<p><strong>创建分桶表：</strong>在创建表的时候添加以下字段</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[CLUSTERED BY (col_name, col_name, ...)]</span><br></pre></td></tr></table></figure>

<p>桶表的数据加载，由于桶表的数据加载通过hdfs dfs -put文件或通过load data均不好使，只能通过<code>insert overwrite</code>的方式将普通表的数据通过查询的方式加载到桶表当中去。</p>
<h4 id="2-4-修改表"><a href="#2-4-修改表" class="headerlink" title="2.4 修改表"></a>2.4 修改表</h4><p><strong>重命名</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tb_name RENAME <span class="keyword">TO</span> new_tb_name;</span><br></pre></td></tr></table></figure>

<p><strong>修改列信息</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tb_name CHANGE <span class="keyword">COLUMN</span> old_col_name new_col_name new_data_type [AFTER<span class="operator">|</span><span class="keyword">FIRST</span> other_column];</span><br></pre></td></tr></table></figure>

<p><strong>增加列</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tb_name <span class="keyword">ADD</span> COLUMNS(col_name data_type,...)</span><br></pre></td></tr></table></figure>

<p><strong>删除或替换列</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 只能用于使用了两种内置SerDe模块的表：DynamicSerDe或者MetadataTypedColumnsetSerDe</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tb_name REPLACE COLUMNS(col_name data_type,...)</span><br></pre></td></tr></table></figure>

<p><strong>修改表属性</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 可以增加附加的表属性或修改已存在的属性，但是无法删除属性</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tb_name <span class="keyword">SET</span> TBLPROPERTIES(<span class="string">&#x27;notes&#x27;</span><span class="operator">=</span><span class="string">&#x27;wjqixige is my blog&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="2-5-删除表"><a href="#2-5-删除表" class="headerlink" title="2.5 删除表"></a>2.5 删除表</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP TABLE [IF EXISTS] tb_name;</span><br></pre></td></tr></table></figure>

<h2 id="二、数据操作"><a href="#二、数据操作" class="headerlink" title="二、数据操作"></a>二、数据操作</h2><h3 id="1-装载数据"><a href="#1-装载数据" class="headerlink" title="1 装载数据"></a>1 装载数据</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 1. 如果分区目录不存在，则会先创建分区目录，再将数据拷贝到该目录下;</span></span><br><span class="line"><span class="comment">-- 2. 如果是非分区表，则省略PARTITION子句;</span></span><br><span class="line"><span class="comment">-- 3. 使用LOCAL，路径为本地文件系统路径; 省略LOCAL，路径为分布式文件系统中路径</span></span><br><span class="line"><span class="comment">-- 4. 使用OVERWRITE,目标文件夹中存在的数据会被删除; 省略OVERWRITE,目标文件中存在的数据不会被删除，如果出现同名文件，那么旧的同名文件会被覆盖重写;</span></span><br><span class="line"><span class="comment">-- 5. INPATH子句中使用的文件路径下不可以包含任何文件夹</span></span><br><span class="line">LOAD DATA <span class="keyword">LOCAL</span> INPATH <span class="string">&#x27;&lt;directory&gt;&#x27;</span> OVERWRITE <span class="keyword">INTO</span> <span class="keyword">TABLE</span> tb_name [<span class="keyword">PARTITION</span>(col_name data_type,...)];</span><br></pre></td></tr></table></figure>

<h3 id="2-插入数据"><a href="#2-插入数据" class="headerlink" title="2 插入数据"></a>2 插入数据</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 在版本V0.8.0之后，如果没有使用OVERWRITE或者使用INRO替换掉它,则hive会以追加的方式写入数据</span></span><br><span class="line"><span class="keyword">INSERT</span> OVERWRITE <span class="keyword">TABLE</span> tb_name [<span class="keyword">PARTITION</span>(col_name1 <span class="operator">=</span> val1, ...)] <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tb_name2 tb2 [<span class="keyword">WHERE</span> tb2.col <span class="operator">=</span> val1 <span class="keyword">AND</span> ...];</span><br></pre></td></tr></table></figure>

<h3 id="3-加载数据"><a href="#3-加载数据" class="headerlink" title="3 加载数据"></a>3 加载数据</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 不能用于外部表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tb_name <span class="keyword">AS</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tb_name1;</span><br></pre></td></tr></table></figure>

<h3 id="4-导出数据"><a href="#4-导出数据" class="headerlink" title="4 导出数据"></a>4 导出数据</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> OVERWRITE <span class="keyword">LOCAL</span> DIRECTORY <span class="string">&#x27;&lt;directory&gt;&#x27;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tb_name;</span><br></pre></td></tr></table></figure>

<h2 id="三、查询"><a href="#三、查询" class="headerlink" title="三、查询"></a>三、查询</h2><h3 id="1-SELECT…FROM语句"><a href="#1-SELECT…FROM语句" class="headerlink" title="1 SELECT…FROM语句"></a>1 SELECT…FROM语句</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> [<span class="keyword">ALL</span><span class="operator">|</span><span class="keyword">DISTINCT</span>] select_expr,select_expr,... FORM table_reference </span><br><span class="line">[<span class="keyword">WHERE</span> where_condition]</span><br><span class="line">[<span class="keyword">GROUP</span> <span class="keyword">BY</span> col_list [HVAING <span class="keyword">condition</span>]]</span><br><span class="line">[ClUSTER <span class="keyword">BY</span> col_list <span class="operator">|</span> [DISTRIBUTE <span class="keyword">BY</span> col_list] [SORT <span class="keyword">BY</span> <span class="operator">|</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> col_list]]</span><br><span class="line">[LIMIT number]</span><br></pre></td></tr></table></figure>

<p><strong>采用正则表达式指定列</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> col_name1,`regex` <span class="keyword">FROM</span> tb_name;</span><br></pre></td></tr></table></figure>

<p><strong>limit语句</strong></p>
<p>用户限制返回的行数</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tb_name LIMIT n;</span><br></pre></td></tr></table></figure>

<p><strong>列别名</strong></p>
<p>紧跟列名，也可以在列名和别名之间加入关键字<code>as</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT col_name AS alas_name, ... FROM tb_name;</span><br></pre></td></tr></table></figure>

<h3 id="2-WHERE语句"><a href="#2-WHERE语句" class="headerlink" title="2 WHERE语句"></a>2 WHERE语句</h3><p>使用where子句，将不满足条件的行过滤掉；where子句紧随from子句</p>
<p><strong>LIKE和RLIKE</strong></p>
<ol>
<li><p>LIKE运算选择类似的值，选择条件可以包含字符或数字</p>
<p><code>%</code> 代表零个或多个字符（任意个字符）<br><code>_</code> 代表一个字符</p>
</li>
<li><p>RLIKE子句是Hive中这个功能的一个扩展，其可以通过<strong>Java的正则表达式</strong>这个更强大的语言来指定匹配条件</p>
</li>
</ol>
<h3 id="3-GROUP-BY语句"><a href="#3-GROUP-BY语句" class="headerlink" title="3 GROUP BY语句"></a>3 GROUP BY语句</h3><p>GROUP BY语句通常会和聚合函数一起使用，按照一个或者多个队列结果进行分组，然后对每个组执行聚合操作。 </p>
<p><strong>having与where不同点</strong></p>
<ol>
<li>where针对<strong>表中的列</strong>发挥作用，查询数据；having针对<strong>查询结果中的列</strong>发挥作用，筛选数据；</li>
<li>where后面不能写分组函数，而having后面可以使用分组函数；</li>
<li>having只用于group by分组统计语句；</li>
</ol>
<h3 id="4-JOIN语句"><a href="#4-JOIN语句" class="headerlink" title="4 JOIN语句"></a>4 JOIN语句</h3><p><strong>等值JOIN</strong></p>
<p>Hive支持通常的SQL JOIN语句，但是<strong>只支持等值连接，不支持非等值连接</strong>。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT s.s_id,s.s_score,stu.s_name,stu.s_birth FROM score s LEFT JOIN student stu ON s.s_id&#x3D;stu.s_id;</span><br></pre></td></tr></table></figure>

<p><strong>内连接（INNER JOIN）</strong></p>
<p>只有进行连接的两个表中都存在与连接条件相匹配的数据才会被保留下来。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM teacher t INNER JOIN course c ON t.t_id&#x3D;c.t_id;</span><br></pre></td></tr></table></figure>

<p><strong>左外连接（LEFT OUTER JOIN）</strong></p>
<p>JOIN操作符左边表中符合WHERE子句的所有记录将会被返回。例如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> teacher t <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> course c <span class="keyword">ON</span> t.t_id <span class="operator">=</span> c.t_id;</span><br></pre></td></tr></table></figure>

<p><strong>右外连接（RIGHT OUTER JOIN）</strong></p>
<p>JOIN操作符右边表中复合WHERE子句的所有记录将会被返回。例如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> teacher t <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> course c <span class="keyword">ON</span> t.t_id <span class="operator">=</span> c.t_id;</span><br></pre></td></tr></table></figure>

<p><strong>多表连接</strong></p>
<p><em><strong>注意：连接n个表，至少需要n-1个连接条件</strong></em>。</p>
<p>多表连接查询，查询老师对应的课程，以及对应的分数，对应的学生</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> teacher t <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> course c <span class="keyword">ON</span> t.t_id <span class="operator">=</span> c.t_id <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> score s <span class="keyword">ON</span> s.c_id<span class="operator">=</span>c.c_id <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> student stu <span class="keyword">ON</span> s.s_id <span class="operator">=</span> stu.s_id;</span><br></pre></td></tr></table></figure>

<h3 id="5-ORDER-BY-和-SORT-BY"><a href="#5-ORDER-BY-和-SORT-BY" class="headerlink" title="5 ORDER BY 和 SORT BY"></a>5 ORDER BY 和 SORT BY</h3><p><strong>ORDER BY</strong>：全局排序(前提：一个reduce)；<code>ASC</code>(升序，默认)，<code>DESC</code>(降序)；ORDER BY子句在SELECT语句的结尾。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT col1,col2,... FROM tb_name GROUP BY col1 ORDER BY col1,col2,... [DESC];</span><br></pre></td></tr></table></figure>

<p>SORT BY：局部排序，每个MapReduce内部进行排序，对全局结果集来说不是排序。</p>
<ol>
<li><p>设置reduce个数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set mapreduce.job.reduces&#x3D;1;</span><br></pre></td></tr></table></figure></li>
<li><p>查看设置reduce个数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set mapreduce.job.reduces;</span><br></pre></td></tr></table></figure></li>
<li><p>查询成绩按照成绩降序排列</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM tb_name SORT BY coln;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="6-DISTRIBUTE-BY"><a href="#6-DISTRIBUTE-BY" class="headerlink" title="6 DISTRIBUTE BY"></a>6 DISTRIBUTE BY</h3><p><strong>Distribute By</strong>：类似MR中partition，进行分区，结合sort by使用。</p>
<p><em><strong>注意，Hive要求DISTRIBUTE BY语句要写在SORT BY语句之前</strong></em>。</p>
<p>对于distribute by进行测试，一定要分配多reduce进行处理，否则无法看到distribute by的效果。</p>
<h3 id="7-CLUSTER-BY"><a href="#7-CLUSTER-BY" class="headerlink" title="7 CLUSTER BY"></a>7 CLUSTER BY</h3><p>当distribute by和sort by字段相同时，可以使用cluster by方式。cluster by除了具有distribute by的功能外还兼具sort by的功能。<strong>但是排序只能是倒序排序，不能指定排序规则为ASC或者DESC</strong>。以下两种写法等价</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM tb_name CLUSTER BY coln;</span><br><span class="line">SELECT * FROM tb_name DISTRIBUTE BY coln SORT BY coln;</span><br></pre></td></tr></table></figure>

<h3 id="8-UNION-ALL"><a href="#8-UNION-ALL" class="headerlink" title="8 UNION ALL"></a>8 UNION ALL</h3><p>union all可以将2个或多个表进行合并。每一个union子查询都必须具有相同的列，而且对应的每个字段的字段类型必须是一致的。</p>
<h2 id="三、调优"><a href="#三、调优" class="headerlink" title="三、调优"></a>三、调优</h2><h3 id="1-使用Explain"><a href="#1-使用Explain" class="headerlink" title="1 使用Explain"></a>1 使用Explain</h3><p>使用explain功能，可以帮助我们学习hive是如何将查询转化成MapReduce任务的。例如查看<code>SELECT * FROM tb_name LIMIT n;</code>转化过程：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tb_name LIMIT n;</span><br></pre></td></tr></table></figure>

<p>理解hive是如何对每个查询进行解析和计划的复杂细节是有用的，这是分析复杂或执行效率低的查询的一个不错的方式。另外，使用<code>EXPLAIN EXTENDED</code>可以产生更多的输出信息。</p>
<h3 id="2-Fetch抓取"><a href="#2-Fetch抓取" class="headerlink" title="2 Fetch抓取"></a>2 Fetch抓取</h3><p>Hive中对某些情况的查询可以不必使用MapReduce计算。例如：SELECT * FROM employees;在这种情况下，Hive可以简单地读取employee对应的存储目录下的文件，然后输出查询结果到控制台。通过设置<code>hive.fetch.task.conversion</code>参数，可以控制查询语句是否走MapReduce。</p>
<h3 id="3-限制调整"><a href="#3-限制调整" class="headerlink" title="3 限制调整"></a>3 限制调整</h3><p>很多情况下LIMIT语句还是需要执行整个查询语句，然后再返回部分结果的。hive中有一个属性可以开启，当使用LIMIT时，其可以对源数据进行抽样。</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&lt;property&gt;</span></span><br><span class="line">	<span class="attr">&lt;name&gt;hive.limit.optimize.enable&lt;/name&gt;</span></span><br><span class="line">	<span class="attr">&lt;value&gt;true.&lt;/value&gt;</span></span><br><span class="line"><span class="attr">&lt;/property&gt;</span></span><br></pre></td></tr></table></figure>

<p>另外还有两个参数可以控制这个操作，就是<code>hive.limit.row.max.size</code>和<code>hive.limit.optimize.limit.file</code>。这个功能有一个缺点就是，有可能输入中有用的数据永远不会被处理到。</p>
<h3 id="4-Join优化"><a href="#4-Join优化" class="headerlink" title="4 Join优化"></a>4 Join优化</h3><p>如果不指定MapJoin或者不符合MapJoin的条件，那么Hive解析器会在Reduce阶段完成join，容易发生数据倾斜。可以用MapJoin把小表全部加载到内存在map端进行join，避免reduce处理。以下是开启MapJoin参数设置：</p>
<ol>
<li><p>设置自动选择Mapjoin</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> hive.auto.convert.join <span class="operator">=</span> <span class="literal">true</span>; </span><br></pre></td></tr></table></figure></li>
<li><p>大表小表的阈值设置（默认25M以下认为是小表）</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> hive.mapjoin.smalltable.filesize<span class="operator">=</span><span class="number">25123456</span>;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="5-本地模式"><a href="#5-本地模式" class="headerlink" title="5 本地模式"></a>5 本地模式</h3><p>大多数的Hadoop Job是需要Hadoop提供的完整的可扩展性来处理大数据集的。不过，有时Hive的输入数据量是非常小的。在这种情况下，为查询触发执行任务时消耗可能会比实际job的执行时间要多的多。对于大多数这种情况，Hive可以通过本地模式在单台机器上处理所有的任务。对于小数据集，执行时间可以明显被缩短。用户可以通过设置<code>hive.exec.mode.local.auto</code>的值为<code>true</code>，来让Hive在适当的时候自动启动这个优化。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SET hive.exec.mode.local.auto&#x3D;true ##开启本地模式</span><br><span class="line">SET hive.exec.mode.local.auto&#x3D;false ##关闭本地模式</span><br></pre></td></tr></table></figure>

<h3 id="6-并行执行"><a href="#6-并行执行" class="headerlink" title="6 并行执行"></a>6 并行执行</h3><p>Hive会将一个查询转化成一个或者多个阶段。这样的阶段可以是MapReduce阶段、抽样阶段、合并阶段、limit阶段。或者Hive执行过程中可能需要的其他阶段。默认情况下，Hive一次只会执行一个阶段。不过，某个特定的job可能包含众多的阶段，而这些阶段可能并非完全互相依赖的，也就是说有些阶段是可以并行执行的，这样可能使得整个job的执行时间缩短。不过，如果有更多的阶段可以并行执行，那么job可能就越快完成。</p>
<p>通过设置参数<code>hive.exec.parallel</code>值为<code>true</code>，就可以开启并发执行。不过，在共享集群中，需要注意下，如果job中并行阶段增多，那么集群利用率就会增加。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET hive.exec.parallel&#x3D;true;</span><br></pre></td></tr></table></figure>

<p>当然，得是在系统资源比较空闲的时候才有优势，否则，没资源，并行也起不来。</p>
<h3 id="7-严格模式"><a href="#7-严格模式" class="headerlink" title="7 严格模式"></a>7 严格模式</h3><p>Hive提供了一个严格模式，可以防止用户执行那些可能意向不到的不好的影响的查询。通过设置属性<code>hive.mapred.mode</code>值为默认是非严格模式nonstrict 。开启严格模式需要修改<code>hive.mapred.mode</code>值为strict，开启严格模式可以禁止3种类型的查询。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SET hive.mapred.mode&#x3D;strict; ##开启严格模式</span><br><span class="line">SET hive.mapred.mode&#x3D;nostrict; ##开启非严格模式</span><br></pre></td></tr></table></figure>

<ol>
<li><p><strong>对于分区表，除非where语句中含有分区字段过滤条件来限制范围，否则不允许执行</strong>。换句话说，就是用户不允许扫描所有分区。进行这个限制的原因是，通常分区表都拥有非常大的数据集，而且数据增加迅速。没有进行分区限制的查询可能会消耗令人不可接受的巨大资源来处理这个表。</p>
</li>
<li><p>对于<strong>使用了order by语句的查询，要求必须使用limit语句</strong>。因为order by为了执行排序过程会将所有的结果数据分发到同一个Reducer中进行处理，强制要求用户增加这个LIMIT语句可以防止Reducer额外执行很长一段时间。</p>
</li>
<li><p><strong>限制笛卡尔积的查询</strong>。对关系型数据库非常了解的用户可能期望在执行查询的时候不使用ON语句而是使用WHERE语句，这样关系数据库的执行优化器就可以高效地将语句转化成那个语句。不幸的是，并不会执行这种优化，因此，如果表足够大，那么这个查询就会出现不可控的情况。</p>
</li>
</ol>
<h3 id="8-GROUP-BY"><a href="#8-GROUP-BY" class="headerlink" title="8 GROUP BY"></a>8 GROUP BY</h3><p>默认情况下，Map阶段同一Key数据分发给一个reduce，当一个key数据过大时就倾斜了。并不是所有的聚合操作都需要在Reduce端完成，很多聚合操作都可以先在Map端进行部分聚合，最后在Reduce端得出最终结果。</p>
<p><strong>开启Map端聚合参数设置</strong></p>
<ol>
<li><p>是否在Map端进行聚合，默认为True</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET hive.map.aggr &#x3D; true;</span><br></pre></td></tr></table></figure></li>
<li><p>在Map端进行聚合操作的条目数目</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET hive.groupby.mapaggr.checkinterval &#x3D; 100000;</span><br></pre></td></tr></table></figure></li>
<li><p>有数据倾斜的时候进行负载均衡（默认是false）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET hive.groupby.skewindata &#x3D; true;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>当选项设定为 true，生成的查询计划会有两个MR Job。</p>
<p>第一个MR Job中，Map的输出结果会随机分布到Reduce中，每个Reduce做部分聚合操作，并输出结果，这样处理的结果是相同的Group By Key有可能被分发到不同的Reduce中，从而达到负载均衡的目的；</p>
<p>第二个MR Job再根据预处理的数据结果按照Group By Key分布到Reduce中（这个过程可以保证相同的Group By Key被分布到同一个Reduce中），最后完成最终的聚合操作。</p>
<h3 id="9-JVM重用"><a href="#9-JVM重用" class="headerlink" title="9 JVM重用"></a>9 JVM重用</h3><p>JVM重用是Hadoop调优参数的内容，其对Hive的性能具有非常大的影响，特别是对于很难避免小文件的场景或task特别多的场景，这类场景大多数执行时间都很短。</p>
<p>Hadoop的默认配置通常是使用派生JVM来执行map和Reduce任务的。这时JVM的启动过程可能会造成相当大的开销，尤其是执行的job包含有成百上千task任务的情况。JVM重用可以使得JVM实例在同一个job中重新使用N次。N的值可以在Hadoop的<code>mapred-site.xml</code>文件(位于$HODOOP_HOME/conf目录下)中进行配置。通常在10-20之间，具体多少需要根据具体业务场景测试得出。也可以在hive当中通过</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET mapred.job.reuse.jvm.num.tasks&#x3D;10;</span><br></pre></td></tr></table></figure>

<p>来设置我们的jvm重用。这个功能的缺点是，开启JVM重用将一直占用使用到的task插槽，以便进行重用，直到任务完成后才能释放。如果某个“不平衡的”job中有某几个reduce task执行的时间要比其他Reduce task消耗的时间多的多的话，那么保留的插槽就会一直空闲着却无法被其他的job使用，直到所有的task都结束了才会释放。</p>
<h3 id="10-索引"><a href="#10-索引" class="headerlink" title="10 索引"></a>10 索引</h3><p>索引可以用来加快含有GROUP BY语句的查询的计算速度。</p>
<h3 id="11-动态分区调整"><a href="#11-动态分区调整" class="headerlink" title="11 动态分区调整"></a>11 动态分区调整</h3><p>往hive分区表中插入数据时，hive提供了一个动态分区功能，其可以基于查询参数的位置去推断分区的名称，从而建立分区。使用hive动态分区，需要进行相应的配置。<strong>hive的动态分区是以第一个表的分区规则，来对应第二个表的分区规则，将第一个表的所有分区，全部拷贝到第二个表中来，第二个表在加载数据的时候，不需要指定分区了，直接用第一个表的分区即可</strong>。</p>
<p><strong>开启动态分区参数设置</strong></p>
<ol>
<li><p>开启动态分区功能（默认true，开启）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET hive.exec.dynamic.partition&#x3D;true;</span><br></pre></td></tr></table></figure></li>
<li><p>设置为非严格模式（动态分区的模式，默认strict，表示必须指定至少一个分区为静态分区，nonstrict模式表示允许所有的分区字段都可以使用动态分区）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET hive.exec.dynamic.partition.mode&#x3D;nonstrict;</span><br></pre></td></tr></table></figure></li>
<li><p>在所有执行MR的节点上，最大一共可以创建多少个动态分区</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET hive.exec.max.dynamic.partitions&#x3D;1000;</span><br></pre></td></tr></table></figure></li>
<li><p>在每个执行MR的节点上，最大可以创建多少个动态分区。该参数需要根据实际的数据来设定。比如：源数据中包含了一年的数据，即day字段有365个值，那么该参数就需要设置成大于365，如果使用默认值100，则会报错。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET hive.exec.max.dynamic.partitions.pernode&#x3D;100</span><br></pre></td></tr></table></figure></li>
<li><p>整个MR Job中，最大可以创建多少个HDFS文件。</p>
<p>在linux系统当中，每个linux用户最多可以开启1024个进程，每一个进程最多可以打开2048个文件，即持有2048个文件句柄，下面这个值越大，就可以打开文件句柄越大</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET hive.exec.max.created.files&#x3D;100000;</span><br></pre></td></tr></table></figure></li>
<li><p>当有空分区生成时，是否抛出异常。一般不需要设置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET hive.error.on.empty.partition&#x3D;false;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="12-推测执行"><a href="#12-推测执行" class="headerlink" title="12 推测执行"></a>12 推测执行</h3><p>在分布式集群环境下，因为程序Bug（包括Hadoop本身的bug），负载不均衡或者资源分布不均等原因，会造成同一个作业的多个任务之间运行速度不一致，有些任务的运行速度可能明显慢于其他任务（比如一个作业的某个任务进度只有50%，而其他所有任务已经运行完毕），则这些任务会拖慢作业的整体执行进度。为了避免这种情况发生，Hadoop采用了推测执行（Speculative Execution）机制，它根据一定的法则推测出“拖后腿”的任务，并为这样的任务启动一个备份任务，让该任务与原始任务同时处理同一份数据，并最终选用最先成功运行完成任务的计算结果作为最终结果。</p>
<p>设置开启推测执行参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SET mapred.map.tasks.speculative.execution&#x3D;true</span><br><span class="line">SET mapred.reduce.tasks.speculative.execution&#x3D;true</span><br><span class="line">SET hive.mapred.reduce.tasks.speculative.execution&#x3D;true</span><br></pre></td></tr></table></figure>

<p>关于调优推测执行变量，很难给出具体的建议。如果对运行时的偏差非常敏感的话，可以将这些功能关掉。</p>
<h3 id="13-Count-distinct"><a href="#13-Count-distinct" class="headerlink" title="13 Count(distinct)"></a>13 Count(distinct)</h3><p>数据量小的时候无所谓，数据量大的情况下，由于COUNT DISTINCT操作需要用一个Reduce Task来完成，这一个Reduce需要处理的数据量太大，就会导致整个Job很难完成，一般COUNT DISTINCT使用先GROUP BY再COUNT的方式替换：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT COUNT(DISTINCT s_id) FROM score;</span><br><span class="line">SELECT COUNT(s_id) FROM (SELECT id FROM score GROUP BY s_id) a;</span><br></pre></td></tr></table></figure>

<p>虽然会多用一个job来完成，但是在数据量大的情况下，这个绝对是值得的。</p>
<h3 id="14-笛卡尔积"><a href="#14-笛卡尔积" class="headerlink" title="14 笛卡尔积"></a>14 笛卡尔积</h3><p>尽量避免笛卡尔积，即避免join的时候不加on条件，或者无效的on条件，Hive只能使用1个reducer来完成笛卡尔积。</p>
<h2 id="四、数据压缩"><a href="#四、数据压缩" class="headerlink" title="四、数据压缩"></a>四、数据压缩</h2><p>在实际工作当中，hive当中处理的数据，一般都需要经过压缩来节省我们的MR处理的网络带宽。</p>
<p><strong>MR支持的压缩编码</strong></p>
<table>
<thead>
<tr>
<th>压缩格式</th>
<th>工具</th>
<th>算法</th>
<th>文件扩展名</th>
<th>是否可切分</th>
</tr>
</thead>
<tbody><tr>
<td>DEFAULT</td>
<td>无</td>
<td>DEFAULT</td>
<td>.deflate</td>
<td>否</td>
</tr>
<tr>
<td>Gzip</td>
<td>gzip</td>
<td>DEFAULT</td>
<td>.gz</td>
<td>否</td>
</tr>
<tr>
<td>bzip2</td>
<td>bzip2</td>
<td>bzip2</td>
<td>.bz2</td>
<td>是</td>
</tr>
<tr>
<td>LZO</td>
<td>lzop</td>
<td>LZO</td>
<td>.lzo</td>
<td>否</td>
</tr>
<tr>
<td>LZ4</td>
<td>无</td>
<td>LZ4</td>
<td>.lz4</td>
<td>否</td>
</tr>
<tr>
<td>Snappy</td>
<td>无</td>
<td>Snappy</td>
<td>.snappy</td>
<td>否</td>
</tr>
</tbody></table>
<p>为了支持多种压缩/解压缩算法，Hadoop引入了编码/解码器，如下表所示</p>
<table>
<thead>
<tr>
<th>压缩格式</th>
<th>对应的编码/解码器</th>
</tr>
</thead>
<tbody><tr>
<td>DEFLATE</td>
<td>org.apache.hadoop.io.compress.DefaultCodec</td>
</tr>
<tr>
<td>gzip</td>
<td>org.apache.hadoop.io.compress.GzipCodec</td>
</tr>
<tr>
<td>bzip2</td>
<td>org.apache.hadoop.io.compress.BZip2Codec</td>
</tr>
<tr>
<td>LZO</td>
<td>com.hadoop.compression.lzo.LzopCodec</td>
</tr>
<tr>
<td>LZ4</td>
<td>org.apache.hadoop.io.compress.Lz4Codec</td>
</tr>
<tr>
<td>Snappy</td>
<td>org.apache.hadoop.io.compress.SnappyCodec</td>
</tr>
</tbody></table>
<p><strong>压缩性能的比较</strong></p>
<table>
<thead>
<tr>
<th>压缩算法</th>
<th>原始文件大小</th>
<th>压缩文件大小</th>
<th>压缩速度</th>
<th>解压速度</th>
</tr>
</thead>
<tbody><tr>
<td>gzip</td>
<td>8.3GB</td>
<td>1.8GB</td>
<td>17.5MB/s</td>
<td>58MB/s</td>
</tr>
<tr>
<td>bzip2</td>
<td>8.3GB</td>
<td>1.1GB</td>
<td>2.4MB/s</td>
<td>9.5MB/s</td>
</tr>
<tr>
<td>LZO</td>
<td>8.3GB</td>
<td>2.9GB</td>
<td>49.3MB/s</td>
<td>74.6MB/s</td>
</tr>
</tbody></table>
<blockquote>
<p><a target="_blank" rel="noopener" href="http://google.github.io/snappy/">http://google.github.io/snappy/</a></p>
<p>On a single core of a Core i7 processor in 64-bit mode, Snappy compresses at about <code>250 MB/sec</code> or more and decompresses at about <code>500 MB/se</code>c or more.</p>
</blockquote>
<p><strong>压缩配置参数</strong></p>
<p>要在Hadoop中启用压缩，可以配置如下参数（mapred-site.xml文件中）：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>默认值</th>
<th>阶段</th>
<th>建议</th>
</tr>
</thead>
<tbody><tr>
<td>io.compression.codecs<br/>(在core-site.xml中配置)</td>
<td>DefaultCodec,   <br/>GzipCodec, <br/>BZip2Codec,  <br/> Lz4Codec,<br/>在org.apache.hadoop.io.compress下</td>
<td>输入压缩</td>
<td>Hadoop使用文件扩展名判断是否支持某种编解码器</td>
</tr>
<tr>
<td>mapreduce.map.output.compress</td>
<td>false</td>
<td>mapper输出</td>
<td>这个参数设为true启用压缩</td>
</tr>
<tr>
<td>mapreduce.map.output.compress.codec</td>
<td>DefaultCodec<br/>（在org.apache.hadoop.io.compress下）</td>
<td>mapper输出</td>
<td>使用LZO、LZ4或snappy编解码器在此阶段压缩数据</td>
</tr>
<tr>
<td>mapreduce.output.fileoutputformat.compress</td>
<td>false</td>
<td>reducer输出</td>
<td>这个参数设为true启用压缩</td>
</tr>
<tr>
<td>mapreduce.output.fileoutputformat.compress.codec</td>
<td>org.apache.hadoop.io.compress.   DefaultCodec</td>
<td>reducer输出</td>
<td>使用标准工具或者编解码器，如gzip和bzip2</td>
</tr>
<tr>
<td>mapreduce.output.fileoutputformat.compress.type</td>
<td>RECORD</td>
<td>reducer输出</td>
<td>SequenceFile输出使用的压缩类型：NONE和BLOCK</td>
</tr>
</tbody></table>
<h3 id="1-开启Map输出阶段压缩"><a href="#1-开启Map输出阶段压缩" class="headerlink" title="1 开启Map输出阶段压缩"></a>1 开启Map输出阶段压缩</h3><p>开启map输出阶段压缩可以减少job中map和Reduce task间数据传输量。具体配置如下：</p>
<ol>
<li><p>开启hive中间传输数据压缩功能</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET hive.exec.compress.intermediate&#x3D;true;</span><br></pre></td></tr></table></figure></li>
<li><p>开启mapreduce中map输出压缩功能</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET mapreduce.map.output.compress&#x3D;true;</span><br></pre></td></tr></table></figure></li>
<li><p>设置mapreduce中map输出数据的压缩方式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET mapreduce.map.output.compress.codec&#x3D; org.apache.hadoop.io.compress.SnappyCodec;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="2-开启Reduce输出阶段压缩"><a href="#2-开启Reduce输出阶段压缩" class="headerlink" title="2 开启Reduce输出阶段压缩"></a>2 开启Reduce输出阶段压缩</h3><p>当Hive将输出写入到表中时，输出内容同样可以进行压缩。属性<code>hive.exec.compress.output</code>控制着这个功能。用户可能需要保持默认设置文件中的默认值<code>false</code>，这样默认的输出就是非压缩的纯文本文件了。用户可以通过在查询语句或执行脚本中设置这个值为true，来开启输出结果压缩功能。具体配置如下：</p>
<ol>
<li><p>开启hive最终输出数据压缩功能</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET hive.exec.compress.output&#x3D;true;</span><br></pre></td></tr></table></figure></li>
<li><p>开启mapreduce最终输出数据压缩</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET mapreduce.output.fileoutputformat.compress&#x3D;true;</span><br></pre></td></tr></table></figure></li>
<li><p>设置mapreduce最终数据输出压缩方式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET mapreduce.output.fileoutputformat.compress.codec &#x3D; org.apache.hadoop.io.compress.SnappyCodec;</span><br></pre></td></tr></table></figure></li>
<li><p>设置mapreduce最终数据输出压缩为块压缩</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET mapreduce.output.fileoutputformat.compress.type&#x3D;BLOCK;</span><br></pre></td></tr></table></figure></li>
<li><p>测试一下输出结果是否是压缩文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT overwrite LOCAL DIRECTORY &#39;&lt;directory&gt;&#39; SELECT * FROM score DISTRIBUTE BY s_id SORT BY s_id DESC;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="五、数据存储格式"><a href="#五、数据存储格式" class="headerlink" title="五、数据存储格式"></a>五、数据存储格式</h2><p>Hive支持的存储数的格式主要有：<strong>TEXTFILE</strong>（行式存储） 、<strong>SEQUENCEFILE</strong>(行式存储)、<strong>ORC</strong>（列式存储）、<strong>PARQUET</strong>（列式存储）。</p>
<h3 id="1-列式存储和行式存储"><a href="#1-列式存储和行式存储" class="headerlink" title="1 列式存储和行式存储"></a>1 列式存储和行式存储</h3><img src="/2021/05/19/Hive%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/wj-hive-20191006006.png" class="">

<p>上图左边为逻辑表，右边第一个为行式存储，第二个为列式存储。</p>
<p><strong>行存储的特点：</strong> 查询满足条件的一整行数据的时候，列存储则需要去每个聚集的字段找到对应的每个列的值，行存储只需要找到其中一个值，其余的值都在相邻地方，所以此时行存储查询的速度更快。</p>
<p><strong>列存储的特点：</strong> 因为每个字段的数据聚集存储，在查询只需要少数几个字段的时候，能大大减少读取的数据量；每个字段的数据类型一定是相同的，列式存储可以针对性的设计更好的设计压缩算法。</p>
<h3 id="2-常用数据存储格式"><a href="#2-常用数据存储格式" class="headerlink" title="2 常用数据存储格式"></a>2 常用数据存储格式</h3><p><strong>TEXTFILE格式</strong></p>
<p>默认格式，数据不做压缩，磁盘开销大，数据解析开销大。可结合Gzip、Bzip2使用(系统自动检查，执行查询时自动解压)，但使用这种方式，hive不会对数据进行切分，从而无法对数据进行并行操作。</p>
<p><strong>ORC格式</strong></p>
<p>Orc (Optimized Row Columnar)是hive 0.11版里引入的新的存储格式。可以看到每个Orc文件由1个或多个stripe组成，每个stripe250MB大小，每个Stripe里有三部分组成，分别是：</p>
<ul>
<li><strong>Index Data</strong>：某些列的索引数据</li>
<li><strong>Row Data</strong>：真正的数据存储</li>
<li><strong>Stripe Footer</strong>：stripe的元数据信息</li>
</ul>
<img src="/2021/05/19/Hive%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/wj-hive-20191006007.png" class="">

<p><strong>PARQUET格式</strong></p>
<p>Parquet是面向分析型业务的列式存储格式，由Twitter和Cloudera合作开发，Parquet文件是以二进制方式存储的，所以是不可以直接读取的，文件中包括该文件的数据和元数据，因此Parquet格式文件是自解析的。通常情况下，在存储Parquet数据的时候会按照Block大小设置行组的大小，由于一般情况下每一个Mapper任务处理数据的最小单位是一个Block，这样可以把每一个行组由一个Mapper任务处理，增大任务执行并行度。Parquet文件的格式如下图所示。</p>
<img src="/2021/05/19/Hive%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/wj-hive-20191006008.png" class="">

<h2 id="六、函数"><a href="#六、函数" class="headerlink" title="六、函数"></a>六、函数</h2><h3 id="1-内置函数"><a href="#1-内置函数" class="headerlink" title="1 内置函数"></a>1 内置函数</h3><p>内容较多，需要用到的时候再查也不迟；查询方式：</p>
<ul>
<li><p>《Hive官方文档》：<a target="_blank" rel="noopener" href="https://cwiki.apache.org/confluence/display/Hive/LanguageManual+UDF">https://cwiki.apache.org/confluence/display/Hive/LanguageManual+UDF</a></p>
</li>
<li><p>《Hive编程指南》第六章 6.1.4 使用函数</p>
</li>
<li><p>在CLI中使用命令查询</p>
<ol>
<li><p>查看系统自带的函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW functions;</span><br></pre></td></tr></table></figure></li>
<li><p>显示自带函数的用法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DESC FUNCTION func_name;</span><br><span class="line">-- 详细显示用法</span><br><span class="line">DESC FUNCTION EXTENDED func_name;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
<h3 id="2-自定义函数"><a href="#2-自定义函数" class="headerlink" title="2 自定义函数"></a>2 自定义函数</h3><p>Hive 自带了一些函数，比如：max/min等，当hive提供的内置函数无法满足你的业务处理需求时，此时就可以考虑使用用户自定义函数(UDF：user-defined function）。根据用户自定义函数类别分为以下三种：</p>
<ol>
<li><strong>UDF（User-Defined-Function）</strong>：一进一出</li>
<li><strong>UDAF（User-Defined Aggregation Function）</strong>：聚集函数，多进一出，类似于：count/max/min</li>
<li><strong>UDTF（User-Defined Table-Generating Functions）</strong>：一进多出，如lateral view explore()</li>
</ol>
<p>官方文档地址：<a target="_blank" rel="noopener" href="https://cwiki.apache.org/confluence/display/Hive/HivePlugins">https://cwiki.apache.org/confluence/display/Hive/HivePlugins</a></p>
<p><strong>编程步骤：</strong></p>
<ol>
<li>继承org.apache.hadoop.hive.ql.UDF</li>
<li>需要实现evaluate函数；evaluate函数支持重载；</li>
</ol>
<p><strong>注意事项</strong></p>
<ol>
<li>UDF必须要有返回类型，可以返回null，但是返回类型不能为void；</li>
<li><strong>UDF中常用Text/LongWritable等类型，不推荐使用java类型；</strong></li>
</ol>
<p><strong>简单UDF示例</strong></p>
<ol>
<li><p>需要的依赖包;</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">org.apache.hive：hive-exec</span>:<span class="string">2.7.5</span></span><br><span class="line"><span class="meta">org.apache.hadoop</span>:<span class="string">hadoop-common:2.7.5</span></span><br></pre></td></tr></table></figure></li>
<li><p>开发java类继承UDF，并重载evaluate 方法;</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyUDF</span> <span class="keyword">extends</span> <span class="title">UDF</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Text <span class="title">evaluate</span><span class="params">(<span class="keyword">final</span> Text str)</span></span>&#123;</span><br><span class="line">        String tmp_str = str.toString();</span><br><span class="line">        <span class="keyword">if</span>(str != <span class="keyword">null</span> &amp;&amp; !tmp_str.equals(<span class="string">&quot;&quot;</span>))&#123;</span><br><span class="line">          String str_ret = tmp_str.substring(<span class="number">0</span>, <span class="number">1</span>).toUpperCase() + tmp_str.substring(<span class="number">1</span>);</span><br><span class="line">          <span class="keyword">return</span>  <span class="keyword">new</span> Text(str_ret);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  <span class="keyword">new</span> Text(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>将项目打包，并上传到hive的lib目录下;</p>
</li>
<li><p>Hive的客户端添加jar包</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add jar /hive-2.1.1/lib/udf.jar</span><br></pre></td></tr></table></figure></li>
<li><p>设置函数与自定义的函数关联;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 不加TEMPORARY关键字，则为永久函数</span><br><span class="line">CREATE TEMPORARY FUNCTION my_upper AS &#39;cn.wjqixige.udf.MyUDF&#39;;</span><br></pre></td></tr></table></figure></li>
<li><p>使用自定义函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT my_upper(&#39;abc&#39;);</span><br></pre></td></tr></table></figure></li>
</ol>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Hive/" rel="tag"># Hive</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/05/18/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9/" rel="prev" title="大数据开发过程中常用的知识点">
                  <i class="fa fa-chevron-left"></i> 大数据开发过程中常用的知识点
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2021/05/24/Hadoop%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%9AYarn%E8%B5%84%E6%BA%90%E8%B0%83%E5%BA%A6/" rel="next" title="Hadoop基础知识：Yarn资源调度">
                  Hadoop基础知识：Yarn资源调度 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>





<script src="/js/comments.js"></script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">浙ICP备18041583号-1 </a>
      <img src="/images/beian.png">
  </div>

<div class="copyright">
  &copy; 2018 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Mr.wj</span>
</div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
